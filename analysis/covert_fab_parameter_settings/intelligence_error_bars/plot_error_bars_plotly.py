"""
DEPRECATED: Do not use this Python script to generate the intelligence accuracy plot.

The authoritative version is generated by JavaScript in:
  frontend/black_project_detection_section.js -> createIntelligenceAccuracyPlot(elementId)

That JavaScript function renders the plot dynamically and can be reused across
multiple elements (main page and tooltips) by passing different element IDs.

This file is kept for reference only.
"""

import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from error_bars import stated_error_bars, estimated_quantities, ground_truth_quantities, categories as estimate_categories, labels
import sys
sys.path.insert(0, '../..')
from plotly_style import STYLE, save_plot, save_html

# Color scheme
COLORS = [STYLE['blue'], STYLE['purple'], STYLE['teal'], STYLE['colors']['accent'], STYLE['dark_teal'], STYLE['red']]

# Process stated error bars data
central_estimates = []
lower_bounds = []
upper_bounds = []
upper_percent_errors = []
lower_percent_errors = []
categories = []

for entry in stated_error_bars:
    if entry.get("possessor") == "Russian Federation" and entry["min"] == 1000 and entry["max"] == 2000:
        continue

    min_val = entry["min"]
    max_val = entry["max"]
    central_estimate = (min_val + max_val) / 2
    central_estimates.append(central_estimate)
    lower_bounds.append(min_val)
    upper_bounds.append(max_val)
    categories.append(entry["category"])

    upper_percent_error = ((max_val - central_estimate) / central_estimate) * 100
    upper_percent_errors.append(upper_percent_error)
    lower_percent_error = ((central_estimate - min_val) / central_estimate) * 100
    lower_percent_errors.append(lower_percent_error)

median_upper_percent_error = np.median(upper_percent_errors)
median_lower_percent_error = np.median(lower_percent_errors)
upper_slope = 1 + (median_upper_percent_error / 100)
lower_slope = 1 - (median_lower_percent_error / 100)

# Process estimate vs reality data
estimate_percent_errors = []
for est, truth in zip(estimated_quantities, ground_truth_quantities):
    if truth != 0:
        percent_error = abs((est - truth) / truth) * 100
        estimate_percent_errors.append(percent_error)

median_estimate_error = np.median(estimate_percent_errors)
estimate_upper_slope = 1 + (median_estimate_error / 100)
estimate_lower_slope = 1 - (median_estimate_error / 100)

# Create subplots
fig = make_subplots(rows=1, cols=2, subplot_titles=('Stated ranges', 'Estimate vs. ground truth'),
                    horizontal_spacing=0.12)

# Color map for categories
unique_categories = list(set(categories))
category_color_map = {cat: COLORS[i % len(COLORS)] for i, cat in enumerate(unique_categories)}

# ========== LEFT SUBPLOT: Stated Error Bars ==========
max_range = max(max(central_estimates), max(upper_bounds))
min_range = min(min(central_estimates), min(lower_bounds))
x_line = np.linspace(min_range, max_range, 100)

# Add y=x line
fig.add_trace(go.Scatter(
    x=x_line, y=x_line,
    mode='lines',
    line=dict(color='gray', width=1, dash='dot'),
    showlegend=False,
    hoverinfo='skip'
), row=1, col=1)

# Add error margin band
fig.add_trace(go.Scatter(
    x=np.concatenate([x_line, x_line[::-1]]),
    y=np.concatenate([upper_slope * x_line, (lower_slope * x_line)[::-1]]),
    fill='toself',
    fillcolor='rgba(128, 128, 128, 0.2)',
    line=dict(width=0),
    name=f'Median error = {median_upper_percent_error:.1f}%',
    hoverinfo='skip'
), row=1, col=1)

# Add data points by category
plotted_categories = set()
for i in range(len(central_estimates)):
    color = category_color_map[categories[i]]
    show_legend = categories[i] not in plotted_categories
    if show_legend:
        plotted_categories.add(categories[i])

    # Error bar line
    fig.add_trace(go.Scatter(
        x=[central_estimates[i], central_estimates[i]],
        y=[lower_bounds[i], upper_bounds[i]],
        mode='lines',
        line=dict(color=color, width=1),
        opacity=0.3,
        showlegend=False,
        hoverinfo='skip'
    ), row=1, col=1)

    # Upper and lower points
    fig.add_trace(go.Scatter(
        x=[central_estimates[i]],
        y=[upper_bounds[i]],
        mode='markers',
        marker=dict(size=STYLE['marker_size'], color=color),
        name=categories[i] if show_legend else None,
        showlegend=show_legend,
        legendgroup=categories[i],
        hovertemplate=f'{categories[i]}<br>Central: %{{x:.0f}}<br>Upper: %{{y:.0f}}<extra></extra>'
    ), row=1, col=1)

    fig.add_trace(go.Scatter(
        x=[central_estimates[i]],
        y=[lower_bounds[i]],
        mode='markers',
        marker=dict(size=STYLE['marker_size'], color=color),
        showlegend=False,
        legendgroup=categories[i],
        hovertemplate=f'{categories[i]}<br>Central: %{{x:.0f}}<br>Lower: %{{y:.0f}}<extra></extra>'
    ), row=1, col=1)

# ========== RIGHT SUBPLOT: Estimate vs Reality ==========
unique_estimate_categories = list(set(estimate_categories))
estimate_category_color_map = {cat: COLORS[i % len(COLORS)] for i, cat in enumerate(unique_estimate_categories)}

max_range_est = max(max(estimated_quantities), max(ground_truth_quantities))
min_range_est = min(min(estimated_quantities), min(ground_truth_quantities))
x_line_est = np.linspace(min_range_est, max_range_est, 100)

# Add y=x line
fig.add_trace(go.Scatter(
    x=x_line_est, y=x_line_est,
    mode='lines',
    line=dict(color='gray', width=1, dash='dot'),
    showlegend=False,
    hoverinfo='skip'
), row=1, col=2)

# Add error margin band
fig.add_trace(go.Scatter(
    x=np.concatenate([x_line_est, x_line_est[::-1]]),
    y=np.concatenate([estimate_upper_slope * x_line_est, (estimate_lower_slope * x_line_est)[::-1]]),
    fill='toself',
    fillcolor='rgba(128, 128, 128, 0.2)',
    line=dict(width=0),
    name=f'Median error = {median_estimate_error:.1f}%',
    hoverinfo='skip'
), row=1, col=2)

# Add data points
plotted_estimate_categories = set()
for i in range(len(estimated_quantities)):
    color = estimate_category_color_map[estimate_categories[i]]
    show_legend = estimate_categories[i] not in plotted_estimate_categories
    if show_legend:
        plotted_estimate_categories.add(estimate_categories[i])

    fig.add_trace(go.Scatter(
        x=[ground_truth_quantities[i]],
        y=[estimated_quantities[i]],
        mode='markers',
        marker=dict(size=STYLE['marker_size'], color=color),
        name=estimate_categories[i] if show_legend else None,
        showlegend=show_legend,
        legendgroup=f'est_{estimate_categories[i]}',
        hovertemplate=f'{estimate_categories[i]}<br>Ground truth: %{{x:.0f}}<br>Estimate: %{{y:.0f}}<extra></extra>'
    ), row=1, col=2)

# Add labels for notable points
label_positions = {
    8: dict(ax=30, ay=-40),
    1: dict(ax=30, ay=40),
    3: dict(ax=30, ay=-60)
}

for label_data in labels:
    idx = label_data["index"]
    label_text = label_data["label"]
    pos = label_positions.get(idx, dict(ax=20, ay=-20))
    fig.add_annotation(
        x=ground_truth_quantities[idx],
        y=estimated_quantities[idx],
        text=label_text,
        showarrow=True,
        arrowhead=2,
        arrowsize=0.5,
        arrowwidth=1,
        arrowcolor='gray',
        ax=pos['ax'],
        ay=pos['ay'],
        bgcolor='white',
        bordercolor='gray',
        borderwidth=1,
        borderpad=3,
        font=dict(size=STYLE['font_size_annotation']),
        xref='x2', yref='y2'
    )

# Update layout
fig.update_layout(
    width=STYLE['wide_width'],
    height=STYLE['wide_height'],
    plot_bgcolor='white',
    paper_bgcolor='white',
    font=dict(size=STYLE['font_size_base']),
    margin=STYLE['margin_with_title'],
    hoverlabel=STYLE['hoverlabel'],
    legend=dict(
        x=0.02, y=0.98,
        xanchor='left', yanchor='top',
        bgcolor='rgba(255, 255, 255, 0.9)',
        bordercolor=STYLE['axis_line_color'], borderwidth=1,
        font=dict(size=STYLE['font_size_legend'])
    )
)

# Update axes
fig.update_xaxes(
    title=dict(text='Central Estimate (Midpoint)', font=dict(size=STYLE['font_size_axis_title'])),
    tickfont=dict(size=STYLE['font_size_tick']),
    gridcolor=STYLE['grid_color'],
    linecolor=STYLE['axis_line_color'], showline=True,
    row=1, col=1
)
fig.update_yaxes(
    title=dict(text='Stated estimate range', font=dict(size=STYLE['font_size_axis_title'])),
    tickfont=dict(size=STYLE['font_size_tick']),
    gridcolor=STYLE['grid_color'],
    linecolor=STYLE['axis_line_color'], showline=True,
    row=1, col=1
)
fig.update_xaxes(
    title=dict(text='Ground Truth', font=dict(size=STYLE['font_size_axis_title'])),
    tickfont=dict(size=STYLE['font_size_tick']),
    gridcolor=STYLE['grid_color'],
    linecolor=STYLE['axis_line_color'], showline=True,
    row=1, col=2
)
fig.update_yaxes(
    title=dict(text='Estimate', font=dict(size=STYLE['font_size_axis_title'])),
    tickfont=dict(size=STYLE['font_size_tick']),
    gridcolor=STYLE['grid_color'],
    linecolor=STYLE['axis_line_color'], showline=True,
    row=1, col=2
)

# Save
save_plot(fig, 'error_bars_plot.png', wide=True)
save_html(fig, 'error_bars_plot.html')

print(f"Median upper percent error: {median_upper_percent_error:.2f}%")
print(f"Median estimate vs reality error: {median_estimate_error:.2f}%")
