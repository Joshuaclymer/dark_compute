<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Covert Compute Production Model</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="config.js"></script>
    <script src="utilities.js"></script>
    <script src="initial_stock_section.js"></script>
    <script src="covert_data_centers_section.js"></script>
    <script src="covert_fab_section.js"></script>
    <script src="black_project_top_section.js"></script>
    <script src="black_project_rate_section.js"></script>
    <script src="black_project_detection_section.js"></script>
    <script src="black_project_main.js"></script>
    <script>
        // Function to send errors to backend
        function logErrorToBackend(errorData) {
            fetch('/log_client_error', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(errorData)
            }).catch(err => console.error('Failed to log error to backend:', err));
        }

        // Global error handler to catch and display all JavaScript errors
        window.addEventListener('error', function(event) {
            const errorData = {
                message: event.message,
                source: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack || 'No stack trace available'
            };

            console.error('Global error caught:', event.error);
            console.error('Error message:', event.message);
            console.error('Error stack:', event.error?.stack);

            // Send to backend
            logErrorToBackend(errorData);

            // Display error in UI
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:20px;right:20px;background:#ff4444;color:white;padding:15px;border-radius:5px;max-width:400px;z-index:10000;font-family:monospace;font-size:12px;';
            errorDiv.innerHTML = `<strong>JavaScript Error:</strong><br>${event.message}<br><small>${event.filename}:${event.lineno}</small>`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 10000);
        });

        // Catch unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            const errorData = {
                message: 'Unhandled Promise Rejection',
                reason: String(event.reason),
                stack: event.reason?.stack || 'No stack trace available'
            };

            console.error('Unhandled promise rejection:', event.reason);

            // Send to backend
            logErrorToBackend(errorData);
        });
    </script>
</head>
<body>
    <!-- Global tooltip (outside sidebar to avoid clipping) -->
    <div id="globalTooltip"></div>

    <!-- Include the sidebar -->
    {% include 'sidebar.html' %}

    <div class="main-content">
        <div class="loading active" id="loading">
            <div class="loading-spinner"></div>
        </div>

        <div id="plots" style="display: none;">
            <!-- Dark Compute Model Section -->
            {% include 'black_project_top_section.html' %}
            {% include 'black_project_rate_section.html' %}

            <!-- Detailed Breakdown Sections (hidden on mobile) -->
            <div class="detailed-breakdown-sections">
                <!-- Initial Stock Section -->
                {% include 'initial_stock_section.html' %}

                <!-- Covert Datacenters Section -->
                {% include 'covert_data_centers_section.html' %}

                <!-- Covert Fab Section -->
                {% include 'covert_fab_section.html' %}
            </div>
        </div>
    </div>

    <script>
        // Mobile menu toggle functionality
        function initializeMobileMenu() {
            const mobileTopBar = document.getElementById('mobileTopBar');
            const sidebar = document.querySelector('.sidebar');

            if (mobileTopBar && sidebar) {
                // Toggle sidebar on top bar click
                mobileTopBar.addEventListener('click', (e) => {
                    e.stopPropagation();
                    sidebar.classList.toggle('open');
                    document.body.classList.toggle('sidebar-open');
                });

                // Close sidebar when clicking on overlay
                document.addEventListener('click', (e) => {
                    if (sidebar.classList.contains('open') &&
                        !sidebar.contains(e.target) &&
                        !mobileTopBar.contains(e.target)) {
                        sidebar.classList.remove('open');
                        document.body.classList.remove('sidebar-open');
                    }
                });

                // Close sidebar when an input triggers simulation (Enter key on mobile)
                const sidebarInputs = document.querySelectorAll('.sidebar input, .sidebar select');
                sidebarInputs.forEach(input => {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && window.innerWidth <= 768) {
                            sidebar.classList.remove('open');
                            document.body.classList.remove('sidebar-open');
                        }
                    });
                });
            }
        }

        // Wait for DOM to be ready and sidebar to be loaded
        function initializeApp() {
            const runButton = document.getElementById('runSimulation');
            const statusDiv = document.getElementById('status');
            const loadingDiv = document.getElementById('loading');

            // Initialize mobile menu
            initializeMobileMenu();

            // If button doesn't exist yet, wait and try again
            if (!runButton) {
                setTimeout(initializeApp, 100);
                return;
            }

            // Initialize parameter displays with current values
            if (typeof updateParameterDisplays === 'function') {
                updateParameterDisplays();
            }
        const plotsDiv = document.getElementById('plots');

        function setStatus(message, type) {
            if (statusDiv) {
                statusDiv.textContent = message;
                statusDiv.className = 'status ' + type;
            }
        }

        function getParameters() {
            // Helper function to safely get element value with debugging
            function getValue(id, type = 'float', defaultValue = null) {
                const el = document.getElementById(id);
                if (!el) {
                    // Return default value if element not found and default provided
                    if (defaultValue !== null) {
                        console.warn(`Element with id '${id}' not found, using default: ${defaultValue}`);
                        return defaultValue;
                    }
                    const msg = `Element with id '${id}' not found!`;
                    console.error(msg);
                    throw new Error(msg);
                }
                if (type === 'float') return parseFloat(el.value);
                if (type === 'int') return parseInt(el.value);
                if (type === 'checked') return el.checked;
                return el.value;
            }

            return {
                // Simulation settings (using dot notation for nested Parameters structure)
                'simulation_settings.agreement_start_year': getValue('agreement_year'),
                'simulation_settings.num_years_to_simulate': getValue('num_years_to_simulate'),
                'simulation_settings.time_step_years': getValue('increment'),
                'simulation_settings.num_simulations': getValue('num_simulations', 'int'),

                // Covert project properties
                'black_project_properties.run_a_black_project': getValue('run_black_project', 'checked', true),
                'black_project_properties.proportion_of_initial_compute_stock_to_divert': getValue('proportion_of_initial_chip_stock_to_divert'),
                'black_project_properties.datacenter_construction_labor': getValue('datacenter_construction_labor', 'int'),
                'black_project_properties.years_before_agreement_year_prc_starts_building_black_datacenters': getValue('years_before_agreement_year_prc_starts_building_black_datacenters', 'int'),
                'black_project_properties.build_a_black_fab': getValue('build_covert_fab', 'checked', true),
                'black_project_properties.black_fab_operating_labor': getValue('operating_labor', 'int'),
                'black_project_properties.black_fab_construction_labor': getValue('construction_labor', 'int'),
                'black_project_properties.black_fab_process_node': getValue('process_node', 'string'),
                'black_project_properties.black_fab_proportion_of_prc_lithography_scanners_devoted': getValue('scanner_proportion'),
                'black_project_properties.researcher_headcount': getValue('researcher_headcount', 'int'),

                // Covert project parameters - detection
                'black_project_parameters.p_project_exists': getValue('black_project_parameters.p_project_exists'),
                'black_project_parameters.detection_parameters.mean_detection_time_for_100_workers': getValue('mean_detection_time_100'),
                'black_project_parameters.detection_parameters.mean_detection_time_for_1000_workers': getValue('mean_detection_time_1000'),
                'black_project_parameters.detection_parameters.variance_of_detection_time_given_num_workers': getValue('variance_detection_time'),

                // Exogenous trends parameters
                'black_project_parameters.exogenous_trends.total_prc_compute_stock_in_2025': getValue('total_prc_compute_stock_in_2025') * 1e6,
                'black_project_parameters.exogenous_trends.annual_growth_rate_of_prc_compute_stock_p10': getValue('annual_growth_rate_of_prc_compute_stock_p10'),
                'black_project_parameters.exogenous_trends.annual_growth_rate_of_prc_compute_stock_p50': getValue('annual_growth_rate_of_prc_compute_stock_p50'),
                'black_project_parameters.exogenous_trends.annual_growth_rate_of_prc_compute_stock_p90': getValue('annual_growth_rate_of_prc_compute_stock_p90'),
                'black_project_parameters.exogenous_trends.proportion_of_prc_chip_stock_produced_domestically_2026': getValue('proportion_of_prc_chip_stock_produced_domestically_2026'),
                'black_project_parameters.exogenous_trends.proportion_of_prc_chip_stock_produced_domestically_2030': getValue('proportion_of_prc_chip_stock_produced_domestically_2030'),
                'black_project_parameters.detection_parameters.us_intelligence_median_error_in_estimate_of_prc_compute_stock': getValue('us_intelligence_median_error_in_estimate_of_prc_compute_stock'),
                'black_project_parameters.exogenous_trends.energy_efficiency_of_prc_stock_relative_to_state_of_the_art': getValue('energy_efficiency_of_prc_stock_relative_to_state_of_the_art'),
                'black_project_parameters.exogenous_trends.h100_power_watts': getValue('h100_power_watts'),

                // Slowdown counterfactual parameters - not sent, backend uses default from paramaters.py

                // Survival rate parameters
                'black_project_parameters.survival_rate_parameters.initial_hazard_rate_p50': getValue('initial_hazard_rate_p50'),
                'black_project_parameters.survival_rate_parameters.increase_of_hazard_rate_per_year_p50': getValue('increase_of_hazard_rate_per_year_p50'),
                'black_project_parameters.survival_rate_parameters.hazard_rate_p25_relative_to_p50': getValue('hazard_rate_p25_relative_to_p50'),
                'black_project_parameters.survival_rate_parameters.hazard_rate_p75_relative_to_p50': getValue('hazard_rate_p75_relative_to_p50'),

                // Covert datacenter parameters
                'black_project_parameters.datacenter_model_parameters.max_proportion_of_PRC_energy_consumption': getValue('max_proportion_of_PRC_energy_consumption'),
                'black_project_parameters.datacenter_model_parameters.total_GW_of_PRC_energy_consumption': getValue('total_GW_of_PRC_energy_consumption'),
                'black_project_parameters.datacenter_model_parameters.MW_per_construction_worker_per_year': getValue('MW_per_construction_worker_per_year'),
                'black_project_parameters.datacenter_model_parameters.relative_sigma_mw_per_construction_worker_per_year': getValue('relative_sigma_mw_per_construction_worker_per_year'),
                'black_project_parameters.datacenter_model_parameters.operating_labor_per_MW': getValue('operating_labor_per_MW'),
                'black_project_parameters.datacenter_model_parameters.relative_sigma_operating_labor_per_MW': getValue('relative_sigma_operating_labor_per_MW'),

                // Covert fab parameters - detection
                'black_project_parameters.detection_parameters.us_intelligence_median_error_in_estimate_of_prc_sme_stock': getValue('proportion_diverted_sme'),

                // Covert fab parameters - production capacity
                'black_project_parameters.black_fab_parameters.wafers_per_month_per_worker': getValue('wafers_per_month_per_worker'),
                'black_project_parameters.black_fab_parameters.labor_productivity_relative_sigma': getValue('labor_productivity_sigma'),
                'black_project_parameters.black_fab_parameters.wafers_per_month_per_lithography_scanner': getValue('wafers_per_month_per_scanner'),
                'black_project_parameters.black_fab_parameters.scanner_productivity_relative_sigma': getValue('scanner_productivity_sigma'),

                // Covert fab parameters - construction time
                'black_project_parameters.black_fab_parameters.construction_time_for_5k_wafers_per_month': getValue('construction_time_5k'),
                'black_project_parameters.black_fab_parameters.construction_time_for_100k_wafers_per_month': getValue('construction_time_100k'),
                'black_project_parameters.black_fab_parameters.construction_time_relative_sigma': getValue('construction_time_sigma'),
                'black_project_parameters.black_fab_parameters.construction_workers_per_1000_wafers_per_month': getValue('construction_workers_per_1000'),

                // Covert fab parameters - chip production
                'black_project_parameters.black_fab_parameters.h100_sized_chips_per_wafer': getValue('chips_per_wafer'),
                'black_project_parameters.black_fab_parameters.transistor_density_scaling_exponent': getValue('transistor_density_exponent'),
                'black_project_parameters.exogenous_trends.architecture_efficiency_improvement_per_year': getValue('architecture_efficiency'),

                // Covert fab parameters - energy efficiency scaling
                'black_project_parameters.black_fab_parameters.watts_per_tpp_vs_transistor_density_exponent_before_dennard_scaling_ended': getValue('watts_per_tpp_exponent_before_dennard'),
                'black_project_parameters.black_fab_parameters.watts_per_tpp_vs_transistor_density_exponent_after_dennard_scaling_ended': getValue('watts_per_tpp_exponent_after_dennard'),
                'black_project_parameters.black_fab_parameters.transistor_density_at_end_of_dennard_scaling_m_per_mm2': getValue('transistor_density_at_dennard_end'),

                // Covert fab parameters - PRC scanner production
                'black_project_parameters.black_fab_parameters.prc_lithography_scanners_produced_in_first_year': getValue('prc_scanners_first_year'),
                'black_project_parameters.black_fab_parameters.prc_additional_lithography_scanners_produced_per_year': getValue('prc_scanners_per_year'),
                'black_project_parameters.black_fab_parameters.prc_scanner_production_relative_sigma': getValue('prc_scanner_production_sigma'),

                // Covert fab parameters - localization probabilities
                'black_project_parameters.black_fab_parameters.localization_130nm_2025': getValue('localization_130nm_2025'),
                'black_project_parameters.black_fab_parameters.localization_130nm_2031': getValue('localization_130nm_2031'),
                'black_project_parameters.black_fab_parameters.localization_28nm_2025': getValue('localization_28nm_2025'),
                'black_project_parameters.black_fab_parameters.localization_28nm_2031': getValue('localization_28nm_2031'),
                'black_project_parameters.black_fab_parameters.localization_14nm_2025': getValue('localization_14nm_2025'),
                'black_project_parameters.black_fab_parameters.localization_14nm_2031': getValue('localization_14nm_2031'),
                'black_project_parameters.black_fab_parameters.localization_7nm_2025': getValue('localization_7nm_2025'),
                'black_project_parameters.black_fab_parameters.localization_7nm_2031': getValue('localization_7nm_2031')
            };
        }

        function plotCovertFabProductionBreakdown(data) {
            // Plot compute breakdown
            if (data.black_fab && data.black_fab.is_operational) {
                const years = data.black_fab.years;

                // Proportion Operational - time series showing proportion
                plotProportionOperational('isOperationalPlot', {
                    proportion: data.black_fab.is_operational.proportion
                }, years, COLOR_PALETTE.fab, 'Probability');

                // Wafer Starts per Month - PDF
                const waferStartsFinal = data.black_fab.wafer_starts.individual.map(sim => sim[sim.length - 1]);
                plotPDF('waferStartsPlot', waferStartsFinal, COLOR_PALETTE.chip_stock, 'Wafers/Month');

                // H100-sized Chips per Wafer - Display as a box (constant value)
                const chipsPerWaferValue = data.black_fab.chips_per_wafer.individual[0][0]; // Same for all sims
                document.getElementById('chipsPerWaferPlot').innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                        <div class="breakdown-box-inner">${chipsPerWaferValue.toFixed(0)}</div>
                        <div class="breakdown-label">Working H100-sized chips per wafer</div>
                    </div>`;

                // Attach hover effect to the newly created breakdown-box-inner
                const chipsPerWaferInner = document.querySelector('#chipsPerWaferPlot .breakdown-box-inner');
                if (chipsPerWaferInner) {
                    chipsPerWaferInner.style.transition = 'all 0.2s ease';
                    chipsPerWaferInner.addEventListener('mouseenter', () => {
                        chipsPerWaferInner.style.boxShadow = '0 0 6px ' + COLOR_PALETTE.rgba('chip_stock', 0.25);
                        chipsPerWaferInner.style.transform = 'scale(1.015)';
                    });
                    chipsPerWaferInner.addEventListener('mouseleave', () => {
                        chipsPerWaferInner.style.boxShadow = '';
                        chipsPerWaferInner.style.transform = '';
                    });
                }

                // Transistor density relative to H100 - Bar plot at final timestep
                const transistorDensityFinal = data.black_fab.transistor_density.individual.map(sim => sim[sim.length - 1]);
                const processNodes = data.black_fab.process_node_by_sim;
                plotBarByProcessNode('computePerChipPlot', transistorDensityFinal, processNodes, COLOR_PALETTE.fab);

                // Architecture Efficiency - Display as a box (constant value at agreement year)
                const archEffValue = data.black_fab.architecture_efficiency_at_agreement;
                document.getElementById('architectureEfficiencyDisplay').innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                        <div class="breakdown-box-inner">${archEffValue.toFixed(2)}</div>
                        <div class="breakdown-label">Architecture efficiency (relative to H100)</div>
                    </div>`;

                // Attach hover effect to the newly created breakdown-box-inner
                const architectureEfficiencyInner = document.querySelector('#architectureEfficiencyDisplay .breakdown-box-inner');
                if (architectureEfficiencyInner) {
                    architectureEfficiencyInner.style.transition = 'all 0.2s ease';
                    architectureEfficiencyInner.addEventListener('mouseenter', () => {
                        architectureEfficiencyInner.style.boxShadow = '0 0 6px ' + COLOR_PALETTE.rgba('chip_stock', 0.25);
                        architectureEfficiencyInner.style.transform = 'scale(1.015)';
                    });
                    architectureEfficiencyInner.addEventListener('mouseleave', () => {
                        architectureEfficiencyInner.style.boxShadow = '';
                        architectureEfficiencyInner.style.transform = '';
                    });
                }

                // Total compute - time series over all timesteps
                const totalComputeArray = data.black_fab.is_operational.individual.map((opSim, simIdx) => {
                    return opSim.map((isOp, timeIdx) => {
                        return (isOp * data.black_fab.wafer_starts.individual[simIdx][timeIdx] *
                                data.black_fab.architecture_efficiency.individual[simIdx][timeIdx] *
                                data.black_fab.compute_per_wafer_2022_arch.individual[simIdx][timeIdx]);
                    });
                });

                // Calculate median and percentiles for total compute
                const totalComputeMedian = years.map((_, i) => {
                    const values = totalComputeArray.map(sim => sim[i]);
                    return values.sort((a, b) => a - b)[Math.floor(values.length * 0.5)];
                });
                const totalComputeP25 = years.map((_, i) => {
                    const values = totalComputeArray.map(sim => sim[i]);
                    return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                });
                const totalComputeP75 = years.map((_, i) => {
                    const values = totalComputeArray.map(sim => sim[i]);
                    return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                });

                // Calculate y-axis maximum as 1.2 times the maximum 75th percentile value
                const maxP75 = Math.max(...totalComputeP75);
                const yMax = maxP75 * 1.2;

                plotMedianWithPercentiles('totalComputePlot', {
                    median: totalComputeMedian,
                    p25: totalComputeP25,
                    p75: totalComputeP75,
                    individual: totalComputeArray
                }, years, COLOR_PALETTE.fab, 'H100e/Month', [0, yMax], false, true);

                // Plot energy breakdown
                // 1. Compute produced per month (reuse from above)
                plotMedianWithPercentiles('energyComputePerMonthPlot', {
                    median: totalComputeMedian,
                    p25: totalComputeP25,
                    p75: totalComputeP75,
                    individual: totalComputeArray
                }, years, COLOR_PALETTE.fab, 'H100e/Month', [0, yMax], false, true);

                // 2. Transistor density relative to H100 (reuse from above)
                plotBarByProcessNode('energyTransistorDensityPlot', transistorDensityFinal, processNodes, COLOR_PALETTE.fab);

                // 3. Curve plot: Transistor density vs Energy efficiency
                // Energy efficiency follows power law from fab_model.py:
                // watts_per_tpp = H100_watts * (density_ratio)^exponent
                // efficiency = 1 / (watts_per_tpp / H100_watts) = 1 / (density_ratio^exponent)

                // Constants from fab_model.py
                const H100_TRANSISTOR_DENSITY = 98.28;  // Million transistors per mm²
                const DENNARD_THRESHOLD_DENSITY = 1.98;  // Million transistors per mm²
                const EXPONENT_BEFORE_DENNARD = -2.006575;
                const EXPONENT_AFTER_DENNARD = -0.909355;

                // Use curve data from backend (calculated by Python)
                const densityRangeRelative = data.black_fab.watts_per_tpp_curve.density_relative;
                const wattsPerTppCurve = data.black_fab.watts_per_tpp_curve.watts_per_tpp_relative;
                const dennardDataX = 1.98 / 98.28;

                const xMin = 0.001;  // From your range
                const xMax = 100;    // From your range

                // Convert data coordinate to paper coordinate for log scale
                const dennardPaperX = (Math.log10(dennardDataX) - Math.log10(xMin)) /
                                    (Math.log10(xMax) - Math.log10(xMin));


                // Create curve plot with actual simulation points overlaid
                Plotly.newPlot('densityVsEfficiencyPlot', [
                    {
                        x: densityRangeRelative,
                        y: wattsPerTppCurve,
                        mode: 'lines',
                        type: 'scatter',
                        line: {
                            color: '#7DD4C0',  // Lighter viridian
                            width: 2
                        },
                        name: 'Power Law',
                        hovertemplate: 'Density: %{x:.2g}x<br>Efficiency: %{y:.2g}x<extra></extra>'
                    },
                    {
                        x: transistorDensityFinal,
                        y: data.black_fab.watts_per_tpp.individual.map(sim => sim[sim.length - 1]),
                        mode: 'markers',
                        type: 'scatter',
                        marker: {
                            size: 6,
                            color: COLOR_PALETTE.fab,
                            opacity: 0.7
                        },
                        name: 'Simulations',
                        hovertemplate: 'Density: %{x:.2g}x<br>Watts/TPP: %{y:.2g}x<extra></extra>'
                    }
                ], {
                    xaxis: {
                        title: 'Transistor Density (relative to H100)',
                        titlefont: { size: 10 },
                        tickfont: { size: 9 },
                        type: 'log',
                        range: [Math.log10(0.001), Math.log10(100)],
                        automargin: true
                    },
                    yaxis: {
                        title: 'Watts per TPP (relative to H100)',
                        titlefont: { size: 10 },
                        tickfont: { size: 9 },
                        type: 'log',
                        tickmode: 'array',
                        tickvals: [0.01, 0.1, 1, 10, 100, 1000],
                        automargin: true
                    },
                    shapes: [{
                        type: 'line',
                        x0: dennardPaperX,
                        x1: dennardPaperX,
                        y0: 0,
                        y1: 1,
                        xref: 'paper',
                        yref: 'paper',
                        line: {
                            color: '#999',
                            width: 1,
                            dash: 'dot'
                        }
                    }],
                    annotations: [{
                        x: dennardPaperX + 0.02,
                        y: 0.85,
                        yref: 'paper',
                        xref: 'paper',
                        xanchor: 'left',
                        yanchor: 'bottom',
                        text: 'End of Dennard<br>Scaling',
                        showarrow: false,
                        align: "left",
                        font: {
                            size: 9,
                            color: '#666',
                        }
                    }],
                    margin: { l: 60, r: 10, t: 10, b: 65, pad: 10 },
                    showlegend: false,
                    hovermode: 'closest'
                }, {displayModeBar: false, responsive: true});
                setTimeout(() => Plotly.Plots.resize('densityVsEfficiencyPlot'), 50);

                // 4. Display H100 energy requirements (from user input)
                const h100PowerWatts = parseFloat(document.getElementById('h100_power_watts').value);
                const h100EnergyWatts = h100PowerWatts; // Store in watts for calculations below
                const h100EnergyKW = h100PowerWatts / 1000;
                document.getElementById('h100EnergyDisplay').innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                        <div class="breakdown-box-inner">${h100EnergyKW.toFixed(2)} kW</div>
                        <div class="breakdown-label">Energy requirements of H100</div>
                    </div>`;

                // Attach hover effect to the newly created breakdown-box-inner
                const h100EnergyInner = document.querySelector('#h100EnergyDisplay .breakdown-box-inner');
                if (h100EnergyInner) {
                    h100EnergyInner.style.transition = 'all 0.2s ease';
                    h100EnergyInner.addEventListener('mouseenter', () => {
                        h100EnergyInner.style.boxShadow = '0 0 6px ' + COLOR_PALETTE.rgba('chip_stock', 0.25);
                        h100EnergyInner.style.transform = 'scale(1.015)';
                    });
                    h100EnergyInner.addEventListener('mouseleave', () => {
                        h100EnergyInner.style.boxShadow = '';
                        h100EnergyInner.style.transform = '';
                    });
                }

                // 5. Calculate and plot energy requirements per month (GW/month)
                // Energy = H100e_per_month × watts_per_TPP_relative × H100_energy
                // Note: transistor_density is already factored into H100e calculation, don't multiply again!
                const wattsPerTppBySimAndTime = data.black_fab.watts_per_tpp.individual;

                const energyPerMonthArray = totalComputeArray.map((simArray, simIdx) => {
                    return simArray.map((h100ePerMonth, timeIdx) => {
                        // h100ePerMonth is actual H100e count (not in thousands)
                        const wattsPerTppRelative = wattsPerTppBySimAndTime[simIdx][timeIdx];

                        // Energy (W) = H100e × watts_per_TPP_rel × H100_energy_watts
                        const totalWatts = h100ePerMonth * wattsPerTppRelative * h100EnergyWatts;
                        const energyGW = totalWatts / 1e9;
                        return energyGW;
                    });
                });

                const energyPerMonthMedian = years.map((_, i) => {
                    const values = energyPerMonthArray.map(sim => sim[i]);
                    return values.sort((a, b) => a - b)[Math.floor(values.length * 0.5)];
                });
                const energyPerMonthP25 = years.map((_, i) => {
                    const values = energyPerMonthArray.map(sim => sim[i]);
                    return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                });
                const energyPerMonthP75 = years.map((_, i) => {
                    const values = energyPerMonthArray.map(sim => sim[i]);
                    return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                });

                const maxEnergyP75 = Math.max(...energyPerMonthP75);
                const yMaxEnergy = maxEnergyP75 * 1.2;

                plotMedianWithPercentiles('energyPerMonthPlot', {
                    median: energyPerMonthMedian,
                    p25: energyPerMonthP25,
                    p75: energyPerMonthP75,
                    individual: energyPerMonthArray
                }, years, COLOR_PALETTE.datacenters_and_energy, 'GW/Month', [0, yMaxEnergy], false, true);
            }
        }

        function plotStrengthOfEvidence(data) {
            // Plot "Strength of Evidence of Covert Project" section
            if (data.initial_stock && data.initial_stock.lr_prc_accounting_samples && data.black_project_model) {
                const years = data.black_project_model.years;

                // Get prior probability from parameters and calculate prior odds
                const priorProb = parseFloat(document.getElementById('black_project_parameters.p_project_exists').value);
                const priorOddsProject = priorProb / (1 - priorProb);

                // Display prior odds
                document.getElementById('dashboardPriorProject').innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                        <div class="breakdown-box-inner">${priorOddsProject.toFixed(3)}</div>
                        <div class="breakdown-label">Prior odds of<br>covert project</div>
                    </div>`;

                // Attach hover effect to the newly created breakdown-box-inner
                const dashboardPriorProjectInner = document.querySelector('#dashboardPriorProject .breakdown-box-inner');
                if (dashboardPriorProjectInner) {
                    dashboardPriorProjectInner.style.transition = 'all 0.2s ease';
                    dashboardPriorProjectInner.addEventListener('mouseenter', () => {
                        dashboardPriorProjectInner.style.boxShadow = '0 0 6px ' + COLOR_PALETTE.rgba('chip_stock', 0.25);
                        dashboardPriorProjectInner.style.transform = 'scale(1.015)';
                    });
                    dashboardPriorProjectInner.addEventListener('mouseleave', () => {
                        dashboardPriorProjectInner.style.boxShadow = '';
                        dashboardPriorProjectInner.style.transform = '';
                    });
                }

                // Note: Individual LR component plots are now created in black_project_model_section.js
                // This includes lrPrcAccountingPlot, lrSmeInventoryPlot, and lrReportedAssetsPlot

                // 3. LR from other intelligence sources (same as lrOtherPlot)
                const lrOtherArray = data.black_fab.lr_other.individual.map(sim => sim.map(v => v));
                const lrOtherP25 = years.map((_, i) => {
                    const values = lrOtherArray.map(sim => sim[i]);
                    return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                });
                const lrOtherP75 = years.map((_, i) => {
                    const values = lrOtherArray.map(sim => sim[i]);
                    return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                });
                plotMedianWithPercentiles('lrOtherIntelPlot', {
                    median: data.black_fab.lr_other.median,
                    p25: lrOtherP25,
                    p75: lrOtherP75,
                    individual: data.black_fab.lr_other.individual
                }, years, COLOR_PALETTE.detection, 'Likelihood Ratio', null, true, true);

                // 4. Posterior probability of covert project
                // Use backend data from US intelligence beliefs (same as Simulation Runs plot)
                // Custom plotting to add threshold lines
                const posteriorData = data.black_project_model.posterior_prob_project;

                // Define thresholds from global config
                const thresholds = DETECTION_CONFIG.getThresholds();

                const traces = [
                    {
                        x: years,
                        y: posteriorData.p75,
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: 'transparent' },
                        showlegend: false,
                        hoverinfo: 'skip'
                    },
                    {
                        x: years,
                        y: posteriorData.p25,
                        type: 'scatter',
                        mode: 'lines',
                        fill: 'tonexty',
                        fillcolor: COLOR_PALETTE.rgba('detection', 0.2),
                        line: { color: 'transparent' },
                        showlegend: false,
                        hoverinfo: 'skip'
                    },
                    {
                        x: years,
                        y: posteriorData.median,
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: COLOR_PALETTE.detection, width: 2 },
                        name: 'Posterior Probability',
                        showlegend: false
                    }
                ];

                // Add threshold lines
                for (const threshold of thresholds) {
                    const thresholdOdds = priorOddsProject * threshold.multiplier;
                    const thresholdProb = thresholdOdds / (1 + thresholdOdds);

                    traces.push({
                        x: [years[0], years[years.length - 1]],
                        y: [thresholdProb, thresholdProb],
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: threshold.color, width: 2, dash: 'dash' },
                        name: `Detection (${threshold.multiplier}x)`,
                        showlegend: true
                    });
                }

                const layout = {
                    xaxis: {
                        title: 'Year',
                        titlefont: { size: 10 },
                        tickfont: { size: 9 }
                    },
                    yaxis: {
                        title: 'Posterior Probability',
                        titlefont: { size: 10 },
                        tickfont: { size: 9 },
                        tickformat: '.0%',
                        range: [0, 1]
                    },
                    margin: { l: 50, r: 20, t: 15, b: 60 },
                    height: 240,
                    hovermode: 'x unified',
                    showlegend: true,
                    legend: {
                        x: 0.98,
                        y: 0.02,
                        xanchor: 'right',
                        yanchor: 'bottom',
                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                        bordercolor: '#ccc',
                        borderwidth: 1,
                        font: { size: 9 }
                    }
                };

                Plotly.newPlot('posteriorProbProjectPlot', traces, layout, {responsive: true, displayModeBar: false});
            }
        }

        async function runSimulation() {
            runButton.disabled = true;
            loadingDiv.classList.add('active');
            plotsDiv.style.display = 'none';
            setStatus('Running simulation...', 'info');

            try {
                const params = getParameters();
                const response = await fetch('/run_simulation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    let errorMessage = 'Simulation failed';
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        console.error('Could not parse error response:', e);
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();

                // Wrapper to catch errors in individual plot functions
                function safeCall(fn, name) {
                    try {
                        fn();
                    } catch (e) {
                        console.error(`Error in ${name}:`, e);
                        const errorDiv = document.createElement('div');
                        errorDiv.style.cssText = 'position:fixed;top:20px;right:20px;background:#ff4444;color:white;padding:15px;border-radius:5px;max-width:500px;z-index:10000;font-family:monospace;font-size:12px;white-space:pre-wrap;';
                        errorDiv.innerHTML = `<strong>Error in ${name}:</strong>\n${e.message}\n\n<small>${e.stack}</small>`;
                        document.body.appendChild(errorDiv);
                        throw e; // Re-throw to stop execution
                    }
                }

                // Plot Initial Stock section
                safeCall(() => plotInitialStock(data), 'plotInitialStock');

                // Plot main charts
                safeCall(() => plotTimeSeries(data), 'plotTimeSeries');
                safeCall(() => plotComputeCcdf(data), 'plotComputeCcdf');
                safeCall(() => updateDashboard(data), 'updateDashboard');
                safeCall(() => plotDarkComputeModel(data), 'plotDarkComputeModel');
                safeCall(() => plotDatacenterCombined(data), 'plotDatacenterCombined');
                safeCall(() => plotDatacenterCapacityCcdf(data), 'plotDatacenterCapacityCcdf');
                safeCall(() => updateDatacenterDashboard(data), 'updateDatacenterDashboard');
                safeCall(() => populateDatacenterCapacityBreakdown(data), 'populateDatacenterCapacityBreakdown');
                safeCall(() => populateUnconcealedDatacenterBreakdown(data), 'populateUnconcealedDatacenterBreakdown');

                // Force resize after a brief delay to ensure plots fill containers
                setTimeout(() => {
                    Plotly.Plots.resize('initialDarkComputePlot');
                    Plotly.Plots.resize('covertFabFlowPlot');
                    Plotly.Plots.resize('chipSurvivalPlot');
                    Plotly.Plots.resize('totalDarkComputePlot');
                    Plotly.Plots.resize('initialDarkComputeDetectionPlot');
                    Plotly.Plots.resize('initialComputeStockPlot');
                    Plotly.Plots.resize('lrPrcAccountingPlot');
                    Plotly.Plots.resize('initialPrcStockPlot');
                    Plotly.Plots.resize('darkComputeResultPlot');
                    Plotly.Plots.resize('initialStockDarkComputePlot');
                    Plotly.Plots.resize('initialStockEnergyRequirementsPlot');
                    Plotly.Plots.resize('prcComputeOverTimePlot');
                    Plotly.Plots.resize('timeSeriesPlot');
                    // Plotly.Plots.resize('h100YearsTimeSeriesPlot');  // Commented out
                    Plotly.Plots.resize('projectH100YearsCcdfPlot');
                    Plotly.Plots.resize('computeCcdfPlot');
                    Plotly.Plots.resize('datacenterCombinedPlot');
                    Plotly.Plots.resize('datacenterCapacityCcdfPlot');
                    Plotly.Plots.resize('chipProductionReductionCcdfPlot');
                    Plotly.Plots.resize('aiRdReductionCcdfPlot');
                    Plotly.Plots.resize('timeToDetectionCcdfPlot');
                    Plotly.Plots.resize('intelligenceAccuracyPlot');
                    Plotly.Plots.resize('detectionLatencyPlot');
                    // Individual LR component plots are resized in black_project_model_section.js
                    Plotly.Plots.resize('lrOtherIntelPlot');
                    Plotly.Plots.resize('posteriorProbProjectPlot');
                }, 100);

                // Plot LR breakdown
                if (data.black_fab && data.black_fab.lr_inventory) {
                    const years = data.black_fab.years;

                    // LR Inventory - PDF of values across simulations at final timestep - REMOVED FROM UI
                    // const lrInventoryFinal = data.black_fab.lr_inventory.individual.map(sim => sim[sim.length - 1]);
                    // Use log scale x-axis but show actual LR values (not log values)
                    // plotPDF('lrInventoryPlot', lrInventoryFinal, '#5B8DBE', 'Likelihood Ratio', 10, true);

                    // LR Procurement - Categorical bar plot (1 or 10) - REMOVED FROM UI
                    // const lrProcurementFinal = data.black_fab.lr_procurement.individual.map(sim => sim[sim.length - 1]);
                    // plotCategoricalFrequency('lrProcurementPlot', lrProcurementFinal, [
                    //     { value: 1, label: 'Likelihood Ratio = 1<br>(>90% localization)' },
                    //     { value: 10, label: 'Likelihood Ratio = 10<br>(≤90% localization)' }
                    // ], '#5B8DBE');

                    // LR Other - Median over time with percentiles - REMOVED FROM UI
                    // const lrOtherArray = data.black_fab.lr_other.individual.map(sim => sim.map(v => v));
                    // const lrOtherP25 = years.map((_, i) => {
                    //     const values = lrOtherArray.map(sim => sim[i]);
                    //     return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    // });
                    // const lrOtherP75 = years.map((_, i) => {
                    //     const values = lrOtherArray.map(sim => sim[i]);
                    //     return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    // });
                    // plotMedianWithPercentiles('lrOtherPlot', {
                    //     median: data.black_fab.lr_other.median,
                    //     p25: lrOtherP25,
                    //     p75: lrOtherP75,
                    //     individual: data.black_fab.lr_other.individual
                    // }, years, '#5B8DBE', 'Likelihood Ratio', null, true, true);

                    // Plot combined LR (product of inventory, procurement, and other intelligence) - REMOVED FROM UI
                    // This is now plotted in black_project_model_section.js as posteriorProbProjectPlot
                    // plotMedianWithPercentiles('posteriorProbPlot', {
                    //     median: data.black_fab.lr_combined.median,
                    //     p25: data.black_fab.lr_combined.p25,
                    //     p75: data.black_fab.lr_combined.p75,
                    //     individual: data.black_fab.lr_combined.individual
                    // }, data.black_fab.years, '#5B8DBE', 'Likelihood Ratio', null, true, true);
                }

                // Plot "Strength of Evidence of Covert Project" section
                safeCall(() => plotStrengthOfEvidence(data), 'plotStrengthOfEvidence');

                // Plot covert fab production breakdown
                safeCall(() => plotCovertFabProductionBreakdown(data), 'plotCovertFabProductionBreakdown');

                // Check if project is running (default to true if elements don't exist)
                const runBlackProjectEl = document.getElementById('run_black_project');
                const buildCovertFabEl = document.getElementById('build_covert_fab');
                const runCovertProject = runBlackProjectEl ? runBlackProjectEl.checked : true;
                const buildCovertFab = buildCovertFabEl ? buildCovertFabEl.checked : true;
                const projectNotRunDiv = document.getElementById('projectNotRun');
                const plotsContentDiv = document.getElementById('plotsContent');

                if (runCovertProject && buildCovertFab) {
                    // Show normal plots
                    projectNotRunDiv.style.display = 'none';
                    plotsContentDiv.style.display = 'block';
                } else {
                    // Show "project not run" message
                    projectNotRunDiv.style.display = 'block';
                    plotsContentDiv.style.display = 'none';
                }

                plotsDiv.style.display = 'block';
                loadingDiv.classList.remove('active');
                setStatus(`Simulation complete! Ran ${data.num_simulations} simulations`, 'success');
                // Update parameter displays (e.g., agreement year in header)
                if (typeof updateParameterDisplays === 'function') {
                    updateParameterDisplays();
                }
                // Update diagram arrows after layout is complete
                setTimeout(() => {
                    if (window.updateDiagramArrows) window.updateDiagramArrows();
                }, 100);
            } catch (error) {
                loadingDiv.classList.remove('active');
                setStatus('Error: ' + error.message, 'error');
            } finally {
                runButton.disabled = false;
            }
        }

        async function loadDefaultResults() {
            // Try to load default cached results
            try {
                setStatus('Loading cached results...', 'info');
                const response = await fetch('/get_default_results');

                if (response.ok) {
                    const data = await response.json();

                    // Wrapper to catch errors in individual plot functions
                    function safeCall(fn, name) {
                        try {
                            fn();
                        } catch (e) {
                            console.error(`Error in ${name}:`, e);
                            const errorDiv = document.createElement('div');
                            errorDiv.style.cssText = 'position:fixed;top:20px;right:20px;background:#ff4444;color:white;padding:15px;border-radius:5px;max-width:500px;z-index:10000;font-family:monospace;font-size:12px;white-space:pre-wrap;';
                            errorDiv.innerHTML = `<strong>Error in ${name}:</strong>\n${e.message}\n\n<small>${e.stack}</small>`;
                            document.body.appendChild(errorDiv);
                            throw e; // Re-throw to stop execution
                        }
                    }

                    // Plot all sections with cached data
                    safeCall(() => plotInitialStock(data), 'plotInitialStock');
                    safeCall(() => plotTimeSeries(data), 'plotTimeSeries');
                    safeCall(() => plotComputeCcdf(data), 'plotComputeCcdf');
                    safeCall(() => updateDashboard(data), 'updateDashboard');
                    safeCall(() => plotDarkComputeModel(data), 'plotDarkComputeModel');
                    safeCall(() => plotDatacenterCombined(data), 'plotDatacenterCombined');
                    safeCall(() => plotDatacenterCapacityCcdf(data), 'plotDatacenterCapacityCcdf');
                    safeCall(() => updateDatacenterDashboard(data), 'updateDatacenterDashboard');
                    safeCall(() => populateDatacenterCapacityBreakdown(data), 'populateDatacenterCapacityBreakdown');
                    safeCall(() => populateUnconcealedDatacenterBreakdown(data), 'populateUnconcealedDatacenterBreakdown');
                    safeCall(() => plotStrengthOfEvidence(data), 'plotStrengthOfEvidence');
                    safeCall(() => plotCovertFabProductionBreakdown(data), 'plotCovertFabProductionBreakdown');

                    // Force resize
                    setTimeout(() => {
                        Plotly.Plots.resize('initialDarkComputePlot');
                        Plotly.Plots.resize('covertFabFlowPlot');
                        Plotly.Plots.resize('chipSurvivalPlot');
                        Plotly.Plots.resize('totalDarkComputePlot');
                        Plotly.Plots.resize('initialDarkComputeDetectionPlot');
                        Plotly.Plots.resize('initialComputeStockPlot');
                        // Update diagram arrows after layout is complete
                        if (window.updateDiagramArrows) window.updateDiagramArrows();
                    }, 100);

                    plotsDiv.style.display = 'block';
                    loadingDiv.classList.remove('active');
                    setStatus('Ran 1000 simulations', 'success');
                    return true; // Successfully loaded cache
                } else {
                    // No cache available, will need to run simulation
                    return false;
                }
            } catch (error) {
                console.error('Error loading cached results:', error);
                return false;
            }
        }

        runButton.addEventListener('click', runSimulation);

        // Load cached results or run simulation on page load
        window.addEventListener('DOMContentLoaded', async () => {
            await new Promise(resolve => setTimeout(resolve, 500)); // Small delay to ensure page is fully loaded
            const cacheLoaded = await loadDefaultResults();
            if (!cacheLoaded) {
                // No cache available, run simulation
                await runSimulation();
            }
        });

        // Add Enter key listener to all input fields and select elements in sidebar
        const sidebarInputs = document.querySelectorAll('.sidebar input, .sidebar select');
        sidebarInputs.forEach(input => {
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    runSimulation();
                }
            });
        });

        // Add click handler to breakdown box to focus corresponding input field
        const diversionProportionDisplay = document.getElementById('diversionProportionDisplay');
        if (diversionProportionDisplay) {
            diversionProportionDisplay.addEventListener('click', () => {
                const inputField = document.getElementById('proportion_of_initial_chip_stock_to_divert');
                if (inputField) {
                    inputField.focus();
                    inputField.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
            // Add cursor pointer style to indicate it's clickable
            diversionProportionDisplay.style.cursor = 'pointer';
        }

        // Add click handler for datacenter workers display
        const datacenterWorkersDisplay = document.getElementById('datacenterWorkersDisplay');
        if (datacenterWorkersDisplay) {
            datacenterWorkersDisplay.addEventListener('click', () => {
                const inputField = document.getElementById('datacenter_construction_labor');
                if (inputField) {
                    inputField.focus();
                    inputField.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
            datacenterWorkersDisplay.style.cursor = 'pointer';
        }

        // Add click handler for MW per worker display
        const mwPerWorkerDisplay = document.getElementById('mwPerWorkerDisplay');
        if (mwPerWorkerDisplay) {
            mwPerWorkerDisplay.addEventListener('click', () => {
                const inputField = document.getElementById('MW_per_construction_worker_per_year');
                if (inputField) {
                    inputField.focus();
                    inputField.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
            mwPerWorkerDisplay.style.cursor = 'pointer';
        }

        // Add click handler for datacenter start year display
        const agreementYearDisplay = document.getElementById('agreementYearDisplay');
        if (agreementYearDisplay) {
            agreementYearDisplay.addEventListener('click', () => {
                const inputField = document.getElementById('years_before_agreement_year_prc_starts_building_black_datacenters');
                if (inputField) {
                    inputField.focus();
                    inputField.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
            agreementYearDisplay.style.cursor = 'pointer';
        }

        // Setup tooltip handlers using event delegation (works for dynamically-added elements)
        const globalTooltip = document.getElementById('globalTooltip');

        let hideTooltipTimeout;
        let currentTooltipElement = null;

        function hideTooltip() {
            globalTooltip.classList.remove('visible');
            globalTooltip.style.opacity = '0';
            currentTooltipElement = null;
        }

        function isMouseOverElementOrTooltip(mouseEvent) {
            // Check if mouse is over the current tooltip element
            if (currentTooltipElement && currentTooltipElement.matches(':hover')) {
                return true;
            }
            // Check if mouse is over the tooltip itself
            if (globalTooltip.matches(':hover')) {
                return true;
            }
            return false;
        }

        // Cache for tooltip file contents
        const tooltipFileCache = {};

        async function getTooltipContent(element) {
            const tooltipFile = element.getAttribute('data-tooltip-file');
            const tooltipText = element.getAttribute('data-tooltip');
            const tooltipSuffix = element.getAttribute('data-tooltip-suffix');

            let baseContent = '';

            if (tooltipFile) {
                // Check cache first
                if (tooltipFileCache[tooltipFile]) {
                    baseContent = tooltipFileCache[tooltipFile];
                } else {
                    try {
                        const response = await fetch(tooltipFile);
                        if (response.ok) {
                            baseContent = await response.text();
                            tooltipFileCache[tooltipFile] = baseContent;
                        } else {
                            console.error(`Failed to load tooltip file: ${tooltipFile}`);
                            return null;
                        }
                    } catch (error) {
                        console.error(`Error loading tooltip file: ${tooltipFile}`, error);
                        return null;
                    }
                }
            } else if (tooltipText) {
                baseContent = tooltipText;
            }

            // Add suffix if present
            if (tooltipSuffix && baseContent) {
                baseContent += tooltipSuffix;
            }

            return baseContent;
        }

        async function showTooltipForElement(element) {
            clearTimeout(hideTooltipTimeout);
            currentTooltipElement = element;

            const tooltipText = await getTooltipContent(element);
            const downloadUrl = element.getAttribute('data-download');
            const imageUrl = element.getAttribute('data-image');
            const imageBeforeText = element.getAttribute('data-image-before-text');
            const imageAfterText = element.getAttribute('data-image-after-text');

            if (tooltipText) {
                // Add the tooltip text
                let content = tooltipText;

                // Add image if data-image attribute exists
                if (imageUrl) {
                    if (imageBeforeText) {
                        // Insert image before the specified text
                        content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageBeforeText}`;
                    } else if (imageAfterText) {
                        // Insert image after the tooltip text, then add the after text
                        content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageAfterText}`;
                    } else {
                        // Default: add image after tooltip text
                        content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px;" alt="Capabilities table">`;
                    }
                }

                // Add download button only if data-download attribute exists
                if (downloadUrl) {
                    const fileName = downloadUrl.split('/').pop() + '.csv';
                    content += `<br><br><button onclick='window.location.href="${downloadUrl}"' style='margin-top: 8px; padding: 6px 12px; background-color: #555; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; pointer-events: auto;'>Download ${fileName}</button>`;
                }

                globalTooltip.innerHTML = content;

                // Render any embedded plots in the tooltip
                const detectionLatencyPlot = globalTooltip.querySelector('[data-plot="detection-latency"]');
                if (detectionLatencyPlot) {
                    createDetectionLatencyPlot(detectionLatencyPlot.id);
                }
                const intelligenceAccuracyPlot = globalTooltip.querySelector('[data-plot="intelligence-accuracy"]');
                if (intelligenceAccuracyPlot) {
                    createIntelligenceAccuracyPlot(intelligenceAccuracyPlot.id);
                }

                // Get the position of the element
                const rect = element.getBoundingClientRect();

                // Show tooltip temporarily to measure its dimensions
                globalTooltip.style.visibility = 'hidden';
                globalTooltip.style.opacity = '1';
                globalTooltip.classList.add('visible');

                const tooltipWidth = globalTooltip.offsetWidth;
                const tooltipHeight = globalTooltip.offsetHeight;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                // Calculate horizontal position
                let leftPosition = rect.right + 10;

                // If tooltip would go off right edge of screen, position to the left of element
                if (leftPosition + tooltipWidth > viewportWidth - 10) {
                    leftPosition = rect.left - tooltipWidth - 10;

                    // If positioning to the left would go off left edge, clamp to viewport
                    if (leftPosition < 10) {
                        leftPosition = 10;
                    }
                }

                globalTooltip.style.left = leftPosition + 'px';

                // Calculate vertical position to keep tooltip within viewport
                let topPosition = rect.top;

                // If tooltip would go off bottom of screen, adjust position
                if (topPosition + tooltipHeight > viewportHeight) {
                    topPosition = Math.max(10, viewportHeight - tooltipHeight - 10);
                }

                // If tooltip would go off top of screen, adjust position
                if (topPosition < 10) {
                    topPosition = 10;
                }

                globalTooltip.style.top = topPosition + 'px';

                // Now show tooltip properly
                globalTooltip.style.visibility = 'visible';
            }
        }

        // Use event delegation for tooltip mouseenter/mouseleave
        document.addEventListener('mouseover', (e) => {
            if (!e.target || typeof e.target.closest !== 'function') return;
            const element = e.target.closest('.has-tooltip');
            if (element && element !== currentTooltipElement) {
                showTooltipForElement(element);
            }
        });

        document.addEventListener('mouseout', (e) => {
            if (!e.target || typeof e.target.closest !== 'function') return;
            const element = e.target.closest('.has-tooltip');
            if (element) {
                // Check if we're moving to a child element of the same tooltip element
                const relatedTarget = e.relatedTarget;
                if (relatedTarget && typeof relatedTarget.closest === 'function') {
                    const relatedTooltipElement = relatedTarget.closest('.has-tooltip');
                    if (relatedTooltipElement === element) {
                        return; // Still within the same tooltip element
                    }
                }
                // Give a short delay to allow mouse to move to tooltip
                hideTooltipTimeout = setTimeout(() => {
                    // Only hide if mouse is not over the element or tooltip
                    if (!isMouseOverElementOrTooltip(e)) {
                        hideTooltip();
                    }
                }, 100);
            }
        });

        // Keep tooltip visible when hovering over it
        globalTooltip.addEventListener('mouseenter', () => {
            clearTimeout(hideTooltipTimeout);
        });

        globalTooltip.addEventListener('mouseleave', () => {
            // Check if we're moving back to the original element
            hideTooltipTimeout = setTimeout(() => {
                if (!isMouseOverElementOrTooltip(event)) {
                    hideTooltip();
                }
            }, 100);
        });

        // Setup footnote handlers - click to show tooltip
        const footnoteLinks = document.querySelectorAll('.footnote-link');

        // Helper function to show footnote tooltip
        function showFootnoteTooltip(link) {
            const footnoteText = link.getAttribute('data-footnote');
            if (footnoteText) {
                globalTooltip.innerHTML = footnoteText;

                // Get the position of the footnote link
                const rect = link.getBoundingClientRect();

                // Show tooltip temporarily to measure its dimensions
                globalTooltip.style.visibility = 'hidden';
                globalTooltip.style.opacity = '1';
                globalTooltip.classList.add('visible');

                const tooltipWidth = globalTooltip.offsetWidth;
                const tooltipHeight = globalTooltip.offsetHeight;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                // Calculate horizontal position
                let leftPosition = rect.right + 10;

                // If tooltip would go off right edge of screen, position to the left of element
                if (leftPosition + tooltipWidth > viewportWidth - 10) {
                    leftPosition = rect.left - tooltipWidth - 10;

                    // If positioning to the left would go off left edge, clamp to viewport
                    if (leftPosition < 10) {
                        leftPosition = 10;
                    }
                }

                globalTooltip.style.left = leftPosition + 'px';

                // Calculate vertical position to keep tooltip within viewport
                let topPosition = rect.top;

                // If tooltip would go off bottom of screen, adjust position
                if (topPosition + tooltipHeight > viewportHeight) {
                    topPosition = Math.max(10, viewportHeight - tooltipHeight - 10);
                }

                // If tooltip would go off top of screen, adjust position
                if (topPosition < 10) {
                    topPosition = 10;
                }

                globalTooltip.style.top = topPosition + 'px';

                // Now show tooltip properly
                globalTooltip.style.visibility = 'visible';
            }
        }

        footnoteLinks.forEach(link => {
            // Click handler for mobile
            link.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showFootnoteTooltip(link);
            });

            // Hover handlers for desktop - only if device supports hover
            if (window.matchMedia('(hover: hover)').matches) {
                link.addEventListener('mouseenter', () => {
                    showFootnoteTooltip(link);
                });

                link.addEventListener('mouseleave', () => {
                    hideTooltip();
                });
            }
        });

        // Hide footnote tooltip when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.footnote-link') && !e.target.closest('#globalTooltip')) {
                hideTooltip();
            }
        });

        // Make breakdown plots clickable and link to sidebar inputs
        const plotToInputMapping = {
            // Covert Fab Section - US Bayesian Inference plots
            // 'lrInventoryPlot': 'proportion_diverted_sme', // REMOVED FROM UI - Median absolute relative error of US intelligence estimate of PRC SME stock
            // 'lrProcurementPlot': 'localization_130nm_2025', // REMOVED - Probability PRC achieves >90% indigenization
            // 'lrOtherPlot': 'mean_detection_time_100', // REMOVED FROM UI - Detection time
            // 'posteriorProbPlot': null, // REMOVED FROM UI - Output, not an input

            // Covert Fab Section - Compute Production Rate plots
            'isOperationalPlot': 'construction_time_5k', // First construction time param
            'waferStartsPlot': 'wafers_per_month_per_worker', // Operating labor productivity
            'chipsPerWaferPlot': 'chips_per_wafer',
            'computePerChipPlot': 'transistor_density_exponent',
            'architectureEfficiencyDisplay': 'architecture_efficiency',
            'totalComputePlot': null, // Output, not an input

            // Covert Fab Section - Energy Requirements plots
            'energyTransistorDensityPlot': 'transistor_density_exponent',
            'densityVsEfficiencyPlot': 'watts_per_tpp_exponent_before_dennard',
            'h100EnergyDisplay': 'h100_power_watts',
            'energyComputePerMonthPlot': null, // This shows compute per month, not an input
            'energyPerMonthPlot': null, // Output, not an input

            // Dark Compute Model Section - Dark Compute Stock Breakdown
            'initialDarkComputePlot': '#initialStockSection', // Scroll to section
            'covertFabFlowPlot': '#covertFabSection', // Scroll to section
            'chipSurvivalPlot': 'increase_of_hazard_rate_per_year_p50',
            'totalDarkComputePlot': null, // Output, not an input

            // Dark Compute Model Section - Datacenter Capacity Breakdown
            'datacenterCapacityPlot2': '#covertDataCentersSection', // Scroll to section
            'darkComputeEnergyPlot': 'h100_power_watts',
            'operationalDarkComputePlot': null, // Output, not an input

            // Dark Compute Model Section - US Estimated Likelihood of PRC Covert Project
            'dashboardPriorProject': 'black_project_parameters.p_project_exists',
            'lrPrcAccountingPlot': '#initialStockSection', // Individual component plots
            'lrSmeInventoryPlot': 'proportion_diverted_sme',
            'lrReportedAssetsPlot': null, // Combined output
            'lrOtherIntelPlot': 'mean_detection_time_100',
            'posteriorProbProjectPlot': null, // Output, not an input

            // Initial Stock Section - Compute Breakdown
            'prcComputeOverTimePlot': 'total_prc_compute_stock_in_2025',
            'initialPrcStockPlot': 'total_prc_compute_stock_in_2025',
            'darkComputeResultPlot': null, // Output, not an input

            // Initial Stock Section - Energy Requirements Breakdown
            'initialStockH100EnergyDisplay': 'h100_power_watts',
            'initialStockSOTAEfficiencyDisplay': 'improvement_in_energy_efficiency_per_year',
            'initialStockPRCEfficiencyDisplay': 'energy_efficiency_of_prc_stock_relative_to_state_of_the_art',
            'initialStockDarkComputePlot': null, // Output, not an input (same as darkComputeResultPlot)
            'initialStockEnergyRequirementsPlot': null, // Output, not an input

            // Initial Stock Section - Intelligence Evidence Breakdown
            'lrPrcAccountingPlot': 'us_intelligence_median_error_in_estimate_of_prc_compute_stock',

            // Covert Datacenters Section - Capacity Breakdown
            'totalPrcEnergyDisplay': 'total_GW_of_PRC_energy_consumption',
            'maxProportionEnergyDisplay': 'max_proportion_of_PRC_energy_consumption',
            'datacenterWorkersDisplay': 'datacenter_construction_labor',
            'mwPerWorkerDisplay': 'MW_per_construction_worker_per_year',
            'agreementYearDisplay': 'years_before_agreement_year_prc_starts_building_black_datacenters',
            'datacenterCapacityBreakdownPlot': null, // Output, not an input

            // Covert Datacenters Section - Unconcealed Capacity Breakdown
            'totalPrcDatacenterCapacityNotConcealedDisplay': 'total_prc_compute_stock_in_2025',
            'proportionUnconcealedDivertedDisplay': 'fraction_of_datacenter_capacity_not_built_for_concealment_diverted'
        };

        // Add clickable class and click handlers to plots with associated inputs
        // Skip boxes that have dynamically created innerHTML (they handle hover effects manually)
        const dynamicallyCreatedBoxes = [
            'dashboardPriorProject',
            'chipsPerWaferPlot',
            'architectureEfficiencyDisplay',
            'h100EnergyDisplay',
            'diversionProportionDisplay',
            'datacenterWorkersDisplay',
            'mwPerWorkerDisplay',
            'agreementYearDisplay',
            'initialStockH100EnergyDisplay',
            'initialStockSOTAEfficiencyDisplay',
            'initialStockPRCEfficiencyDisplay',
            'totalPrcEnergyDisplay',
            'maxProportionEnergyDisplay',
            'totalPrcDatacenterCapacityNotConcealedDisplay',
            'proportionUnconcealedDivertedDisplay'
        ];

        Object.entries(plotToInputMapping).forEach(([plotId, inputId]) => {
            const plotElement = document.getElementById(plotId);
            if (plotElement && inputId) {
                // Skip hover effect setup for dynamically created boxes (they handle it themselves)
                if (!dynamicallyCreatedBoxes.includes(plotId)) {
                    // For breakdown boxes, target the inner element if it exists, otherwise target the box itself
                    const innerElement = plotElement.classList.contains('breakdown-box')
                        ? plotElement.querySelector('.breakdown-box-inner')
                        : null;
                    const hoverTarget = innerElement || plotElement;

                    // Add consistent hover styles
                    hoverTarget.style.transition = 'all 0.2s ease';

                    // Add hover effect via event listeners
                    hoverTarget.addEventListener('mouseenter', () => {
                        hoverTarget.style.boxShadow = '0 0 6px ' + COLOR_PALETTE.rgba('chip_stock', 0.25);
                        hoverTarget.style.transform = 'scale(1.015)';
                    });
                    hoverTarget.addEventListener('mouseleave', () => {
                        hoverTarget.style.boxShadow = '';
                        hoverTarget.style.transform = '';
                    });
                }

                // Make the whole element clickable
                plotElement.style.cursor = 'pointer';

                // Add click handler
                plotElement.addEventListener('click', () => {
                    // Check if inputId is a section (starts with #) or an input field
                    if (inputId.startsWith('#')) {
                        // Scroll to section
                        const sectionElement = document.getElementById(inputId.substring(1));
                        if (sectionElement) {
                            sectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    } else {
                        // Focus on input field
                        const inputElement = document.getElementById(inputId);
                        if (inputElement) {
                            // Scroll input into view
                            inputElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            // Focus and select the input
                            setTimeout(() => {
                                inputElement.focus();
                                inputElement.select();
                            }, 300);
                        }
                    }
                });
            }
        });
        }  // End of initializeApp function

        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>
