<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Covert Compute Production Model</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="utilities.js"></script>
    <script src="initial_stock_section.js"></script>
    <script src="covert_data_centers_section.js"></script>
    <script src="covert_fab_section.js"></script>
    <script src="dark_compute_model_section.js"></script>
    <script>
        // Function to send errors to backend
        function logErrorToBackend(errorData) {
            fetch('/log_client_error', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(errorData)
            }).catch(err => console.error('Failed to log error to backend:', err));
        }

        // Global error handler to catch and display all JavaScript errors
        window.addEventListener('error', function(event) {
            const errorData = {
                message: event.message,
                source: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack || 'No stack trace available'
            };

            console.error('Global error caught:', event.error);
            console.error('Error message:', event.message);
            console.error('Error stack:', event.error?.stack);

            // Send to backend
            logErrorToBackend(errorData);

            // Display error in UI
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:20px;right:20px;background:#ff4444;color:white;padding:15px;border-radius:5px;max-width:400px;z-index:10000;font-family:monospace;font-size:12px;';
            errorDiv.innerHTML = `<strong>JavaScript Error:</strong><br>${event.message}<br><small>${event.filename}:${event.lineno}</small>`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 10000);
        });

        // Catch unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            const errorData = {
                message: 'Unhandled Promise Rejection',
                reason: String(event.reason),
                stack: event.reason?.stack || 'No stack trace available'
            };

            console.error('Unhandled promise rejection:', event.reason);

            // Send to backend
            logErrorToBackend(errorData);
        });
    </script>
</head>
<body>
    <!-- Global tooltip (outside sidebar to avoid clipping) -->
    <div id="globalTooltip"></div>

    <!-- Include the sidebar -->
    {% include 'sidebar.html' %}

    <div class="main-content">
        <div class="loading active" id="loading">
            <h2>Running Simulation...</h2>
            <p>This may take a few moments.</p>
        </div>

        <div id="plots" style="display: none;">
            <!-- Dark Compute Model Section -->
            {% include 'dark_compute_model_section.html' %}

            <!-- Initial Stock Section -->
            {% include 'initial_stock_section.html' %}

            <!-- Covert Data Centers Section -->
            {% include 'covert_data_centers_section.html' %}

            <!-- Covert Fab Section -->
            {% include 'covert_fab_section.html' %}
        </div>
    </div>

    <script>
        // Mobile menu toggle functionality
        function initializeMobileMenu() {
            const mobileTopBar = document.getElementById('mobileTopBar');
            const sidebar = document.querySelector('.sidebar');

            if (mobileTopBar && sidebar) {
                // Toggle sidebar on top bar click
                mobileTopBar.addEventListener('click', (e) => {
                    e.stopPropagation();
                    sidebar.classList.toggle('open');
                    document.body.classList.toggle('sidebar-open');
                });

                // Close sidebar when clicking on overlay
                document.addEventListener('click', (e) => {
                    if (sidebar.classList.contains('open') &&
                        !sidebar.contains(e.target) &&
                        !mobileTopBar.contains(e.target)) {
                        sidebar.classList.remove('open');
                        document.body.classList.remove('sidebar-open');
                    }
                });

                // Close sidebar when an input triggers simulation (Enter key on mobile)
                const sidebarInputs = document.querySelectorAll('.sidebar input, .sidebar select');
                sidebarInputs.forEach(input => {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && window.innerWidth <= 768) {
                            sidebar.classList.remove('open');
                            document.body.classList.remove('sidebar-open');
                        }
                    });
                });
            }
        }

        // Wait for DOM to be ready and sidebar to be loaded
        function initializeApp() {
            const runButton = document.getElementById('runSimulation');
            const statusDiv = document.getElementById('status');
            const loadingDiv = document.getElementById('loading');

            // Initialize mobile menu
            initializeMobileMenu();

            // If button doesn't exist yet, wait and try again
            if (!runButton) {
                setTimeout(initializeApp, 100);
                return;
            }

            // Initialize parameter displays with current values
            if (typeof updateParameterDisplays === 'function') {
                updateParameterDisplays();
            }
        const plotsDiv = document.getElementById('plots');

        function setStatus(message, type) {
            if (statusDiv) {
                statusDiv.textContent = message;
                statusDiv.className = 'status ' + type;
            }
        }

        function getParameters() {
            return {
                // Simulation settings (using dot notation for nested Parameters structure)
                'simulation_settings.start_year': parseFloat(document.getElementById('agreement_year').value),
                'simulation_settings.end_year': parseFloat(document.getElementById('end_year').value),
                'simulation_settings.time_step_years': parseFloat(document.getElementById('increment').value),
                'simulation_settings.num_simulations': parseInt(document.getElementById('num_simulations').value),

                // Covert project strategy
                'covert_project_strategy.run_a_covert_project': document.getElementById('run_covert_project').checked,
                'covert_project_strategy.proportion_of_initial_compute_stock_to_divert': parseFloat(document.getElementById('proportion_of_initial_chip_stock_to_divert').value),
                'covert_project_strategy.GW_per_initial_datacenter': parseFloat(document.getElementById('GW_per_initial_datacenter').value),
                'covert_project_strategy.number_of_initial_datacenters': parseFloat(document.getElementById('number_of_initial_datacenters').value),
                'covert_project_strategy.datacenter_construction_labor': parseInt(document.getElementById('datacenter_construction_labor').value),
                'covert_project_strategy.build_a_covert_fab': document.getElementById('build_covert_fab').checked,
                'covert_project_strategy.covert_fab_operating_labor': parseInt(document.getElementById('operating_labor').value),
                'covert_project_strategy.covert_fab_construction_labor': parseInt(document.getElementById('construction_labor').value),
                'covert_project_strategy.covert_fab_process_node': document.getElementById('process_node').value,
                'covert_project_strategy.covert_fab_proportion_of_prc_lithography_scanners_devoted': parseFloat(document.getElementById('scanner_proportion').value),

                // Covert project parameters - detection
                'covert_project_parameters.p_project_exists': parseFloat(document.getElementById('covert_project_parameters.p_project_exists').value),
                'covert_project_parameters.mean_detection_time_for_100_workers': parseFloat(document.getElementById('mean_detection_time_100').value),
                'covert_project_parameters.mean_detection_time_for_1000_workers': parseFloat(document.getElementById('mean_detection_time_1000').value),
                'covert_project_parameters.variance_of_detection_time_given_num_workers': parseFloat(document.getElementById('variance_detection_time').value),

                // Initial PRC compute stock parameters
                'covert_project_parameters.initial_compute_stock_parameters.total_prc_compute_stock_in_2025': parseFloat(document.getElementById('total_prc_compute_stock_in_2025').value) * 1e6,
                'covert_project_parameters.initial_compute_stock_parameters.annual_growth_rate_of_prc_compute_stock': parseFloat(document.getElementById('annual_growth_rate_of_prc_compute_stock').value),
                'covert_project_parameters.initial_compute_stock_parameters.relative_sigma_of_prc_compute_stock': parseFloat(document.getElementById('relative_sigma_of_prc_compute_stock').value),
                'covert_project_parameters.initial_compute_stock_parameters.us_intelligence_median_error_in_estimate_of_prc_compute_stock': parseFloat(document.getElementById('us_intelligence_median_error_in_estimate_of_prc_compute_stock').value),
                'covert_project_parameters.initial_compute_stock_parameters.energy_efficiency_relative_to_h100': parseFloat(document.getElementById('energy_efficiency_relative_to_h100').value),
                'covert_project_parameters.initial_compute_stock_parameters.h100_power_watts': parseFloat(document.getElementById('h100_power_watts').value),

                // Survival rate parameters
                'covert_project_parameters.survival_rate_parameters.initial_hazard_rate_p50': parseFloat(document.getElementById('initial_hazard_rate_p50').value),
                'covert_project_parameters.survival_rate_parameters.increase_of_hazard_rate_per_year_p50': parseFloat(document.getElementById('increase_of_hazard_rate_per_year_p50').value),
                'covert_project_parameters.survival_rate_parameters.hazard_rate_p25_relative_to_p50': parseFloat(document.getElementById('hazard_rate_p25_relative_to_p50').value),
                'covert_project_parameters.survival_rate_parameters.hazard_rate_p75_relative_to_p50': parseFloat(document.getElementById('hazard_rate_p75_relative_to_p50').value),

                // Covert datacenter parameters
                'covert_project_parameters.datacenter_model_parameters.max_proportion_of_PRC_energy_consumption': parseFloat(document.getElementById('max_proportion_of_PRC_energy_consumption').value),
                'covert_project_parameters.datacenter_model_parameters.total_GW_of_PRC_energy_consumption': parseFloat(document.getElementById('total_GW_of_PRC_energy_consumption').value),
                'covert_project_parameters.datacenter_model_parameters.MW_per_construction_worker_per_year': parseFloat(document.getElementById('MW_per_construction_worker_per_year').value),
                'covert_project_parameters.datacenter_model_parameters.relative_sigma_mw_per_construction_worker_per_year': parseFloat(document.getElementById('relative_sigma_mw_per_construction_worker_per_year').value),
                'covert_project_parameters.datacenter_model_parameters.operating_labor_per_MW': parseFloat(document.getElementById('operating_labor_per_MW').value),
                'covert_project_parameters.datacenter_model_parameters.relative_sigma_operating_labor_per_MW': parseFloat(document.getElementById('relative_sigma_operating_labor_per_MW').value),

                // Covert fab parameters - detection
                'covert_project_parameters.covert_fab_parameters.median_absolute_relative_error_of_us_intelligence_estimate_of_prc_sme_stock': parseFloat(document.getElementById('proportion_diverted_sme').value),

                // Covert fab parameters - production capacity
                'covert_project_parameters.covert_fab_parameters.wafers_per_month_per_worker': parseFloat(document.getElementById('wafers_per_month_per_worker').value),
                'covert_project_parameters.covert_fab_parameters.labor_productivity_relative_sigma': parseFloat(document.getElementById('labor_productivity_sigma').value),
                'covert_project_parameters.covert_fab_parameters.wafers_per_month_per_lithography_scanner': parseFloat(document.getElementById('wafers_per_month_per_scanner').value),
                'covert_project_parameters.covert_fab_parameters.scanner_productivity_relative_sigma': parseFloat(document.getElementById('scanner_productivity_sigma').value),

                // Covert fab parameters - construction time
                'covert_project_parameters.covert_fab_parameters.construction_time_for_5k_wafers_per_month': parseFloat(document.getElementById('construction_time_5k').value),
                'covert_project_parameters.covert_fab_parameters.construction_time_for_100k_wafers_per_month': parseFloat(document.getElementById('construction_time_100k').value),
                'covert_project_parameters.covert_fab_parameters.construction_time_relative_sigma': parseFloat(document.getElementById('construction_time_sigma').value),
                'covert_project_parameters.covert_fab_parameters.construction_workers_per_1000_wafers_per_month': parseFloat(document.getElementById('construction_workers_per_1000').value),

                // Covert fab parameters - chip production
                'covert_project_parameters.covert_fab_parameters.h100_sized_chips_per_wafer': parseFloat(document.getElementById('chips_per_wafer').value),
                'covert_project_parameters.covert_fab_parameters.transistor_density_scaling_exponent': parseFloat(document.getElementById('transistor_density_exponent').value),
                'covert_project_parameters.covert_fab_parameters.architecture_efficiency_improvement_per_year': parseFloat(document.getElementById('architecture_efficiency').value),

                // Covert fab parameters - energy efficiency scaling
                'covert_project_parameters.covert_fab_parameters.watts_per_tpp_vs_transistor_density_exponent_before_dennard_scaling_ended': parseFloat(document.getElementById('watts_per_tpp_exponent_before_dennard').value),
                'covert_project_parameters.covert_fab_parameters.watts_per_tpp_vs_transistor_density_exponent_after_dennard_scaling_ended': parseFloat(document.getElementById('watts_per_tpp_exponent_after_dennard').value),
                'covert_project_parameters.covert_fab_parameters.transistor_density_at_end_of_dennard_scaling_m_per_mm2': parseFloat(document.getElementById('transistor_density_at_dennard_end').value),

                // Covert fab parameters - PRC scanner production
                'covert_project_parameters.covert_fab_parameters.prc_lithography_scanners_produced_in_first_year': parseFloat(document.getElementById('prc_scanners_first_year').value),
                'covert_project_parameters.covert_fab_parameters.prc_additional_lithography_scanners_produced_per_year': parseFloat(document.getElementById('prc_scanners_per_year').value),
                'covert_project_parameters.covert_fab_parameters.prc_scanner_production_relative_sigma': parseFloat(document.getElementById('prc_scanner_production_sigma').value),

                // Covert fab parameters - localization probabilities
                'covert_project_parameters.covert_fab_parameters.localization_130nm_2025': parseFloat(document.getElementById('localization_130nm_2025').value),
                'covert_project_parameters.covert_fab_parameters.localization_130nm_2031': parseFloat(document.getElementById('localization_130nm_2031').value),
                'covert_project_parameters.covert_fab_parameters.localization_28nm_2025': parseFloat(document.getElementById('localization_28nm_2025').value),
                'covert_project_parameters.covert_fab_parameters.localization_28nm_2031': parseFloat(document.getElementById('localization_28nm_2031').value),
                'covert_project_parameters.covert_fab_parameters.localization_14nm_2025': parseFloat(document.getElementById('localization_14nm_2025').value),
                'covert_project_parameters.covert_fab_parameters.localization_14nm_2031': parseFloat(document.getElementById('localization_14nm_2031').value),
                'covert_project_parameters.covert_fab_parameters.localization_7nm_2025': parseFloat(document.getElementById('localization_7nm_2025').value),
                'covert_project_parameters.covert_fab_parameters.localization_7nm_2031': parseFloat(document.getElementById('localization_7nm_2031').value)
            };
        }

        async function runSimulation() {
            runButton.disabled = true;
            loadingDiv.classList.add('active');
            plotsDiv.style.display = 'none';
            setStatus('Running simulation...', 'info');

            try {
                const params = getParameters();
                const response = await fetch('/run_simulation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    throw new Error('Simulation failed');
                }

                const data = await response.json();

                // Plot Initial Stock section
                plotInitialStock(data);

                // Plot main charts
                plotTimeSeries(data);
                plotH100YearsTimeSeries(data);
                plotComputeCcdf(data);
                updateDashboard(data);
                plotDarkComputeModel(data);
                plotDatacenterCombined(data);
                plotDatacenterCapacityCcdf(data);
                plotProjectH100YearsCcdf(data);
                updateDatacenterDashboard(data);
                createIntelligenceAccuracyPlot();
                createDetectionLatencyPlot();

                // Force resize after a brief delay to ensure plots fill containers
                setTimeout(() => {
                    Plotly.Plots.resize('initialDarkComputePlot');
                    Plotly.Plots.resize('covertFabFlowPlot');
                    Plotly.Plots.resize('chipSurvivalPlot');
                    Plotly.Plots.resize('totalDarkComputePlot');
                    Plotly.Plots.resize('initialDarkComputeDetectionPlot');
                    Plotly.Plots.resize('initialComputeStockPlot');
                    Plotly.Plots.resize('lrPrcAccountingPlot');
                    Plotly.Plots.resize('lrCombinedPlot');
                    Plotly.Plots.resize('initialPrcStockPlot');
                    Plotly.Plots.resize('darkComputeResultPlot');
                    Plotly.Plots.resize('timeSeriesPlot');
                    Plotly.Plots.resize('h100YearsTimeSeriesPlot');
                    Plotly.Plots.resize('computeCcdfPlot');
                    Plotly.Plots.resize('datacenterCombinedPlot');
                    Plotly.Plots.resize('datacenterCapacityCcdfPlot');
                    Plotly.Plots.resize('intelligenceAccuracyPlot');
                    Plotly.Plots.resize('detectionLatencyPlot');
                    // Individual LR component plots are resized in dark_compute_model_section.js
                    Plotly.Plots.resize('lrOtherIntelPlot');
                    Plotly.Plots.resize('posteriorProbProjectPlot');
                }, 100);

                // Plot LR breakdown
                if (data.covert_fab && data.covert_fab.lr_inventory) {
                    const years = data.covert_fab.years;

                    // LR Inventory - PDF of values across simulations at final timestep
                    const lrInventoryFinal = data.covert_fab.lr_inventory.individual.map(sim => sim[sim.length - 1]);
                    // Use log scale x-axis but show actual LR values (not log values)
                    plotPDF('lrInventoryPlot', lrInventoryFinal, '#5B8DBE', 'Likelihood Ratio', 10, true);

                    // LR Procurement - Categorical bar plot (1 or 10)
                    const lrProcurementFinal = data.covert_fab.lr_procurement.individual.map(sim => sim[sim.length - 1]);
                    plotCategoricalFrequency('lrProcurementPlot', lrProcurementFinal, [
                        { value: 1, label: 'Likelihood Ratio = 1<br>(>90% localization)' },
                        { value: 10, label: 'Likelihood Ratio = 10<br>(≤90% localization)' }
                    ], '#5B8DBE');

                    // LR Other - Median over time with percentiles
                    const lrOtherArray = data.covert_fab.lr_other.individual.map(sim => sim.map(v => v));
                    const lrOtherP25 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const lrOtherP75 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });
                    plotMedianWithPercentiles('lrOtherPlot', {
                        median: data.covert_fab.lr_other.median,
                        p25: lrOtherP25,
                        p75: lrOtherP75,
                        individual: data.covert_fab.lr_other.individual
                    }, years, '#5B8DBE', 'Likelihood Ratio', null, true, true);

                    // Plot combined LR (product of inventory, procurement, and other intelligence)
                    plotMedianWithPercentiles('posteriorProbPlot', {
                        median: data.covert_fab.lr_combined.median,
                        p25: data.covert_fab.lr_combined.p25,
                        p75: data.covert_fab.lr_combined.p75,
                        individual: data.covert_fab.lr_combined.individual
                    }, data.covert_fab.years, '#5B8DBE', 'Likelihood Ratio', null, true, true);
                }

                // Plot "Strength of Evidence of Covert Project" section
                if (data.initial_stock && data.initial_stock.lr_prc_accounting_samples && data.dark_compute_model) {
                    const years = data.dark_compute_model.years;

                    // Get prior probability from parameters and calculate prior odds
                    const priorProb = parseFloat(document.getElementById('covert_project_parameters.p_project_exists').value);
                    const priorOddsProject = priorProb / (1 - priorProb);

                    // Display prior odds
                    document.getElementById('dashboardPriorProject').innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <div class="breakdown-box-inner">${priorOddsProject.toFixed(3)}</div>
                            <div class="breakdown-label">Prior Odds of<br>Covert Project</div>
                        </div>`;

                    // Attach hover effect to the newly created breakdown-box-inner
                    const dashboardPriorProjectInner = document.querySelector('#dashboardPriorProject .breakdown-box-inner');
                    if (dashboardPriorProjectInner) {
                        dashboardPriorProjectInner.style.transition = 'all 0.2s ease';
                        dashboardPriorProjectInner.addEventListener('mouseenter', () => {
                            dashboardPriorProjectInner.style.boxShadow = '0 0 6px rgba(0, 123, 255, 0.25)';
                            dashboardPriorProjectInner.style.transform = 'scale(1.015)';
                        });
                        dashboardPriorProjectInner.addEventListener('mouseleave', () => {
                            dashboardPriorProjectInner.style.boxShadow = '';
                            dashboardPriorProjectInner.style.transform = '';
                        });
                    }

                    // Note: Individual LR component plots are now created in dark_compute_model_section.js
                    // This includes lrPrcAccountingPlot, lrSmeInventoryPlot, and lrReportedAssetsPlot

                    // 3. LR from other intelligence sources (same as lrOtherPlot)
                    const lrOtherArray = data.covert_fab.lr_other.individual.map(sim => sim.map(v => v));
                    const lrOtherP25 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const lrOtherP75 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });
                    plotMedianWithPercentiles('lrOtherIntelPlot', {
                        median: data.covert_fab.lr_other.median,
                        p25: lrOtherP25,
                        p75: lrOtherP75,
                        individual: data.covert_fab.lr_other.individual
                    }, years, '#5B8DBE', 'Likelihood Ratio', null, true, true);

                    // 4. Posterior probability of covert project
                    // Use backend data from US intelligence beliefs (same as Simulation Runs plot)
                    // Custom plotting to add threshold lines
                    const posteriorData = data.dark_compute_model.posterior_prob_project;

                    // Define thresholds with colors matching H100-Years plot
                    const thresholds = [
                        { multiplier: 1, color: '#9B7BB3', label: '1x update' },  // Purple
                        { multiplier: 3, color: '#5B8DBE', label: '3x update' },  // Blue
                        { multiplier: 5, color: '#5AA89B', label: '5x update' }   // Blue-green
                    ];

                    const traces = [
                        {
                            x: years,
                            y: posteriorData.p75,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        {
                            x: years,
                            y: posteriorData.p25,
                            type: 'scatter',
                            mode: 'lines',
                            fill: 'tonexty',
                            fillcolor: 'rgba(91, 141, 190, 0.2)',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        {
                            x: years,
                            y: posteriorData.median,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: '#5B8DBE', width: 2 },
                            name: 'Posterior Probability',
                            showlegend: false
                        }
                    ];

                    // Add threshold lines
                    for (const threshold of thresholds) {
                        const thresholdOdds = priorOddsProject * threshold.multiplier;
                        const thresholdProb = thresholdOdds / (1 + thresholdOdds);

                        traces.push({
                            x: [years[0], years[years.length - 1]],
                            y: [thresholdProb, thresholdProb],
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: threshold.color, width: 2, dash: 'dash' },
                            name: `Detection (${threshold.multiplier}x)`,
                            showlegend: true
                        });
                    }

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 }
                        },
                        yaxis: {
                            title: 'Posterior Probability',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            tickformat: '.0%',
                            range: [0, 1]
                        },
                        margin: { l: 50, r: 20, t: 15, b: 60 },
                        height: 240,
                        hovermode: 'x unified',
                        showlegend: true,
                        legend: {
                            x: 0.98,
                            y: 0.02,
                            xanchor: 'right',
                            yanchor: 'bottom',
                            bgcolor: 'rgba(255, 255, 255, 0.8)',
                            bordercolor: '#ccc',
                            borderwidth: 1,
                            font: { size: 9 }
                        }
                    };

                    Plotly.newPlot('posteriorProbProjectPlot', traces, layout, {responsive: true, displayModeBar: false});
                }

                // Plot compute breakdown
                if (data.covert_fab && data.covert_fab.is_operational) {
                    const years = data.covert_fab.years;

                    // Proportion Operational - time series showing proportion
                    plotProportionOperational('isOperationalPlot', {
                        proportion: data.covert_fab.is_operational.proportion
                    }, years, '#D4A574', 'Probability');

                    // Wafer Starts per Month - PDF
                    const waferStartsFinal = data.covert_fab.wafer_starts.individual.map(sim => sim[sim.length - 1]);
                    plotPDF('waferStartsPlot', waferStartsFinal, '#9B72B0', 'Wafers/Month');

                    // H100-sized Chips per Wafer - Display as a box (constant value)
                    const chipsPerWaferValue = data.covert_fab.chips_per_wafer.individual[0][0]; // Same for all sims
                    document.getElementById('chipsPerWaferPlot').innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <div class="breakdown-box-inner">${chipsPerWaferValue.toFixed(0)}</div>
                            <div class="breakdown-label">Working H100-sized chips per wafer</div>
                        </div>`;

                    // Attach hover effect to the newly created breakdown-box-inner
                    const chipsPerWaferInner = document.querySelector('#chipsPerWaferPlot .breakdown-box-inner');
                    if (chipsPerWaferInner) {
                        chipsPerWaferInner.style.transition = 'all 0.2s ease';
                        chipsPerWaferInner.addEventListener('mouseenter', () => {
                            chipsPerWaferInner.style.boxShadow = '0 0 6px rgba(0, 123, 255, 0.25)';
                            chipsPerWaferInner.style.transform = 'scale(1.015)';
                        });
                        chipsPerWaferInner.addEventListener('mouseleave', () => {
                            chipsPerWaferInner.style.boxShadow = '';
                            chipsPerWaferInner.style.transform = '';
                        });
                    }

                    // Transistor density relative to H100 - Bar plot at final timestep
                    const transistorDensityFinal = data.covert_fab.transistor_density.individual.map(sim => sim[sim.length - 1]);
                    const processNodes = data.covert_fab.process_node_by_sim;
                    plotBarByProcessNode('computePerChipPlot', transistorDensityFinal, processNodes, '#E8A863');

                    // Architecture Efficiency - Display as a box (constant value at agreement year)
                    const archEffValue = data.covert_fab.architecture_efficiency_at_agreement;
                    document.getElementById('architectureEfficiencyDisplay').innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <div class="breakdown-box-inner">${archEffValue.toFixed(2)}</div>
                            <div class="breakdown-label">Architecture Efficiency (relative to H100)</div>
                        </div>`;

                    // Attach hover effect to the newly created breakdown-box-inner
                    const architectureEfficiencyInner = document.querySelector('#architectureEfficiencyDisplay .breakdown-box-inner');
                    if (architectureEfficiencyInner) {
                        architectureEfficiencyInner.style.transition = 'all 0.2s ease';
                        architectureEfficiencyInner.addEventListener('mouseenter', () => {
                            architectureEfficiencyInner.style.boxShadow = '0 0 6px rgba(0, 123, 255, 0.25)';
                            architectureEfficiencyInner.style.transform = 'scale(1.015)';
                        });
                        architectureEfficiencyInner.addEventListener('mouseleave', () => {
                            architectureEfficiencyInner.style.boxShadow = '';
                            architectureEfficiencyInner.style.transform = '';
                        });
                    }

                    // Total compute - time series over all timesteps
                    const totalComputeArray = data.covert_fab.is_operational.individual.map((opSim, simIdx) => {
                        return opSim.map((isOp, timeIdx) => {
                            return (isOp * data.covert_fab.wafer_starts.individual[simIdx][timeIdx] *
                                    data.covert_fab.architecture_efficiency.individual[simIdx][timeIdx] *
                                    data.covert_fab.compute_per_wafer_2022_arch.individual[simIdx][timeIdx]);
                        });
                    });

                    // Calculate median and percentiles for total compute
                    const totalComputeMedian = years.map((_, i) => {
                        const values = totalComputeArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.5)];
                    });
                    const totalComputeP25 = years.map((_, i) => {
                        const values = totalComputeArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const totalComputeP75 = years.map((_, i) => {
                        const values = totalComputeArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });

                    // Calculate y-axis maximum as 1.2 times the maximum 75th percentile value
                    const maxP75 = Math.max(...totalComputeP75);
                    const yMax = maxP75 * 1.2;

                    plotMedianWithPercentiles('totalComputePlot', {
                        median: totalComputeMedian,
                        p25: totalComputeP25,
                        p75: totalComputeP75,
                        individual: totalComputeArray
                    }, years, '#9B7BB3', 'H100e/Month', [0, yMax], false, true);

                    // Plot energy breakdown
                    // 1. Compute produced per month (reuse from above)
                    plotMedianWithPercentiles('energyComputePerMonthPlot', {
                        median: totalComputeMedian,
                        p25: totalComputeP25,
                        p75: totalComputeP75,
                        individual: totalComputeArray
                    }, years, '#9B7BB3', 'H100e/Month', [0, yMax], false, true);

                    // 2. Transistor density relative to H100 (reuse from above)
                    plotBarByProcessNode('energyTransistorDensityPlot', transistorDensityFinal, processNodes, '#E8A863');

                    // 3. Curve plot: Transistor density vs Energy efficiency
                    // Energy efficiency follows power law from fab_model.py:
                    // watts_per_tpp = H100_watts * (density_ratio)^exponent
                    // efficiency = 1 / (watts_per_tpp / H100_watts) = 1 / (density_ratio^exponent)

                    // Constants from fab_model.py
                    const H100_TRANSISTOR_DENSITY = 98.28;  // Million transistors per mm²
                    const DENNARD_THRESHOLD_DENSITY = 1.98;  // Million transistors per mm²
                    const EXPONENT_BEFORE_DENNARD = -2.006575;
                    const EXPONENT_AFTER_DENNARD = -0.909355;

                    // Use curve data from backend (calculated by Python)
                    const densityRangeRelative = data.covert_fab.watts_per_tpp_curve.density_relative;
                    const wattsPerTppCurve = data.covert_fab.watts_per_tpp_curve.watts_per_tpp_relative;
                    const dennardDataX = 1.98 / 98.28;

                    const xMin = 0.001;  // From your range
                    const xMax = 100;    // From your range

                    // Convert data coordinate to paper coordinate for log scale
                    const dennardPaperX = (Math.log10(dennardDataX) - Math.log10(xMin)) / 
                                        (Math.log10(xMax) - Math.log10(xMin));


                    // Create curve plot with actual simulation points overlaid
                    Plotly.newPlot('densityVsEfficiencyPlot', [
                        {
                            x: densityRangeRelative,
                            y: wattsPerTppCurve,
                            mode: 'lines',
                            type: 'scatter',
                            line: {
                                color: '#74B3A8',
                                width: 2
                            },
                            name: 'Power Law',
                            hovertemplate: 'Density: %{x:.2g}x<br>Efficiency: %{y:.2g}x<extra></extra>'
                        },
                        {
                            x: transistorDensityFinal,
                            y: data.covert_fab.watts_per_tpp.individual.map(sim => sim[sim.length - 1]),
                            mode: 'markers',
                            type: 'scatter',
                            marker: {
                                size: 6,
                                color: '#E8A863',
                                opacity: 0.7
                            },
                            name: 'Simulations',
                            hovertemplate: 'Density: %{x:.2g}x<br>Watts/TPP: %{y:.2g}x<extra></extra>'
                        }
                    ], {
                        xaxis: {
                            title: 'Transistor Density (relative to H100)',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            type: 'log',
                            range: [Math.log10(0.001), Math.log10(100)],
                            automargin: true
                        },
                        yaxis: {
                            title: 'Watts per TPP (relative to H100)',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            type: 'log',
                            tickmode: 'array',
                            tickvals: [0.01, 0.1, 1, 10, 100, 1000],
                            automargin: true
                        },
                        shapes: [{
                            type: 'line',
                            x0: dennardPaperX,
                            x1: dennardPaperX,
                            y0: 0,
                            y1: 1,
                            xref: 'paper',
                            yref: 'paper',
                            line: {
                                color: '#999',
                                width: 1,
                                dash: 'dot'
                            }
                        }],
                        annotations: [{
                            x: dennardPaperX + 0.02,
                            y: 0.85,
                            yref: 'paper',
                            xref: 'paper',
                            xanchor: 'left',
                            yanchor: 'bottom',
                            text: 'End of Dennard<br>Scaling',
                            showarrow: false,
                            align: "left",
                            font: {
                                size: 9,
                                color: '#666',
                            }
                        }],
                        margin: { l: 60, r: 10, t: 10, b: 65, pad: 10 },
                        showlegend: false,
                        hovermode: 'closest'
                    }, {displayModeBar: false, responsive: true});
                    setTimeout(() => Plotly.Plots.resize('densityVsEfficiencyPlot'), 50);

                    // 4. Display H100 energy requirements (from user input)
                    const h100PowerWatts = parseFloat(document.getElementById('h100_power_watts').value);
                    const h100EnergyWatts = h100PowerWatts; // Store in watts for calculations below
                    const h100EnergyKW = h100PowerWatts / 1000;
                    document.getElementById('h100EnergyDisplay').innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <div class="breakdown-box-inner">${h100EnergyKW.toFixed(2)} kW</div>
                            <div class="breakdown-label">Energy requirements of H100</div>
                        </div>`;

                    // Attach hover effect to the newly created breakdown-box-inner
                    const h100EnergyInner = document.querySelector('#h100EnergyDisplay .breakdown-box-inner');
                    if (h100EnergyInner) {
                        h100EnergyInner.style.transition = 'all 0.2s ease';
                        h100EnergyInner.addEventListener('mouseenter', () => {
                            h100EnergyInner.style.boxShadow = '0 0 6px rgba(0, 123, 255, 0.25)';
                            h100EnergyInner.style.transform = 'scale(1.015)';
                        });
                        h100EnergyInner.addEventListener('mouseleave', () => {
                            h100EnergyInner.style.boxShadow = '';
                            h100EnergyInner.style.transform = '';
                        });
                    }

                    // 5. Calculate and plot energy requirements per month (GW/month)
                    // Energy = H100e_per_month × watts_per_TPP_relative × H100_energy
                    // Note: transistor_density is already factored into H100e calculation, don't multiply again!
                    const wattsPerTppBySimAndTime = data.covert_fab.watts_per_tpp.individual;

                    const energyPerMonthArray = totalComputeArray.map((simArray, simIdx) => {
                        return simArray.map((h100ePerMonth, timeIdx) => {
                            // h100ePerMonth is actual H100e count (not in thousands)
                            const wattsPerTppRelative = wattsPerTppBySimAndTime[simIdx][timeIdx];

                            // Energy (W) = H100e × watts_per_TPP_rel × H100_energy_watts
                            const totalWatts = h100ePerMonth * wattsPerTppRelative * h100EnergyWatts;
                            const energyGW = totalWatts / 1e9;
                            return energyGW;
                        });
                    });

                    const energyPerMonthMedian = years.map((_, i) => {
                        const values = energyPerMonthArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.5)];
                    });
                    const energyPerMonthP25 = years.map((_, i) => {
                        const values = energyPerMonthArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const energyPerMonthP75 = years.map((_, i) => {
                        const values = energyPerMonthArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });

                    const maxEnergyP75 = Math.max(...energyPerMonthP75);
                    const yMaxEnergy = maxEnergyP75 * 1.2;

                    plotMedianWithPercentiles('energyPerMonthPlot', {
                        median: energyPerMonthMedian,
                        p25: energyPerMonthP25,
                        p75: energyPerMonthP75,
                        individual: energyPerMonthArray
                    }, years, '#5AA89B', 'GW/Month', [0, yMaxEnergy], false, true);
                }

                // Check if project is running
                const runCovertProject = document.getElementById('run_covert_project').checked;
                const buildCovertFab = document.getElementById('build_covert_fab').checked;
                const projectNotRunDiv = document.getElementById('projectNotRun');
                const plotsContentDiv = document.getElementById('plotsContent');

                if (runCovertProject && buildCovertFab) {
                    // Show normal plots
                    projectNotRunDiv.style.display = 'none';
                    plotsContentDiv.style.display = 'block';
                } else {
                    // Show "project not run" message
                    projectNotRunDiv.style.display = 'block';
                    plotsContentDiv.style.display = 'none';
                }

                plotsDiv.style.display = 'block';
                loadingDiv.classList.remove('active');
                setStatus(`Simulation complete! Ran ${data.num_simulations} simulations`, 'success');
            } catch (error) {
                loadingDiv.classList.remove('active');
                setStatus('Error: ' + error.message, 'error');
            } finally {
                runButton.disabled = false;
            }
        }

        runButton.addEventListener('click', runSimulation);

        // Run simulation automatically on page load
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(runSimulation, 500); // Small delay to ensure page is fully loaded
        });

        // Add Enter key listener to all input fields and select elements in sidebar
        const sidebarInputs = document.querySelectorAll('.sidebar input, .sidebar select');
        sidebarInputs.forEach(input => {
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    runSimulation();
                }
            });
        });

        // Add click handler to breakdown box to focus corresponding input field
        const diversionProportionDisplay = document.getElementById('diversionProportionDisplay');
        if (diversionProportionDisplay) {
            diversionProportionDisplay.addEventListener('click', () => {
                const inputField = document.getElementById('proportion_of_initial_chip_stock_to_divert');
                if (inputField) {
                    inputField.focus();
                    inputField.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
            // Add cursor pointer style to indicate it's clickable
            diversionProportionDisplay.style.cursor = 'pointer';
        }

        // Setup tooltip handlers
        const globalTooltip = document.getElementById('globalTooltip');
        const tooltipElements = document.querySelectorAll('.has-tooltip');

        let hideTooltipTimeout;
        let currentTooltipElement = null;

        function hideTooltip() {
            globalTooltip.classList.remove('visible');
            globalTooltip.style.opacity = '0';
            currentTooltipElement = null;
        }

        function isMouseOverElementOrTooltip(mouseEvent) {
            // Check if mouse is over the current tooltip element
            if (currentTooltipElement && currentTooltipElement.matches(':hover')) {
                return true;
            }
            // Check if mouse is over the tooltip itself
            if (globalTooltip.matches(':hover')) {
                return true;
            }
            return false;
        }

        tooltipElements.forEach(element => {
            element.addEventListener('mouseenter', (e) => {
                clearTimeout(hideTooltipTimeout);
                currentTooltipElement = element;
                const tooltipText = element.getAttribute('data-tooltip');
                const downloadUrl = element.getAttribute('data-download');
                const imageUrl = element.getAttribute('data-image');
                const imageBeforeText = element.getAttribute('data-image-before-text');
                const imageAfterText = element.getAttribute('data-image-after-text');

                if (tooltipText) {
                    // Add the tooltip text
                    let content = tooltipText;

                    // Add image if data-image attribute exists
                    if (imageUrl) {
                        if (imageBeforeText) {
                            // Insert image before the specified text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageBeforeText}`;
                        } else if (imageAfterText) {
                            // Insert image after the tooltip text, then add the after text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageAfterText}`;
                        } else {
                            // Default: add image after tooltip text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px;" alt="Capabilities table">`;
                        }
                    }

                    // Add download button only if data-download attribute exists
                    if (downloadUrl) {
                        const fileName = downloadUrl.split('/').pop() + '.csv';
                        content += `<br><br><button onclick='window.location.href="${downloadUrl}"' style='margin-top: 8px; padding: 6px 12px; background-color: #555; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; pointer-events: auto;'>Download ${fileName}</button>`;
                    }

                    globalTooltip.innerHTML = content;

                    // Get the position of the element
                    const rect = element.getBoundingClientRect();

                    // Position tooltip to the right of the element
                    globalTooltip.style.left = (rect.right + 10) + 'px';

                    // Calculate vertical position to keep tooltip within viewport
                    let topPosition = rect.top;

                    // Show tooltip temporarily to measure its height
                    globalTooltip.style.visibility = 'hidden';
                    globalTooltip.style.opacity = '1';
                    globalTooltip.classList.add('visible');

                    const tooltipHeight = globalTooltip.offsetHeight;
                    const viewportHeight = window.innerHeight;

                    // If tooltip would go off bottom of screen, adjust position
                    if (topPosition + tooltipHeight > viewportHeight) {
                        topPosition = Math.max(10, viewportHeight - tooltipHeight - 10);
                    }

                    // If tooltip would go off top of screen, adjust position
                    if (topPosition < 10) {
                        topPosition = 10;
                    }

                    globalTooltip.style.top = topPosition + 'px';

                    // Now show tooltip properly
                    globalTooltip.style.visibility = 'visible';
                }
            });

            element.addEventListener('mouseleave', (e) => {
                // Give a short delay to allow mouse to move to tooltip
                hideTooltipTimeout = setTimeout(() => {
                    // Only hide if mouse is not over the element or tooltip
                    if (!isMouseOverElementOrTooltip(e)) {
                        hideTooltip();
                    }
                }, 100);
            });
        });

        // Keep tooltip visible when hovering over it
        globalTooltip.addEventListener('mouseenter', () => {
            clearTimeout(hideTooltipTimeout);
        });

        globalTooltip.addEventListener('mouseleave', () => {
            // Check if we're moving back to the original element
            hideTooltipTimeout = setTimeout(() => {
                if (!isMouseOverElementOrTooltip(event)) {
                    hideTooltip();
                }
            }, 100);
        });

        // Make breakdown plots clickable and link to sidebar inputs
        const plotToInputMapping = {
            // Covert Fab Section - US Bayesian Inference plots
            'lrInventoryPlot': 'proportion_diverted_sme', // Median absolute relative error of US intelligence estimate of PRC SME stock
            'lrProcurementPlot': 'localization_130nm_2025', // Probability PRC achieves >90% indigenization
            'lrOtherPlot': 'mean_detection_time_100', // Detection time
            'posteriorProbPlot': null, // Output, not an input

            // Covert Fab Section - Compute Production Rate plots
            'isOperationalPlot': 'construction_time_5k', // First construction time param
            'waferStartsPlot': 'wafers_per_month_per_worker', // Operating labor productivity
            'chipsPerWaferPlot': 'chips_per_wafer',
            'computePerChipPlot': 'transistor_density_exponent',
            'architectureEfficiencyDisplay': 'architecture_efficiency',
            'totalComputePlot': null, // Output, not an input

            // Covert Fab Section - Energy Requirements plots
            'energyTransistorDensityPlot': 'transistor_density_exponent',
            'densityVsEfficiencyPlot': 'watts_per_tpp_exponent_before_dennard',
            'h100EnergyDisplay': 'h100_power_watts',
            'energyComputePerMonthPlot': null, // This shows compute per month, not an input
            'energyPerMonthPlot': null, // Output, not an input

            // Dark Compute Model Section - Dark Compute Stock Breakdown
            'initialDarkComputePlot': 'proportion_of_initial_chip_stock_to_divert',
            'covertFabFlowPlot': '#covertFabComputeProductionBreakdown', // Scroll to section instead of input
            'chipSurvivalPlot': 'increase_of_hazard_rate_per_year_p50',
            'totalDarkComputePlot': null, // Output, not an input

            // Dark Compute Model Section - Data Center Capacity Breakdown
            'datacenterCapacityPlot2': 'GW_per_initial_datacenter',
            'darkComputeEnergyPlot': 'h100_power_watts',
            'operationalDarkComputePlot': null, // Output, not an input

            // Dark Compute Model Section - US Estimated Likelihood of PRC Covert Project
            'dashboardPriorProject': 'covert_project_parameters.p_project_exists',
            'lrPrcAccountingPlot': '#initialStockIntelligenceBreakdown', // Individual component plots
            'lrSmeInventoryPlot': 'proportion_diverted_sme',
            'lrReportedAssetsPlot': null, // Combined output
            'lrOtherIntelPlot': 'mean_detection_time_100',
            'posteriorProbProjectPlot': null, // Output, not an input

            // Initial Stock Section - Compute Breakdown
            'initialPrcStockPlot': 'total_prc_compute_stock_in_2025',
            'darkComputeResultPlot': null, // Output, not an input

            // Initial Stock Section - Intelligence Evidence Breakdown
            'lrPrcAccountingPlot': 'us_intelligence_median_error_in_estimate_of_prc_compute_stock',
            'lrCombinedPlot': null // Output, not an input
        };

        // Add clickable class and click handlers to plots with associated inputs
        // Skip boxes that have dynamically created innerHTML (they handle hover effects manually)
        const dynamicallyCreatedBoxes = [
            'dashboardPriorProject',
            'chipsPerWaferPlot',
            'architectureEfficiencyDisplay',
            'h100EnergyDisplay',
            'diversionProportionDisplay'
        ];

        Object.entries(plotToInputMapping).forEach(([plotId, inputId]) => {
            const plotElement = document.getElementById(plotId);
            if (plotElement && inputId) {
                // Skip hover effect setup for dynamically created boxes (they handle it themselves)
                if (!dynamicallyCreatedBoxes.includes(plotId)) {
                    // For breakdown boxes, target the inner element if it exists, otherwise target the box itself
                    const innerElement = plotElement.classList.contains('breakdown-box')
                        ? plotElement.querySelector('.breakdown-box-inner')
                        : null;
                    const hoverTarget = innerElement || plotElement;

                    // Add consistent hover styles
                    hoverTarget.style.transition = 'all 0.2s ease';

                    // Add hover effect via event listeners
                    hoverTarget.addEventListener('mouseenter', () => {
                        hoverTarget.style.boxShadow = '0 0 6px rgba(0, 123, 255, 0.25)';
                        hoverTarget.style.transform = 'scale(1.015)';
                    });
                    hoverTarget.addEventListener('mouseleave', () => {
                        hoverTarget.style.boxShadow = '';
                        hoverTarget.style.transform = '';
                    });
                }

                // Make the whole element clickable
                plotElement.style.cursor = 'pointer';

                // Add click handler
                plotElement.addEventListener('click', () => {
                    // Check if inputId is a section (starts with #) or an input field
                    if (inputId.startsWith('#')) {
                        // Scroll to section
                        const sectionElement = document.getElementById(inputId.substring(1));
                        if (sectionElement) {
                            sectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    } else {
                        // Focus on input field
                        const inputElement = document.getElementById(inputId);
                        if (inputElement) {
                            // Scroll input into view
                            inputElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            // Focus and select the input
                            setTimeout(() => {
                                inputElement.focus();
                                inputElement.select();
                            }, 300);
                        }
                    }
                });
            }
        });
        }  // End of initializeApp function

        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>
