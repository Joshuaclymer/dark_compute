<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Covert Compute Production Model</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script>
        // Function to send errors to backend
        function logErrorToBackend(errorData) {
            fetch('/log_client_error', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(errorData)
            }).catch(err => console.error('Failed to log error to backend:', err));
        }

        // Global error handler to catch and display all JavaScript errors
        window.addEventListener('error', function(event) {
            const errorData = {
                message: event.message,
                source: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack || 'No stack trace available'
            };

            console.error('Global error caught:', event.error);
            console.error('Error message:', event.message);
            console.error('Error stack:', event.error?.stack);

            // Send to backend
            logErrorToBackend(errorData);

            // Display error in UI
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:20px;right:20px;background:#ff4444;color:white;padding:15px;border-radius:5px;max-width:400px;z-index:10000;font-family:monospace;font-size:12px;';
            errorDiv.innerHTML = `<strong>JavaScript Error:</strong><br>${event.message}<br><small>${event.filename}:${event.lineno}</small>`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 10000);
        });

        // Catch unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            const errorData = {
                message: 'Unhandled Promise Rejection',
                reason: String(event.reason),
                stack: event.reason?.stack || 'No stack trace available'
            };

            console.error('Unhandled promise rejection:', event.reason);

            // Send to backend
            logErrorToBackend(errorData);
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #globalTooltip {
            position: fixed;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            background-color: #333;
            color: #fff;
            text-align: left;
            padding: 15px;
            border-radius: 6px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            pointer-events: none;
            visibility: hidden;
        }

        #globalTooltip.visible {
            pointer-events: auto;
        }

        #globalTooltip * {
            color: #fff !important;
        }

        /* Force Plotly hover labels to use white text */
        .hoverlayer .hovertext path {
            fill: #333 !important;
        }

        .hoverlayer .hovertext text {
            fill: #fff !important;
        }

        g.hovertext path {
            fill: #333 !important;
        }

        g.hovertext text {
            fill: #fff !important;
        }

        #globalTooltip::before {
            content: "";
            position: absolute;
            top: 20px;
            left: -8px;
            border-width: 8px;
            border-style: solid;
            border-color: transparent #333 transparent transparent;
        }

        #globalTooltip.visible {
            visibility: visible;
            opacity: 1;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 20px 20px 20px;
            overflow-y: auto;
        }

        .top-plots {
            display: grid;
            grid-template-columns: minmax(250px, 300px) 1fr 1fr;
            gap: 20px;
            margin-bottom: 10px;
            width: 100%;
            align-items: stretch;
        }

        @media (max-width: 1200px) {
            .top-plots {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 700px) {
            .top-plots {
                grid-template-columns: 1fr;
            }
        }

        .dashboard {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 25px;
            justify-content: center;
        }

        .dashboard-item {
            text-align: center;
        }

        .dashboard-value {
            font-size: 32px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .dashboard-value-small {
            font-size: 20px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .dashboard-label {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 3px;
            line-height: 1.3;
        }

        .dashboard-label-light {
            font-size: 13px;
            font-weight: 400;
            color: #333;
            margin-bottom: 3px;
            line-height: 1.3;
        }

        .dashboard-sublabel {
            font-size: 10px;
            color: #777;
            line-height: 1.3;
        }

        .plot-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            min-width: 0;
            overflow: hidden;
        }

        .plot-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .plot {
            width: 100% !important;
            max-width: 100% !important;
            height: 364px;
        }

        .plot > div {
            width: 100% !important;
            max-width: 100% !important;
        }

        #computeCcdfPlot, #timeSeriesPlot, #h100YearsTimeSeriesPlot {
            border: none !important;
        }

        #computeCcdfPlot > div, #timeSeriesPlot > div, #h100YearsTimeSeriesPlot > div {
            border: none !important;
        }

        .breakdown-plot > div {
            border: none !important;
        }

        .breakdown-section {
            margin-top: 30px;
            padding: 15px 10px;
            background: #f9f9f9;
            border-radius: 8px;
            overflow: visible;
        }

        .breakdown-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }

        .breakdown-plots-row {
            display: flex;
            align-items: flex-start;
            gap: 5px;
            margin-bottom: 10px;
            max-width: 100%;
            width: 100%;
            flex-wrap: wrap;
        }

        .breakdown-labels-row {
            display: flex;
            gap: 5px;
            max-width: 100%;
            width: 100%;
            flex-wrap: wrap;
        }

        .breakdown-item {
            text-align: center;
            min-width: 100px;
            flex: 1 1 170px;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            margin-top: 20px;
        }

        .breakdown-plot {
            height: 240px;
            width: 100%;
            max-width: 100%;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .breakdown-plot.clickable {
            cursor: pointer;
        }

        .breakdown-plot.clickable:hover {
            border-color: #007bff;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.3);
            transform: scale(1.02);
        }

        .breakdown-box {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: #555;
            margin-top: 100px;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
            max-width: 200px;
        }

        .breakdown-box-inner {
            max-height: 200px;
            width: 100%;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            cursor: pointer;
            white-space: nowrap;
        }

        .breakdown-box-inner:hover {
            border-color: #007bff;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.3);
            transform: scale(1.02);
        }

        .breakdown-plot > div:not(.js-plotly-plot) {
            width: 100% !important;
            max-width: 100% !important;
        }

        .breakdown-plot > .js-plotly-plot {
            width: 100% !important;
            max-width: 100% !important;
            height: 100% !important;
            max-height: 100% !important;
        }

        .breakdown-label {
            font-size: 11px;
            font-weight: bold;
            margin-top: 5px;
            color: #555;
            line-height: 1.2;
            text-align: center;
        }

        .breakdown-description {
            font-size: 9px;
            color: #777;
            margin-top: 5px;
            line-height: 1.3;
            font-style: italic;
        }

        .operator {
            font-size: 24px;
            font-weight: bold;
            color: #666;
            padding: 0 3px;
            flex: 0 0 auto;
            position: relative;
            height: 240px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 20px;
        }

        .operator.arrow-operator {
            padding-top: 28px;
            padding-bottom: 0;
            padding-left: 20px;
            padding-right: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .section-description {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- Global tooltip (outside sidebar to avoid clipping) -->
    <div id="globalTooltip"></div>

    <!-- Include the sidebar -->
    {% include 'sidebar.html' %}

    <div class="main-content">
        <div class="loading active" id="loading">
            <h2>Running Simulation...</h2>
            <p>This may take a few moments.</p>
        </div>

        <div id="plots" style="display: none;">
            <!-- Dark Compute Model Section -->
            {% include 'dark_compute_model_section.html' %}

            <!-- Initial Stock Section -->
            {% include 'initial_stock_section.html' %}

            <!-- Covert Data Centers Section -->
            {% include 'covert_data_centers_section.html' %}

            <!-- Covert Fab Section -->
            {% include 'covert_fab_section.html' %}
        </div>
    </div>

    <script>
        // Wait for DOM to be ready and sidebar to be loaded
        function initializeApp() {
            const runButton = document.getElementById('runSimulation');
            const statusDiv = document.getElementById('status');
            const loadingDiv = document.getElementById('loading');

            // If button doesn't exist yet, wait and try again
            if (!runButton) {
                setTimeout(initializeApp, 100);
                return;
            }
        const plotsDiv = document.getElementById('plots');

        function setStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
        }

        function getParameters() {
            return {
                agreement_year: parseFloat(document.getElementById('agreement_year').value),
                end_year: parseFloat(document.getElementById('end_year').value),
                increment: parseFloat(document.getElementById('increment').value),
                num_simulations: parseInt(document.getElementById('num_simulations').value),
                // Initial PRC compute stock parameters
                total_prc_compute_stock_in_2025: parseFloat(document.getElementById('total_prc_compute_stock_in_2025').value) * 1e6,
                annual_growth_rate_of_prc_compute_stock: parseFloat(document.getElementById('annual_growth_rate_of_prc_compute_stock').value),
                relative_sigma_of_prc_compute_stock: parseFloat(document.getElementById('relative_sigma_of_prc_compute_stock').value),
                us_intelligence_median_error_in_estimate_of_prc_compute_stock: parseFloat(document.getElementById('us_intelligence_median_error_in_estimate_of_prc_compute_stock').value),
                energy_efficiency_relative_to_h100: parseFloat(document.getElementById('energy_efficiency_relative_to_h100').value),
                run_covert_project: document.getElementById('run_covert_project').checked,
                proportion_of_initial_chip_stock_to_divert: parseFloat(document.getElementById('proportion_of_initial_chip_stock_to_divert').value),
                GW_per_initial_datacenter: parseFloat(document.getElementById('GW_per_initial_datacenter').value),
                number_of_initial_datacenters: parseFloat(document.getElementById('number_of_initial_datacenters').value),
                datacenter_construction_labor: parseInt(document.getElementById('datacenter_construction_labor').value),
                build_covert_fab: document.getElementById('build_covert_fab').checked,
                operating_labor: parseInt(document.getElementById('operating_labor').value),
                construction_labor: parseInt(document.getElementById('construction_labor').value),
                process_node: document.getElementById('process_node').value,
                scanner_proportion: parseFloat(document.getElementById('scanner_proportion').value),
                p_fab_exists: parseFloat(document.getElementById('p_fab_exists').value),
                // Detection parameters
                median_absolute_relative_error_of_us_intelligence_estimate_of_prc_sme_stock: parseFloat(document.getElementById('proportion_diverted_sme').value),
                mean_detection_time_for_100_workers: parseFloat(document.getElementById('mean_detection_time_100').value),
                mean_detection_time_for_1000_workers: parseFloat(document.getElementById('mean_detection_time_1000').value),
                variance_of_detection_time_given_num_workers: parseFloat(document.getElementById('variance_detection_time').value),
                // Production capacity
                wafers_per_month_per_worker: parseFloat(document.getElementById('wafers_per_month_per_worker').value),
                labor_productivity_relative_sigma: parseFloat(document.getElementById('labor_productivity_sigma').value),
                wafers_per_month_per_lithography_scanner: parseFloat(document.getElementById('wafers_per_month_per_scanner').value),
                scanner_productivity_relative_sigma: parseFloat(document.getElementById('scanner_productivity_sigma').value),
                // Construction time
                construction_time_for_5k_wafers_per_month: parseFloat(document.getElementById('construction_time_5k').value),
                construction_time_for_100k_wafers_per_month: parseFloat(document.getElementById('construction_time_100k').value),
                construction_time_relative_sigma: parseFloat(document.getElementById('construction_time_sigma').value),
                construction_workers_per_1000_wafers_per_month: parseFloat(document.getElementById('construction_workers_per_1000').value),
                // Chip production
                h100_sized_chips_per_wafer: parseFloat(document.getElementById('chips_per_wafer').value),
                transistor_density_scaling_exponent: parseFloat(document.getElementById('transistor_density_exponent').value),
                architecture_efficiency_improvement_per_year: parseFloat(document.getElementById('architecture_efficiency').value),
                // H100 reference specifications
                h100_transistor_density_m_per_mm2: 98.28,
                h100_power_watts: parseFloat(document.getElementById('h100_power_watts').value),
                h100_watts_per_tpp: parseFloat(document.getElementById('h100_power_watts').value) / 2144.0,
                // Energy efficiency scaling parameters
                watts_per_tpp_vs_transistor_density_exponent_before_dennard_scaling_ended: parseFloat(document.getElementById('watts_per_tpp_exponent_before_dennard').value),
                watts_per_tpp_vs_transistor_density_exponent_after_dennard_scaling_ended: parseFloat(document.getElementById('watts_per_tpp_exponent_after_dennard').value),
                transistor_density_at_end_of_dennard_scaling_m_per_mm2: parseFloat(document.getElementById('transistor_density_at_dennard_end').value),
                // PRC scanner production
                prc_lithography_scanners_produced_in_first_year: parseFloat(document.getElementById('prc_scanners_first_year').value),
                prc_additional_lithography_scanners_produced_per_year: parseFloat(document.getElementById('prc_scanners_per_year').value),
                prc_scanner_production_relative_sigma: parseFloat(document.getElementById('prc_scanner_production_sigma').value),
                // Localization probabilities
                localization_130nm_2025: parseFloat(document.getElementById('localization_130nm_2025').value),
                localization_130nm_2031: parseFloat(document.getElementById('localization_130nm_2031').value),
                localization_28nm_2025: parseFloat(document.getElementById('localization_28nm_2025').value),
                localization_28nm_2031: parseFloat(document.getElementById('localization_28nm_2031').value),
                localization_14nm_2025: parseFloat(document.getElementById('localization_14nm_2025').value),
                localization_14nm_2031: parseFloat(document.getElementById('localization_14nm_2031').value),
                localization_7nm_2025: parseFloat(document.getElementById('localization_7nm_2025').value),
                localization_7nm_2031: parseFloat(document.getElementById('localization_7nm_2031').value),
                // Survival rate parameters
                initial_hazard_rate_p50: parseFloat(document.getElementById('initial_hazard_rate_p50').value),
                increase_of_hazard_rate_per_year_p50: parseFloat(document.getElementById('increase_of_hazard_rate_per_year_p50').value),
                hazard_rate_p25_relative_to_p50: parseFloat(document.getElementById('hazard_rate_p25_relative_to_p50').value),
                hazard_rate_p75_relative_to_p50: parseFloat(document.getElementById('hazard_rate_p75_relative_to_p50').value),
                // Covert datacenter parameters
                max_proportion_of_PRC_energy_consumption: parseFloat(document.getElementById('max_proportion_of_PRC_energy_consumption').value),
                total_GW_of_PRC_energy_consumption: parseFloat(document.getElementById('total_GW_of_PRC_energy_consumption').value),
                construction_labor_per_MW_per_year: parseFloat(document.getElementById('construction_labor_per_MW_per_year').value),
                relative_sigma_construction_labor_per_MW_per_year: parseFloat(document.getElementById('relative_sigma_construction_labor_per_MW_per_year').value),
                operating_labor_per_MW: parseFloat(document.getElementById('operating_labor_per_MW').value),
                relative_sigma_operating_labor_per_MW: parseFloat(document.getElementById('relative_sigma_operating_labor_per_MW').value),
                mean_detection_time_of_covert_site_for_100_workers: parseFloat(document.getElementById('mean_detection_time_100').value),
                mean_detection_time_of_covert_site_for_1000_workers: parseFloat(document.getElementById('mean_detection_time_1000').value),
                variance_of_detection_time_given_num_workers: parseFloat(document.getElementById('variance_detection_time').value)
            };
        }

        function plotTimeSeries(data) {
            if (!data.dark_compute_model || !data.covert_fab) return;

            const dcm = data.dark_compute_model;
            const years = dcm.years;

            // Better color scheme
            const lrColor = '#5B8DBE'; // Muted blue
            const computeColor = '#9B7BB3'; // Purple

            // Create traces for individual simulations (show first 100 for performance)
            const individualsToShow = Math.min(100, data.covert_fab.lr_combined.individual ? data.covert_fab.lr_combined.individual.length : 0);

            const individualLRs = (data.covert_fab.lr_combined.individual || []).slice(0, individualsToShow).map((lrs, idx) => ({
                x: years,
                y: lrs,
                type: 'scatter',
                mode: 'lines',
                line: { color: lrColor, width: 0.8 },
                opacity: 0.08,
                showlegend: false,
                hoverinfo: 'skip'
            }));

            const individualH100e = (dcm.covert_fab_flow.individual || []).slice(0, individualsToShow).map((h100e, idx) => ({
                x: years,
                y: h100e,
                type: 'scatter',
                mode: 'lines',
                line: { color: computeColor, width: 0.8 },
                opacity: 0.08,
                showlegend: false,
                hoverinfo: 'skip',
                yaxis: 'y2'
            }));

            // Median and percentile traces
            const traces = [
                ...individualLRs,
                {
                    x: years,
                    y: data.covert_fab.lr_combined.p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip'
                },
                {
                    x: years,
                    y: data.covert_fab.lr_combined.p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: lrColor + '30',
                    line: { color: 'transparent' },
                    name: '25th-75th %ile (LR)',
                    hovertemplate: 'LR: %{y:.2f}<extra></extra>'
                },
                {
                    x: years,
                    y: data.covert_fab.lr_combined.median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: lrColor, width: 3 },
                    name: 'Median Evidence of Covert Fab',
                    hovertemplate: 'LR: %{y:.2f}<extra></extra>'
                },
                ...individualH100e,
                {
                    x: years,
                    y: dcm.covert_fab_flow.p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip',
                    yaxis: 'y2'
                },
                {
                    x: years,
                    y: dcm.covert_fab_flow.p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: computeColor + '60',
                    line: { color: 'transparent' },
                    name: '25th-75th %ile (H100e)',
                    yaxis: 'y2',
                    hovertemplate: 'H100e: %{y:,.0f}<extra></extra>'
                },
                {
                    x: years,
                    y: dcm.covert_fab_flow.median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: computeColor, width: 3 },
                    name: 'Median H100e',
                    yaxis: 'y2',
                    hovertemplate: 'H100e: %{y:,.0f}<extra></extra>'
                }
            ];

            // Calculate max value from 75th percentile for y-axis range
            const maxP75 = Math.max(...dcm.covert_fab_flow.p75);
            const yAxisMax = maxP75 * 1.5;

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 13 },
                    automargin: true
                },
                yaxis: {
                    title: 'Evidence of Covert Fab (Likelihood Ratio)',
                    titlefont: { size: 13, color: '#000' },
                    tickfont: { size: 10, color: lrColor },
                    type: 'log',
                    side: 'left',
                    automargin: true
                },
                yaxis2: {
                    title: 'H100e Produced by Fab',
                    titlefont: { size: 13, color: '#000' },
                    tickfont: { size: 10, color: computeColor },
                    overlaying: 'y',
                    side: 'right',
                    automargin: true,
                    tickformat: '.2s',
                    range: [0, yAxisMax]
                },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: -0.25,
                    xanchor: 'left',
                    yanchor: 'top',
                    orientation: 'h',
                    font: { size: 10 }
                },
                hovermode: 'x unified',
                margin: { l: 50, r: 10, t: 10, b: 85, pad: 10 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('timeSeriesPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('timeSeriesPlot'), 50);
        }

        function plotDatacenterCapacity(data) {
            if (!data.dark_compute_model || !data.dark_compute_model.datacenter_capacity) return;

            const dcm = data.dark_compute_model;
            const years = dcm.years;

            // Colors
            const datacenterColor = '#5AA89B'; // Turquoise for capacity

            // Create traces - just the median lines without confidence intervals
            const traces = [
                // Capacity
                {
                    x: years,
                    y: dcm.datacenter_capacity.median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: datacenterColor, width: 3 },
                    name: 'Capacity',
                    hovertemplate: 'Capacity: %{y:.1f} GW<extra></extra>'
                }
            ];

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 13 },
                    automargin: true
                },
                yaxis: {
                    title: 'Covert Datacenter Capacity (GW)',
                    titlefont: { size: 13, color: 'black' },
                    tickfont: { size: 10, color: 'black' },
                    automargin: true
                },
                showlegend: false,
                hovermode: 'x unified',
                margin: { l: 50, r: 20, t: 10, b: 85, pad: 10 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('datacenterCapacityPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('datacenterCapacityPlot'), 50);
        }

        function plotDatacenterLR(data) {
            if (!data.covert_datacenters || !data.covert_datacenters.lr_datacenters) return;

            const cd = data.covert_datacenters;
            const years = cd.years;

            // Color for LR
            const lrColor = '#5B8DBE'; // Blue for likelihood ratio

            // Create traces with shaded percentile band
            const traces = [
                // 25th percentile (invisible, used for fill)
                {
                    x: years,
                    y: cd.lr_datacenters.p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip'
                },
                // 75th percentile (fills to previous trace)
                {
                    x: years,
                    y: cd.lr_datacenters.p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: lrColor + '30',
                    line: { color: 'transparent' },
                    name: '25th-75th %ile',
                    hovertemplate: 'LR: %{y:.2f}<extra></extra>'
                },
                // Median line
                {
                    x: years,
                    y: cd.lr_datacenters.median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: lrColor, width: 3 },
                    name: 'Median LR',
                    hovertemplate: 'LR: %{y:.2f}<extra></extra>'
                }
            ];

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 13 },
                    automargin: true
                },
                yaxis: {
                    title: 'Likelihood Ratio',
                    titlefont: { size: 13, color: 'black' },
                    tickfont: { size: 10, color: 'black' },
                    automargin: true,
                    type: 'log'
                },
                showlegend: false,
                hovermode: 'x unified',
                margin: { l: 50, r: 20, t: 10, b: 85, pad: 10 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('datacenterLRPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('datacenterLRPlot'), 50);
        }

        function plotH100YearsTimeSeries(data) {
            if (!data.dark_compute_model) return;

            const dcm = data.dark_compute_model;
            const years = dcm.years;

            // Colors - use turquoise green for H100-years (like "other intelligence")
            const h100YearsColor = '#5AA89B'; // Turquoise green
            const lrColor = '#E57373'; // Red for likelihood ratio

            // Create traces - median lines with confidence intervals
            const traces = [
                // H100-years confidence interval
                {
                    x: years.concat(years.slice().reverse()),
                    y: dcm.h100_years.p75.concat(dcm.h100_years.p25.slice().reverse()),
                    fill: 'toself',
                    fillcolor: 'rgba(90, 168, 155, 0.2)',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip',
                    yaxis: 'y'
                },
                // H100-years median
                {
                    x: years,
                    y: dcm.h100_years.median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: h100YearsColor, width: 3 },
                    name: 'H100-Years',
                    yaxis: 'y',
                    hovertemplate: 'H100-Years: %{y:.1f}<extra></extra>'
                },
                // Cumulative LR confidence interval
                {
                    x: years.concat(years.slice().reverse()),
                    y: dcm.cumulative_lr.p75.concat(dcm.cumulative_lr.p25.slice().reverse()),
                    fill: 'toself',
                    fillcolor: 'rgba(229, 115, 115, 0.2)',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip',
                    yaxis: 'y2'
                },
                // LR median
                {
                    x: years,
                    y: dcm.cumulative_lr.median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: lrColor, width: 3 },
                    name: 'Likelihood Ratio',
                    yaxis: 'y2',
                    hovertemplate: 'LR: %{y:.2f}<extra></extra>'
                }
            ];

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 13 },
                    automargin: true
                },
                yaxis: {
                    title: 'H100-Years of Computation',
                    titlefont: { size: 13, color: h100YearsColor },
                    tickfont: { size: 10, color: h100YearsColor },
                    side: 'left',
                    automargin: true
                },
                yaxis2: {
                    title: 'Likelihood Ratio',
                    titlefont: { size: 13, color: lrColor },
                    tickfont: { size: 10, color: lrColor },
                    overlaying: 'y',
                    side: 'right',
                    type: 'log',
                    automargin: true
                },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: -0.25,
                    xanchor: 'left',
                    yanchor: 'top',
                    orientation: 'h',
                    font: { size: 10 }
                },
                hovermode: 'x unified',
                margin: { l: 50, r: 50, t: 10, b: 85, pad: 10 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('h100YearsTimeSeriesPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('h100YearsTimeSeriesPlot'), 50);
        }

        function plotComputeCcdf(data) {
            if (!data.covert_fab || !data.covert_fab.compute_ccdfs) {
                document.getElementById('computeCcdfPlot').innerHTML = '<p>No detection data available</p>';
                return;
            }

            // Get prior probability from the input
            const priorProb = parseFloat(document.getElementById('p_fab_exists').value) || 0.1;
            const priorOdds = priorProb / (1 - priorProb);

            // Use likelihood ratios from backend
            const likelihoodRatios = data.likelihood_ratios || [1, 2, 5];
            const colors = ['#9B7BB3', '#5B8DBE', '#5AA89B'];  // Purple, Blue, Blue-green

            const traces = [];
            const thresholds = likelihoodRatios.map((lr, index) => {
                const posteriorOdds = priorOdds * lr;
                const posteriorProb = posteriorOdds / (1 + posteriorOdds);
                return {
                    value: posteriorProb,
                    label: `>${lr}x update`,
                    color: colors[index % colors.length]
                };
            });

            // Reverse thresholds for legend order (highest to lowest)
            const thresholdsReversed = [...thresholds].reverse();

            for (const threshold of thresholdsReversed) {
                const ccdf = data.covert_fab.compute_ccdfs[threshold.value];
                if (ccdf && ccdf.length > 0) {
                    traces.push({
                        x: ccdf.map(d => d.x),
                        y: ccdf.map(d => d.y),
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: threshold.color, width: 2 },
                        name: `"Detection" = ${threshold.label}`,
                        hovertemplate: 'H100e: %{x:.0f}<br>P(≥x): %{y:.3f}<extra></extra>'
                    });
                }
            }

            const layout = {
                xaxis: {
                    title: "H100e Produced by Covert Fab Before 'Detection'",
                    titlefont: { size: 13 },
                    tickfont: { size: 10 },
                    type: 'log',
                    automargin: true
                },
                yaxis: {
                    title: 'P(covert compute > x)',
                    titlefont: { size: 13 },
                    tickfont: { size: 10 },
                    range: [0, 1],
                    automargin: true
                },
                showlegend: true,
                legend: {
                    x: 0.98,
                    y: 0.98,
                    xanchor: 'right',
                    yanchor: 'top',
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ccc',
                    borderwidth: 1
                },
                hovermode: 'closest',
                margin: { l: 50, r: 10, t: 10, b: 65, pad: 10 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('computeCcdfPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('computeCcdfPlot'), 50);
        }

        function plotProjectH100YearsCcdf(data) {
            if (!data.dark_compute_model || !data.dark_compute_model.h100_years_ccdf) {
                document.getElementById('projectH100YearsCcdfPlot').innerHTML = '<p>No detection data available</p>';
                return;
            }

            // Get prior probability from the data
            const priorProb = data.p_project_exists || 0.1;
            const priorOdds = priorProb / (1 - priorProb);

            // Use likelihood ratios from backend
            const likelihoodRatios = data.likelihood_ratios || [1, 2, 5];
            const colors = ['#9B7BB3', '#5B8DBE', '#5AA89B'];  // Purple, Blue, Blue-green

            const traces = [];
            const thresholds = likelihoodRatios.map((lr, index) => {
                const posteriorOdds = priorOdds * lr;
                const posteriorProb = posteriorOdds / (1 + posteriorOdds);
                return {
                    value: posteriorProb,
                    label: `>${lr}x update`,
                    color: colors[index % colors.length]
                };
            });

            console.log('Project H100-Years CCDF Debug:');
            console.log('priorProb:', priorProb);
            console.log('likelihoodRatios:', likelihoodRatios);
            console.log('thresholds:', thresholds);
            console.log('CCDF data keys:', Object.keys(data.dark_compute_model.h100_years_ccdf));
            console.log('CCDF data:', data.dark_compute_model.h100_years_ccdf);

            // Reverse thresholds for legend order (highest to lowest)
            const thresholdsReversed = [...thresholds].reverse();

            for (const threshold of thresholdsReversed) {
                const ccdf = data.dark_compute_model.h100_years_ccdf[threshold.value];
                if (ccdf && ccdf.length > 0) {
                    traces.push({
                        x: ccdf.map(d => d.x),
                        y: ccdf.map(d => d.y),
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: threshold.color, width: 2 },
                        name: `"Detection" = ${threshold.label}`,
                        hovertemplate: 'H100-years: %{x:.0f}<br>P(≥x): %{y:.3f}<extra></extra>'
                    });
                }
            }

            const layout = {
                xaxis: {
                    title: "H100-Years Before 'Detection'",
                    titlefont: { size: 13 },
                    tickfont: { size: 10 },
                    type: 'log',
                    automargin: true
                },
                yaxis: {
                    title: 'P(H100-years > x)',
                    titlefont: { size: 13 },
                    tickfont: { size: 10 },
                    range: [0, 1],
                    automargin: true
                },
                showlegend: true,
                legend: {
                    x: 0.98,
                    y: 0.98,
                    xanchor: 'right',
                    yanchor: 'top',
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ccc',
                    borderwidth: 1
                },
                hovermode: 'closest',
                margin: { l: 50, r: 50, t: 10, b: 65, pad: 10 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('projectH100YearsCcdfPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('projectH100YearsCcdfPlot'), 50);
        }

        function plotPDF(divId, values, color, xAxisLabel, nbins = 30, logScale = false, logMin = null, logMax = null, title = null, pattern = null) {
            // Create histogram/PDF from values
            console.log(`plotPDF called for ${divId}:`, values);
            console.log(`plotPDF ${divId} - min: ${Math.min(...values)}, max: ${Math.max(...values)}, count: ${values.length}`);

            const marker = { color: color, line: { width: 0.5, color: 'white' } };

            // Add pattern if specified
            if (pattern) {
                marker.pattern = pattern;
            }

            const trace = {
                x: values,
                type: 'histogram',
                histnorm: 'probability density',
                marker: marker,
                hovertemplate: '%{x:.2f}<br>Density: %{y:.3f}<extra></extra>'
            };

            // For log scale, manually specify bin edges
            if (logScale) {
                // Use custom range if provided, otherwise default to 0.1 to 10
                const minVal = logMin !== null ? logMin : 0.1;
                const maxVal = logMax !== null ? logMax : 10;
                const numBins = 12;
                const logMinVal = Math.log10(minVal);
                const logMaxVal = Math.log10(maxVal);
                const binEdges = [];
                for (let i = 0; i <= numBins; i++) {
                    binEdges.push(Math.pow(10, logMinVal + i * (logMaxVal - logMinVal) / numBins));
                }

                // Manually bin the data
                const binCounts = new Array(binEdges.length - 1).fill(0);
                values.forEach(v => {
                    // Find which bin this value belongs to
                    let binned = false;
                    for (let i = 0; i < binEdges.length - 2; i++) {
                        if (v >= binEdges[i] && v < binEdges[i + 1]) {
                            binCounts[i]++;
                            binned = true;
                            break;
                        }
                    }
                    // Last bin captures all values >= second-to-last edge (making it a "+" bin)
                    if (!binned) {
                        binCounts[binCounts.length - 1]++;
                    }
                });

                // Calculate bin centers for plotting
                const binCenters = [];
                for (let i = 0; i < binEdges.length - 1; i++) {
                    binCenters.push((binEdges[i] + binEdges[i + 1]) / 2);
                }

                // Calculate probability mass (count / total) for better visualization with open-ended bins
                // Using probability instead of density makes the bar height proportional to the actual probability mass
                const probabilities = binCounts.map(count => count / values.length);

                console.log(`Bin edges: ${binEdges}`);
                console.log(`Bin counts: ${binCounts}`);
                console.log(`Probabilities: ${probabilities}`);

                // Create bar trace instead of histogram
                trace.type = 'bar';
                trace.x = binCenters;
                trace.y = probabilities;
                delete trace.histnorm;
                trace.width = binEdges.map((edge, i) => i < binEdges.length - 1 ? binEdges[i + 1] - binEdges[i] : 0).slice(0, -1);
                trace.hovertemplate = 'LR: %{x:.2f}<br>Probability: %{y:.3f}<extra></extra>';
            } else {
                trace.nbinsx = nbins;
            }

            const xaxisConfig = {
                title: xAxisLabel,
                titlefont: { size: 10 },
                automargin: true,
                tickfont: { size: 9 }
            };

            const yaxisConfig = {
                title: logScale ? 'Probability' : 'Density',
                titlefont: { size: 10 },
                tickfont: { size: 9 }
            };

            if (logScale) {
                xaxisConfig.type = 'log';
                // Manually specify tick values for better visibility
                // Use the actual max value from logMax parameter
                const maxTickVal = logMax !== null ? logMax : 10;
                const maxTickText = maxTickVal.toString() + '+';
                xaxisConfig.tickvals = [0.1, 0.2, 0.5, 1, 2, maxTickVal];
                xaxisConfig.ticktext = ['0.1', '0.2', '0.5', '1', '2', maxTickText];
                // Don't force range - let it adjust based on data
                xaxisConfig.autorange = true;
            }

            const layout = {
                xaxis: xaxisConfig,
                yaxis: {
                    ...yaxisConfig,
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 10, t: title ? 30 : 10, b: 55, pad: 10 },
                hovermode: 'closest'
            };

            if (title) {
                layout.title = {
                    text: `<b>${title}</b>`,
                    font: { size: 12 },
                    x: 0.5,
                    xanchor: 'center'
                };
            }

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotMedianWithPercentiles(divId, data, years, color, yAxisLabel = '', yAxisRange = null, logScale = false, showLegend = false) {
            // Plot median with 25th-75th percentile bands
            const traces = [];

            // Add individual simulation lines if provided
            if (data.individual) {
                const individualsToPlot = data.individual.slice(0, 100);
                for (let i = 0; i < individualsToPlot.length; i++) {
                    traces.push({
                        x: years,
                        y: individualsToPlot[i],
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: color, width: 0.5 },
                        opacity: 0.15,
                        showlegend: false,
                        hoverinfo: 'skip'
                    });
                }
            }

            // Add percentile bands
            traces.push(
                {
                    x: years,
                    y: data.p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: color, width: 1.5, dash: 'dot' },
                    opacity: 0.6,
                    showlegend: false,
                    hoverinfo: 'skip',
                    name: '25th percentile'
                },
                {
                    x: years,
                    y: data.p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: color + '60',
                    line: { color: color, width: 1.5, dash: 'dot' },
                    opacity: 0.7,
                    showlegend: showLegend,
                    hoverinfo: 'skip',
                    name: '25th-75th %ile'
                },
                {
                    x: years,
                    y: data.median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: color, width: 3 },
                    showlegend: showLegend,
                    hovertemplate: 'Year: %{x:.1f}<br>Value: %{y:.2f}<extra></extra>',
                    name: 'Median'
                }
            );

            const yaxisConfig = {
                title: yAxisLabel,
                titlefont: { size: 10 },
                tickfont: { size: 9 },
                automargin: true
            };

            // Add log scale if specified
            if (logScale) {
                yaxisConfig.type = 'log';
            }

            // Add range if specified
            if (yAxisRange !== null) {
                yaxisConfig.range = yAxisRange;
            }

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    range: [years[0] - 0.1, years[years.length - 1] + 0.1],
                    autorange: false,
                    fixedrange: true
                },
                yaxis: yaxisConfig,
                showlegend: showLegend,
                legend: {
                    x: 0.98,
                    y: 0.98,
                    xanchor: 'right',
                    yanchor: 'top',
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ccc',
                    borderwidth: 1,
                    font: { size: 10 }
                },
                margin: { l: 50, r: 10, t: 10, b: 55, pad: 10 },
                hovermode: 'x'
            };

            Plotly.newPlot(divId, traces, layout, {displayModeBar: false, responsive: true});
            // Force resize after a small delay
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotBarByProcessNode(divId, values, processNodes, color) {
            // Group by process node and compute per wafer value
            const nodeValueCounts = {};
            values.forEach((v, idx) => {
                const rounded = Math.round(v * 1000) / 1000; // Round to 3 decimal places
                const node = processNodes[idx];
                const key = `${rounded}|${node}`;
                nodeValueCounts[key] = (nodeValueCounts[key] || 0) + 1;
            });

            // Parse and sort by value
            const entries = Object.entries(nodeValueCounts).map(([key, count]) => {
                const [value, node] = key.split('|');
                return { value: parseFloat(value), node, count };
            });
            entries.sort((a, b) => a.value - b.value);

            // Convert counts to proportions
            const totalCount = values.length;
            const labels = entries.map(e => `${e.value.toFixed(2)}x (${e.node})`);
            const proportions = entries.map(e => e.count / totalCount);

            const trace = {
                x: labels,
                y: proportions,
                type: 'bar',
                marker: {
                    color: color,
                    line: { width: 1, color: 'white' }
                },
                textposition: 'auto',
                hovertemplate: '%{x}<br>Probability: %{y:.3f}<extra></extra>'
            };

            const layout = {
                xaxis: {
                    title: '',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    type: 'category'
                },
                yaxis: {
                    title: 'Probability',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 10, t: 10, b: 65, pad: 10 },
                hovermode: 'closest',
                bargap: 0.2
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotProportionOperational(divId, data, years, color, yAxisLabel = '') {
            // Use the proportion directly (proportion of simulations where fab is operational)
            const proportions = data.proportion;

            const trace = {
                x: years,
                y: proportions,
                type: 'scatter',
                mode: 'lines',
                line: { color: color, width: 2 },
                fill: 'tozeroy',
                fillcolor: color + '20',
                hovertemplate: 'Year: %{x:.1f}<br>Proportion: %{y:.2f}<extra></extra>'
            };

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    range: [years[0] - 0.1, years[years.length - 1] + 0.1],
                    autorange: false,
                    fixedrange: true
                },
                yaxis: {
                    title: yAxisLabel,
                    range: [0, 1],
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 10, t: 10, b: 55, pad: 10 },
                hovermode: 'x'
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            // Force resize after a small delay
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotCategoricalFrequency(divId, values, categories, color) {
            // Count frequencies for each category
            const frequencies = categories.map(cat =>
                values.filter(v => v === cat.value).length
            );

            // Convert to proportions
            const total = values.length;
            const proportions = frequencies.map(f => f / total);

            const trace = {
                x: categories.map(cat => cat.label),
                y: proportions,
                type: 'bar',
                marker: {
                    color: color,
                    line: { width: 1, color: 'white' }
                },
                textposition: 'auto',
                hovertemplate: '%{x}<br>Probability: %{y:.3f}<extra></extra>'
            };

            const layout = {
                xaxis: {
                    title: '',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    type: 'category'
                },
                yaxis: {
                    title: 'Probability',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 10, t: 10, b: 65, pad: 10 },
                hovermode: 'closest',
                bargap: 0.2
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function updateDashboard(data) {
            // Find the median simulation by H100e production
            const h100eValues = data.individual_h100e_before_detection || [];
            const timeValues = data.individual_time_before_detection || [];
            const nodeValues = data.individual_process_node || [];
            const energyValues = data.individual_energy_before_detection || [];

            if (h100eValues.length > 0) {
                // Sort by H100e and find median simulation
                const indexed = h100eValues.map((h100e, idx) => ({ h100e, idx }));
                indexed.sort((a, b) => a.h100e - b.h100e);
                const idx50 = Math.floor(indexed.length * 0.5);
                const sim80th = indexed[idx50];

                // Get all values from this same simulation
                const h100e80th = sim80th.h100e;
                const time80th = timeValues[sim80th.idx];
                const node80th = nodeValues[sim80th.idx];
                const energy80th = energyValues[sim80th.idx];

                // Display H100e and energy combined
                const rounded = Math.round(h100e80th / 100000) * 100000;
                let h100eText;
                if (rounded >= 1000000) {
                    h100eText = `${(rounded / 1000000).toFixed(1)}M H100e`;
                } else if (rounded >= 1000) {
                    h100eText = `${(rounded / 1000).toFixed(0)}K H100e`;
                } else {
                    h100eText = `${rounded.toFixed(0)} H100e`;
                }

                let energyText;
                if (energy80th >= 1) {
                    energyText = `${energy80th.toFixed(1)} GW`;
                } else if (energy80th >= 0.001) {
                    energyText = `${(energy80th * 1000).toFixed(0)} MW`;
                } else {
                    energyText = `${(energy80th * 1000).toFixed(1)} MW`;
                }

                document.getElementById('dashboard80thCombined').innerHTML =
                    `${h100eText}<br><span style="font-size: 24px; color: #666;">${energyText}</span>`;

                // Display time
                document.getElementById('dashboard80thTime').textContent = time80th.toFixed(1);

                // Display process node
                document.getElementById('dashboard80thNode').textContent = node80th;

                // Display probability of fab being built
                const probFabBuilt = data.prob_fab_built !== undefined ? (data.prob_fab_built * 100).toFixed(1) + '%' : '--';
                document.getElementById('dashboardProbFabBuilt').textContent = probFabBuilt;

                // Update detection label with highest LR value
                const likelihoodRatios = data.likelihood_ratios || [1, 3, 5];
                const highestLR = likelihoodRatios[likelihoodRatios.length - 1];
                document.getElementById('dashboardDetectionLabel').textContent =
                    `Detection means ≥${highestLR}x update`;
            }

            // Populate dark compute project dashboard
            const projectH100eValues = data.individual_project_h100e_before_detection || [];
            const projectEnergyValues = data.individual_project_energy_before_detection || [];
            const projectTimeValues = data.individual_project_time_before_detection || [];
            const projectH100YearsValues = data.individual_project_h100_years_before_detection || [];

            if (projectH100eValues.length > 0) {
                // Sort by H100-years and find 80th percentile simulation
                const projectIndexed = projectH100YearsValues.map((h100years, idx) => ({ h100years, idx }));
                projectIndexed.sort((a, b) => a.h100years - b.h100years);
                const projectIdx80 = Math.floor(projectIndexed.length * 0.8);
                const projectSim80th = projectIndexed[projectIdx80];

                // Get all values from this same simulation
                const projectH100Years80th = projectSim80th.h100years;
                const projectH100e80th = projectH100eValues[projectSim80th.idx];
                const projectEnergy80th = projectEnergyValues[projectSim80th.idx];
                const projectTime80th = projectTimeValues[projectSim80th.idx];

                // Display H100-years
                const h100YearsRounded = Math.round(projectH100Years80th / 100000) * 100000;
                if (h100YearsRounded >= 1000000) {
                    document.getElementById('dashboardProject80thH100Years').textContent =
                        `~${(h100YearsRounded / 1000000).toFixed(1)}M H100-years`;
                } else if (h100YearsRounded >= 1000) {
                    document.getElementById('dashboardProject80thH100Years').textContent =
                        `~${(h100YearsRounded / 1000).toFixed(0)}K H100-years`;
                } else {
                    document.getElementById('dashboardProject80thH100Years').textContent =
                        `~${h100YearsRounded.toFixed(0)} H100-years`;
                }

                // Display H100e and energy combined
                const projectRounded = Math.round(projectH100e80th / 100000) * 100000;
                let projectH100eText;
                if (projectRounded >= 1000000) {
                    projectH100eText = `${(projectRounded / 1000000).toFixed(1)}M H100e`;
                } else if (projectRounded >= 1000) {
                    projectH100eText = `${(projectRounded / 1000).toFixed(0)}K H100e`;
                } else {
                    projectH100eText = `${projectRounded.toFixed(0)} H100e`;
                }

                let projectEnergyText;
                if (projectEnergy80th >= 1) {
                    projectEnergyText = `${projectEnergy80th.toFixed(1)} GW`;
                } else if (projectEnergy80th >= 0.001) {
                    projectEnergyText = `${(projectEnergy80th * 1000).toFixed(0)} MW`;
                } else {
                    projectEnergyText = `${(projectEnergy80th * 1000).toFixed(1)} MW`;
                }

                document.getElementById('dashboardProject80thH100eCombined').innerHTML =
                    `${projectH100eText}<br><span style="font-size: 24px; color: #666;">${projectEnergyText}</span>`;

                // Display time
                document.getElementById('dashboardProject80thTime').textContent = projectTime80th.toFixed(1);
            }
        }

        async function runSimulation() {
            runButton.disabled = true;
            loadingDiv.classList.add('active');
            plotsDiv.style.display = 'none';
            setStatus('Running simulation...', 'info');

            try {
                const params = getParameters();
                const response = await fetch('/run_simulation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    throw new Error('Simulation failed');
                }

                const data = await response.json();

                // Log data structure for debugging
                console.log('=== SIMULATION DATA RECEIVED ===');
                console.log('Top-level keys:', Object.keys(data));
                console.log('Full data structure:', data);
                console.log('==============================');

                if (data.error) {
                    throw new Error(data.error);
                }

                // Update dashboard
                updateDashboard(data);

                // Plot dark compute equation section
                console.log('Plotting dark compute equation section...');

                // Plot 1: Initial dark compute (histogram)
                if (data.initial_stock && data.initial_stock.initial_compute_stock_samples) {
                    // Convert to thousands
                    const samplesInThousands = data.initial_stock.initial_compute_stock_samples.map(v => v / 1000);
                    plotPDF('initialDarkComputePlot', samplesInThousands, '#9B72B0', 'Thousands of H100 Equivalents');
                }

                // Plot 2: Flow from covert fab (line plot - cumulative production over time)
                if (data.dark_compute_model && data.dark_compute_model.years) {
                    const years = data.dark_compute_model.years;
                    const h100e_median = data.dark_compute_model.h100_years.median;
                    const h100e_p25 = data.dark_compute_model.h100_years.p25;
                    const h100e_p75 = data.dark_compute_model.h100_years.p75;

                    // Create traces for the shaded region and median line
                    const traces = [
                        // Upper bound of shaded region (invisible line)
                        {
                            x: years,
                            y: h100e_p75,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Lower bound with fill to previous trace
                        {
                            x: years,
                            y: h100e_p25,
                            type: 'scatter',
                            mode: 'lines',
                            fill: 'tonexty',
                            fillcolor: 'rgba(187, 143, 206, 0.2)',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Median line
                        {
                            x: years,
                            y: h100e_median,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: '#8E44AD', width: 2 },
                            name: 'Covert Fab Production',
                            showlegend: true
                        }
                    ];

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            range: [years[0], 2037]
                        },
                        yaxis: {
                            title: 'H100e (thousands)',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 }
                        },
                        margin: { l: 50, r: 20, t: 35, b: 40 },
                        height: 250,
                        hovermode: 'x unified',
                        legend: {
                            x: 0.5,
                            y: 1.0,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            orientation: 'h',
                            font: { size: 10 }
                        },
                        showlegend: true
                    };

                    Plotly.newPlot('covertFabFlowPlot', traces, layout, {responsive: true});
                }

                // Plot 3: Average compute survival rate
                if (data.dark_compute_model && data.dark_compute_model.survival_rate) {
                    const years = data.dark_compute_model.years;
                    const survival_rate_median = data.dark_compute_model.survival_rate.median;
                    const survival_rate_p25 = data.dark_compute_model.survival_rate.p25;
                    const survival_rate_p75 = data.dark_compute_model.survival_rate.p75;

                    const traces = [
                        // Upper bound of shaded region (invisible line)
                        {
                            x: years,
                            y: survival_rate_p75,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Lower bound with fill to previous trace
                        {
                            x: years,
                            y: survival_rate_p25,
                            type: 'scatter',
                            mode: 'lines',
                            fill: 'tonexty',
                            fillcolor: 'rgba(231, 76, 60, 0.2)',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Median line
                        {
                            x: years,
                            y: survival_rate_median,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: '#E74C3C', width: 2 },
                            name: 'Median',
                            showlegend: false
                        }
                    ];

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            range: [years[0], 2037]
                        },
                        yaxis: {
                            title: 'Survival Rate',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            range: [0, 1]
                        },
                        margin: { l: 50, r: 20, t: 10, b: 40 },
                        height: 250,
                        hovermode: 'x unified'
                    };

                    Plotly.newPlot('chipSurvivalPlot', traces, layout, {responsive: true});
                }

                // Plot 4: Dark compute (surviving, not limited by capacity)
                if (data.dark_compute_model && data.dark_compute_model.total_dark_compute) {
                    const years = data.dark_compute_model.years;
                    const dark_compute_median = data.dark_compute_model.total_dark_compute.median;
                    const dark_compute_p25 = data.dark_compute_model.total_dark_compute.p25;
                    const dark_compute_p75 = data.dark_compute_model.total_dark_compute.p75;

                    const traces = [
                        // Upper bound of shaded region (invisible line)
                        {
                            x: years,
                            y: dark_compute_p75,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Lower bound with fill to previous trace
                        {
                            x: years,
                            y: dark_compute_p25,
                            type: 'scatter',
                            mode: 'lines',
                            fill: 'tonexty',
                            fillcolor: 'rgba(142, 68, 173, 0.2)',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Median line
                        {
                            x: years,
                            y: dark_compute_median,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: '#8E44AD', width: 2 },
                            name: 'Median',
                            showlegend: false
                        }
                    ];

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 }
                        },
                        yaxis: {
                            title: 'H100e (thousands)',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 }
                        },
                        margin: { l: 50, r: 20, t: 10, b: 40 },
                        height: 250,
                        hovermode: 'x unified'
                    };

                    layout.xaxis.range = [years[0], 2037];

                    Plotly.newPlot('totalDarkComputePlot', traces, layout, {responsive: true});
                }

                // Plot 5: Datacenter capacity (GW)
                if (data.dark_compute_model && data.dark_compute_model.datacenter_capacity) {
                    const years = data.dark_compute_model.years;
                    const capacity_median = data.dark_compute_model.datacenter_capacity.median;
                    const capacity_p25 = data.dark_compute_model.datacenter_capacity.p25;
                    const capacity_p75 = data.dark_compute_model.datacenter_capacity.p75;

                    const traces = [
                        // Upper bound of shaded region (invisible line)
                        {
                            x: years,
                            y: capacity_p75,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Lower bound with fill to previous trace
                        {
                            x: years,
                            y: capacity_p25,
                            type: 'scatter',
                            mode: 'lines',
                            fill: 'tonexty',
                            fillcolor: 'rgba(90, 168, 155, 0.2)',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Median line
                        {
                            x: years,
                            y: capacity_median,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: '#2D6B61', width: 3 },  // Dark turquoise
                            name: 'Median',
                            showlegend: false
                        }
                    ];

                    // Calculate Y-axis range (1.8x max value to match darkComputeEnergyPlot)
                    const allYValues = [...capacity_p75, ...capacity_median, ...capacity_p25];
                    const maxY = Math.max(...allYValues);
                    const yMax = maxY * 1.8;

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            automargin: true
                        },
                        yaxis: {
                            title: 'GW',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            automargin: true,
                            range: [0, yMax]
                        },
                        margin: { l: 50, r: 50, t: 10, b: 55, pad: 10 },
                        height: 250,
                        hovermode: 'x unified'
                    };

                    layout.xaxis.range = [years[0], 2037];

                    Plotly.newPlot('datacenterCapacityPlot2', traces, layout, {responsive: true, displayModeBar: false});
                    setTimeout(() => Plotly.Plots.resize('datacenterCapacityPlot2'), 50);
                }

                // Energy Consumption Stacked Area Plot (for median simulation)
                // Shows two sources: Initial Stock (bottom) and Fab-Produced (top)
                if (data.dark_compute_model && data.dark_compute_model.dark_compute_energy) {
                    const years = data.dark_compute_model.years;
                    const energyData = data.dark_compute_model.dark_compute_energy;
                    const sourceLabels = data.dark_compute_model.energy_source_labels;
                    const datacenterCapacity = data.dark_compute_model.datacenter_capacity.median;

                    // Two colors: turquoise shades for initial stock (bottom) and fab-produced (top)
                    const colors = ['#4A9B8E', '#74B3A8'];  // Dark turquoise, light turquoise

                    const traces = [];

                    // Calculate total energy (sum of both sources) at each time point
                    const totalEnergy = energyData.map(yearData => yearData[0] + yearData[1]);

                    // LAYER 1: Create stacked area traces for each source (bottom layer)
                    for (let i = 0; i < sourceLabels.length; i++) {
                        const energyAtSource = energyData.map(yearData => yearData[i]);
                        const sourceLabel = sourceLabels[i];

                        traces.push({
                            x: years,
                            y: energyAtSource,
                            type: 'scatter',
                            mode: 'lines',
                            stackgroup: 'energy',
                            fillcolor: colors[i],
                            line: { width: 0 },
                            name: sourceLabel,
                            hovertemplate: `${sourceLabel}<br>Energy: %{y:.2f} GW<extra></extra>`
                        });
                    }

                    // LAYER 2: Create hash pattern ONLY where total energy exceeds capacity
                    // For each time point, the unpowered region is: max(0, totalEnergy - capacity)
                    // We'll stack this on TOP of the capacity line
                    const unpoweredEnergy = years.map((year, i) =>
                        Math.max(0, totalEnergy[i] - datacenterCapacity[i])
                    );

                    // Create the hash region as a shape that sits above the capacity line
                    // It goes from capacity to (capacity + unpowered)
                    const hashX = [...years, ...years.slice().reverse()];
                    const hashYTop = years.map((year, i) => datacenterCapacity[i] + unpoweredEnergy[i]);
                    const hashY = [...hashYTop, ...datacenterCapacity.slice().reverse()];

                    traces.push({
                        x: hashX,
                        y: hashY,
                        type: 'scatter',
                        mode: 'none',
                        fill: 'toself',
                        fillcolor: 'rgba(0, 0, 0, 0)',
                        fillpattern: {
                            shape: '/',
                            fgcolor: 'rgba(100, 100, 100, 0.8)',
                            bgcolor: 'rgba(0, 0, 0, 0)',
                            size: 8,
                            solidity: 0.7
                        },
                        showlegend: false,
                        hoverinfo: 'skip',
                        line: { width: 0 }
                    });

                    // LAYER 3: Add datacenter capacity line on top (just a line, no hash)
                    traces.push({
                        x: years,
                        y: datacenterCapacity,
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: '#2D6B61', width: 3 },
                        name: 'Covert Datacenter Capacity',
                        hovertemplate: 'Capacity: %{y:.1f} GW<extra></extra>'
                    });

                    // Add legend entry for the hash pattern
                    traces.push({
                        x: [years[0], years[1]],
                        y: [null, null],
                        type: 'scatter',
                        mode: 'lines',
                        fill: 'tozeroy',
                        fillcolor: 'rgba(0, 0, 0, 0)',
                        fillpattern: {
                            shape: '/',
                            fgcolor: 'rgba(100, 100, 100, 0.8)',
                            bgcolor: 'rgba(0, 0, 0, 0)',
                            size: 8,
                            solidity: 0.7
                        },
                        line: { width: 0 },
                        name: 'Cannot be powered',
                        showlegend: true,
                        hoverinfo: 'skip'
                    });

                    // Datacenter capacity line already added above

                    // Calculate max y value to set range to 1.8x
                    const allYValues = [...totalEnergy, ...datacenterCapacity];
                    const maxY = Math.max(...allYValues);
                    const yMax = maxY * 1.8;

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            automargin: true
                        },
                        yaxis: {
                            title: 'Energy Usage',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            automargin: true,
                            range: [0, yMax]
                        },
                        margin: { l: 50, r: 50, t: 10, b: 55, pad: 10 },
                        height: 250,
                        hovermode: 'x unified',
                        showlegend: true,
                        legend: {
                            x: 0.02,
                            y: 0.98,
                            xanchor: 'left',
                            yanchor: 'top',
                            bgcolor: 'rgba(255,255,255,0.9)',
                            bordercolor: '#ccc',
                            borderwidth: 1,
                            font: { size: 7 }
                        },
                        autosize: true
                    };

                    layout.xaxis.range = [years[0], 2037];

                    Plotly.newPlot('darkComputeEnergyPlot', traces, layout, {responsive: true, displayModeBar: false});
                    setTimeout(() => Plotly.Plots.resize('darkComputeEnergyPlot'), 50);
                }

                // Plot 6: Operational dark compute (limited by capacity)
                if (data.dark_compute_model && data.dark_compute_model.operational_dark_compute) {
                    const years = data.dark_compute_model.years;
                    const operational_median = data.dark_compute_model.operational_dark_compute.median;
                    const operational_p25 = data.dark_compute_model.operational_dark_compute.p25;
                    const operational_p75 = data.dark_compute_model.operational_dark_compute.p75;

                    const traces = [
                        // Upper bound of shaded region (invisible line)
                        {
                            x: years,
                            y: operational_p75,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Lower bound with fill to previous trace
                        {
                            x: years,
                            y: operational_p25,
                            type: 'scatter',
                            mode: 'lines',
                            fill: 'tonexty',
                            fillcolor: 'rgba(90, 168, 155, 0.2)',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Median line
                        {
                            x: years,
                            y: operational_median,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: '#5AA89B', width: 2 },
                            name: 'Median',
                            showlegend: false
                        }
                    ];

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            automargin: true
                        },
                        yaxis: {
                            title: 'H100e (thousands)',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            automargin: true
                        },
                        margin: { l: 50, r: 50, t: 10, b: 55, pad: 10 },
                        height: 250,
                        hovermode: 'x unified'
                    };

                    layout.xaxis.range = [years[0], 2037];

                    Plotly.newPlot('operationalDarkComputePlot', traces, layout, {responsive: true, displayModeBar: false});
                    setTimeout(() => Plotly.Plots.resize('operationalDarkComputePlot'), 50);
                }

                // Plot detection probability bar chart and initial compute stock histogram
                if (data.initial_stock && data.initial_stock.initial_dark_compute_detection_probs && data.initial_stock.initial_compute_stock_samples) {
                    console.log('Plotting detection probability bar chart and initial compute stock...');

                    // Update dashboard with median values
                    const sortedDarkCompute = [...data.initial_stock.initial_compute_stock_samples].sort((a, b) => a - b);
                    const medianDarkCompute = sortedDarkCompute[Math.floor(sortedDarkCompute.length / 2)];

                    // Format H100e text
                    let h100eText;
                    const rounded = Math.round(medianDarkCompute / 100000) * 100000;
                    if (rounded >= 1000000) {
                        h100eText = `${(rounded / 1000000).toFixed(1)}M H100e`;
                    } else if (rounded >= 1000) {
                        h100eText = `${(rounded / 1000).toFixed(0)}K H100e`;
                    } else {
                        h100eText = `${rounded.toFixed(0)} H100e`;
                    }

                    // Calculate energy for this compute stock
                    const h100PowerWatts = parseFloat(document.getElementById('h100_power_watts').value);
                    const energyGW = (medianDarkCompute * h100PowerWatts) / 1e9; // Convert watts to GW

                    let energyText;
                    if (energyGW >= 1) {
                        energyText = `${energyGW.toFixed(1)} GW`;
                    } else if (energyGW >= 0.001) {
                        energyText = `${(energyGW * 1000).toFixed(0)} MW`;
                    } else {
                        energyText = `${(energyGW * 1000).toFixed(1)} MW`;
                    }

                    document.getElementById('dashboardMedianDarkComputeCombined').innerHTML =
                        `${h100eText}<br><span style="font-size: 24px; color: #666;">${energyText}</span>`;

                    // Display probability of detection (P(LR ≥ 5x))
                    if (data.initial_stock.initial_dark_compute_detection_probs && data.initial_stock.initial_dark_compute_detection_probs['5x'] !== undefined) {
                        const probDetection = data.initial_stock.initial_dark_compute_detection_probs['5x'];
                        document.getElementById('dashboardMedianLR').textContent = (probDetection * 100).toFixed(1) + '%';
                    }

                    // Bar chart for detection probabilities
                    const likelihoodRatios = data.likelihood_ratios || [1, 3, 5];
                    const colors = ['#9B7BB3', '#5B8DBE', '#5AA89B'];  // Purple, Blue, Blue-green
                    const detectionProbs = likelihoodRatios.map((lr, idx) => ({
                        lr: lr,
                        prob: data.initial_stock.initial_dark_compute_detection_probs[`${lr}x`] || 0,
                        color: colors[idx]
                    }));

                    const barTrace = {
                        x: detectionProbs.map(d => `Detection means<br>≥${d.lr}x LR`),
                        y: detectionProbs.map(d => d.prob),
                        type: 'bar',
                        marker: {
                            color: detectionProbs.map(d => d.color)
                        },
                        hovertemplate: 'P(LR ≥ %{x}): %{y:.2%}<extra></extra>'
                    };

                    const barLayout = {
                        xaxis: {
                            title: 'Probability of detection',
                            titlefont: { size: 11 },
                            tickfont: { size: 9 }
                        },
                        yaxis: {
                            title: 'P(Detection)',
                            titlefont: { size: 11 },
                            tickfont: { size: 10 },
                            range: [0, 1],
                            tickformat: '.0%'
                        },
                        showlegend: false,
                        margin: { l: 55, r: 10, t: 10, b: 70 },
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        plot_bgcolor: 'rgba(0,0,0,0)'
                    };

                    Plotly.newPlot('initialDarkComputeDetectionPlot', [barTrace], barLayout, {displayModeBar: false, responsive: true});

                    // Histogram for initial compute stock
                    plotPDF('initialComputeStockPlot', data.initial_stock.initial_compute_stock_samples, '#9B72B0', 'PRC Dark Compute Stock (H100e)', 30, false);
                } else {
                    console.log('No detection probability or compute stock data available');
                }

                // Plot LR breakdown histograms for initial compute reporting
                if (data.initial_stock && data.initial_stock.lr_prc_accounting_samples && data.initial_stock.lr_global_accounting_samples && data.initial_stock.lr_combined_samples) {
                    console.log('Plotting LR breakdown histograms...');
                    // Use log scale with range 1/3 to 5, and blue color #5B8DBE
                    plotPDF('lrPrcAccountingPlot', data.initial_stock.lr_prc_accounting_samples, '#5B8DBE', 'Likelihood Ratio from PRC Accounting', 12, true, 1/3, 5);
                    plotPDF('lrGlobalAccountingPlot', data.initial_stock.lr_global_accounting_samples, '#5B8DBE', 'Likelihood Ratio from Global Production Accounting', 12, true, 1/3, 5);
                    plotPDF('lrCombinedPlot', data.initial_stock.lr_combined_samples, '#5B8DBE', 'Combined LR', 12, true, 1/3, 5);
                } else {
                    console.log('No LR samples in data');
                }

                // Plot initial dark compute stock breakdown
                if (data.initial_stock && data.initial_stock.initial_prc_stock_samples && data.initial_stock.diversion_proportion && data.initial_stock.initial_compute_stock_samples) {
                    console.log('Plotting initial dark compute stock breakdown...');

                    // Plot initial PRC stock distribution - purple color #9B72B0
                    plotPDF('initialPrcStockPlot', data.initial_stock.initial_prc_stock_samples, '#9B72B0', 'Initial PRC Compute Stock (H100e)', 30, false);

                    // Display the diversion proportion
                    const diversionPercent = (data.initial_stock.diversion_proportion * 100).toFixed(0);
                    document.getElementById('diversionProportionDisplay').innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <div class="breakdown-box-inner">${diversionPercent}%</div>
                            <div class="breakdown-label">Proportion diverted<br>to covert project</div>
                        </div>`;

                    // Plot the resulting dark compute stock - purple color #9B72B0
                    plotPDF('darkComputeResultPlot', data.initial_stock.initial_compute_stock_samples, '#9B72B0', 'Dark Compute Stock (H100e)', 30, false);
                } else {
                    console.log('No initial dark compute stock breakdown data available');
                }

                // Plot main charts
                plotTimeSeries(data);
                plotH100YearsTimeSeries(data);
                plotComputeCcdf(data);
                plotDatacenterCapacity(data);
                plotDatacenterLR(data);
                plotProjectH100YearsCcdf(data);

                // Force resize after a brief delay to ensure plots fill containers
                setTimeout(() => {
                    Plotly.Plots.resize('initialDarkComputePlot');
                    Plotly.Plots.resize('covertFabFlowPlot');
                    Plotly.Plots.resize('chipSurvivalPlot');
                    Plotly.Plots.resize('totalDarkComputePlot');
                    Plotly.Plots.resize('initialDarkComputeDetectionPlot');
                    Plotly.Plots.resize('initialComputeStockPlot');
                    Plotly.Plots.resize('lrPrcAccountingPlot');
                    Plotly.Plots.resize('lrGlobalAccountingPlot');
                    Plotly.Plots.resize('lrCombinedPlot');
                    Plotly.Plots.resize('initialPrcStockPlot');
                    Plotly.Plots.resize('darkComputeResultPlot');
                    Plotly.Plots.resize('timeSeriesPlot');
                    Plotly.Plots.resize('h100YearsTimeSeriesPlot');
                    Plotly.Plots.resize('computeCcdfPlot');
                    Plotly.Plots.resize('lrInitialStockPlot');
                    Plotly.Plots.resize('lrDivertedSMEPlot');
                    Plotly.Plots.resize('lrOtherIntelPlot');
                    Plotly.Plots.resize('posteriorProbProjectPlot');
                }, 100);

                // Plot LR breakdown
                if (data.covert_fab && data.covert_fab.lr_inventory) {
                    const years = data.covert_fab.years;

                    // LR Inventory - PDF of values across simulations at final timestep
                    const lrInventoryFinal = data.covert_fab.lr_inventory.individual.map(sim => sim[sim.length - 1]);
                    console.log('LR Inventory values:', lrInventoryFinal);
                    console.log('LR Inventory length:', lrInventoryFinal.length);
                    console.log('LR Inventory min:', Math.min(...lrInventoryFinal), 'max:', Math.max(...lrInventoryFinal));
                    console.log('Values below 1:', lrInventoryFinal.filter(v => v < 1));
                    console.log('Values at or above 1:', lrInventoryFinal.filter(v => v >= 1));
                    // Use log scale x-axis but show actual LR values (not log values)
                    plotPDF('lrInventoryPlot', lrInventoryFinal, '#D97676', 'Likelihood Ratio', 10, true);

                    // LR Procurement - Categorical bar plot (1 or 10)
                    const lrProcurementFinal = data.covert_fab.lr_procurement.individual.map(sim => sim[sim.length - 1]);
                    plotCategoricalFrequency('lrProcurementPlot', lrProcurementFinal, [
                        { value: 1, label: 'Likelihood Ratio = 1<br>(>90% localization)' },
                        { value: 10, label: 'Likelihood Ratio = 10<br>(≤90% localization)' }
                    ], '#6B9BD1');

                    // LR Other - Median over time with percentiles
                    const lrOtherArray = data.covert_fab.lr_other.individual.map(sim => sim.map(v => v));
                    const lrOtherP25 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const lrOtherP75 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });
                    plotMedianWithPercentiles('lrOtherPlot', {
                        median: data.covert_fab.lr_other.median,
                        p25: lrOtherP25,
                        p75: lrOtherP75,
                        individual: data.covert_fab.lr_other.individual
                    }, years, '#5AA89B', 'Likelihood Ratio', null, true);

                    // Plot combined LR (product of inventory, procurement, and other intelligence)
                    plotMedianWithPercentiles('posteriorProbPlot', {
                        median: data.covert_fab.lr_combined.median,
                        p25: data.covert_fab.lr_combined.p25,
                        p75: data.covert_fab.lr_combined.p75,
                        individual: data.covert_fab.lr_combined.individual
                    }, data.covert_fab.years, '#5B8DBE', 'Likelihood Ratio', null, true);
                }

                // Plot "Strength of Evidence of Covert Project" section
                if (data.initial_stock && data.initial_stock.lr_combined_samples && data.dark_compute_model) {
                    console.log('Plotting Strength of Evidence of Covert Project section...');
                    const years = data.dark_compute_model.years;

                    // Get prior probability from parameters and calculate prior odds
                    const priorProb = getParameters().p_fab_exists;
                    const priorOddsProject = priorProb / (1 - priorProb);

                    // Display prior odds
                    document.getElementById('dashboardPriorProject').innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <div class="breakdown-box-inner">${priorOddsProject.toFixed(3)}</div>
                            <div class="breakdown-label">Prior Odds of<br>Covert Project</div>
                        </div>`;

                    // 1. LR from initial stock (Combined LR from PRC and global accounting)
                    // Use the same data as lrCombinedPlot
                    plotPDF('lrInitialStockPlot', data.initial_stock.lr_combined_samples, '#5B8DBE', 'Likelihood Ratio', 12, true, 1/3, 5);

                    // 2. LR from diverted SME (multiply inventory and procurement LRs)
                    const lrInventoryFinal = data.covert_fab.lr_inventory.individual.map(sim => sim[sim.length - 1]);
                    const lrProcurementFinal = data.covert_fab.lr_procurement.individual.map(sim => sim[sim.length - 1]);
                    const lrDivertedSME = lrInventoryFinal.map((inv, i) => inv * lrProcurementFinal[i]);
                    plotPDF('lrDivertedSMEPlot', lrDivertedSME, '#6B9BD1', 'Likelihood Ratio', 12, true, 1/3, 50);

                    // 3. LR from other intelligence sources (same as lrOtherPlot)
                    const lrOtherArray = data.covert_fab.lr_other.individual.map(sim => sim.map(v => v));
                    const lrOtherP25 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const lrOtherP75 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });
                    plotMedianWithPercentiles('lrOtherIntelPlot', {
                        median: data.covert_fab.lr_other.median,
                        p25: lrOtherP25,
                        p75: lrOtherP75,
                        individual: data.covert_fab.lr_other.individual
                    }, years, '#5AA89B', 'Likelihood Ratio', null, true);

                    // 4. Posterior probability of covert project
                    // Calculate: Prior × LR_initial × LR_SME × LR_other for each simulation at each timestep
                    const posteriorProbProject_individual = data.covert_fab.lr_other.individual.map((other_sim, sim_idx) => {
                        const lr_initial = data.initial_stock.lr_combined_samples[sim_idx];
                        const lr_sme = lrDivertedSME[sim_idx];

                        return other_sim.map((lr_other_t) => {
                            // Calculate posterior odds
                            const priorOdds = priorProb / (1 - priorProb);
                            const posteriorOdds = priorOdds * lr_initial * lr_sme * lr_other_t;
                            // Convert to probability
                            const posteriorProb = posteriorOdds / (1 + posteriorOdds);
                            return posteriorProb;
                        });
                    });

                    // Calculate median and percentiles
                    const posteriorProbProject_median = years.map((_, i) => {
                        const values = posteriorProbProject_individual.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.5)];
                    });
                    const posteriorProbProject_p25 = years.map((_, i) => {
                        const values = posteriorProbProject_individual.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const posteriorProbProject_p75 = years.map((_, i) => {
                        const values = posteriorProbProject_individual.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });

                    plotMedianWithPercentiles('posteriorProbProjectPlot', {
                        median: posteriorProbProject_median,
                        p25: posteriorProbProject_p25,
                        p75: posteriorProbProject_p75,
                        individual: posteriorProbProject_individual
                    }, years, '#5B8DBE', 'Posterior Probability');
                }

                // Plot compute breakdown
                if (data.covert_fab && data.covert_fab.is_operational) {
                    const years = data.covert_fab.years;

                    // Proportion Operational - time series showing proportion
                    plotProportionOperational('isOperationalPlot', {
                        proportion: data.covert_fab.is_operational.proportion
                    }, years, '#D4A574', 'Probability');

                    // Wafer Starts per Month - PDF
                    const waferStartsFinal = data.covert_fab.wafer_starts.individual.map(sim => sim[sim.length - 1]);
                    plotPDF('waferStartsPlot', waferStartsFinal, '#74B3A8', 'Wafers/Month');

                    // H100-sized Chips per Wafer - Display as a box (constant value)
                    const chipsPerWaferValue = data.covert_fab.chips_per_wafer.individual[0][0]; // Same for all sims
                    document.getElementById('chipsPerWaferPlot').innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <div class="breakdown-box-inner">${chipsPerWaferValue.toFixed(0)}</div>
                            <div class="breakdown-label">Working H100-sized chips per wafer</div>
                        </div>`;

                    // Transistor density relative to H100 - Bar plot at final timestep
                    const transistorDensityFinal = data.covert_fab.transistor_density.individual.map(sim => sim[sim.length - 1]);
                    const processNodes = data.covert_fab.process_node_by_sim;
                    plotBarByProcessNode('computePerChipPlot', transistorDensityFinal, processNodes, '#E8A863');

                    // Architecture Efficiency - Display as a box (constant value at agreement year)
                    const archEffValue = data.covert_fab.architecture_efficiency_at_agreement;
                    document.getElementById('architectureEfficiencyDisplay').innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <div class="breakdown-box-inner">${archEffValue.toFixed(2)}</div>
                            <div class="breakdown-label">Architecture Efficiency (relative to H100)</div>
                        </div>`;

                    // Total compute - time series over all timesteps
                    const totalComputeArray = data.covert_fab.is_operational.individual.map((opSim, simIdx) => {
                        return opSim.map((isOp, timeIdx) => {
                            return (isOp * data.covert_fab.wafer_starts.individual[simIdx][timeIdx] *
                                    data.covert_fab.architecture_efficiency.individual[simIdx][timeIdx] *
                                    data.covert_fab.compute_per_wafer_2022_arch.individual[simIdx][timeIdx]);
                        });
                    });

                    // Calculate median and percentiles for total compute
                    const totalComputeMedian = years.map((_, i) => {
                        const values = totalComputeArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.5)];
                    });
                    const totalComputeP25 = years.map((_, i) => {
                        const values = totalComputeArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const totalComputeP75 = years.map((_, i) => {
                        const values = totalComputeArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });

                    // Calculate y-axis maximum as 1.2 times the maximum 75th percentile value
                    const maxP75 = Math.max(...totalComputeP75);
                    const yMax = maxP75 * 1.2;

                    plotMedianWithPercentiles('totalComputePlot', {
                        median: totalComputeMedian,
                        p25: totalComputeP25,
                        p75: totalComputeP75,
                        individual: totalComputeArray
                    }, years, '#9B7BB3', 'H100e/Month', [0, yMax], false, true);

                    // Plot energy breakdown
                    // 1. Compute produced per month (reuse from above)
                    plotMedianWithPercentiles('energyComputePerMonthPlot', {
                        median: totalComputeMedian,
                        p25: totalComputeP25,
                        p75: totalComputeP75,
                        individual: totalComputeArray
                    }, years, '#9B7BB3', 'H100e/Month', [0, yMax], false, true);

                    // 2. Transistor density relative to H100 (reuse from above)
                    plotBarByProcessNode('energyTransistorDensityPlot', transistorDensityFinal, processNodes, '#E8A863');

                    // 3. Curve plot: Transistor density vs Energy efficiency
                    // Energy efficiency follows power law from fab_model.py:
                    // watts_per_tpp = H100_watts * (density_ratio)^exponent
                    // efficiency = 1 / (watts_per_tpp / H100_watts) = 1 / (density_ratio^exponent)

                    // Constants from fab_model.py
                    const H100_TRANSISTOR_DENSITY = 98.28;  // Million transistors per mm²
                    const DENNARD_THRESHOLD_DENSITY = 1.98;  // Million transistors per mm²
                    const EXPONENT_BEFORE_DENNARD = -2.006575;
                    const EXPONENT_AFTER_DENNARD = -0.909355;

                    // Use curve data from backend (calculated by Python)
                    const densityRangeRelative = data.covert_fab.watts_per_tpp_curve.density_relative;
                    const wattsPerTppCurve = data.covert_fab.watts_per_tpp_curve.watts_per_tpp_relative;
                    const dennardDataX = 1.98 / 98.28;

                    const xMin = 0.001;  // From your range
                    const xMax = 100;    // From your range

                    // Convert data coordinate to paper coordinate for log scale
                    const dennardPaperX = (Math.log10(dennardDataX) - Math.log10(xMin)) / 
                                        (Math.log10(xMax) - Math.log10(xMin));


                    // Create curve plot with actual simulation points overlaid
                    Plotly.newPlot('densityVsEfficiencyPlot', [
                        {
                            x: densityRangeRelative,
                            y: wattsPerTppCurve,
                            mode: 'lines',
                            type: 'scatter',
                            line: {
                                color: '#74B3A8',
                                width: 2
                            },
                            name: 'Power Law',
                            hovertemplate: 'Density: %{x:.2g}x<br>Efficiency: %{y:.2g}x<extra></extra>'
                        },
                        {
                            x: transistorDensityFinal,
                            y: data.covert_fab.watts_per_tpp.individual.map(sim => sim[sim.length - 1]),
                            mode: 'markers',
                            type: 'scatter',
                            marker: {
                                size: 6,
                                color: '#E8A863',
                                opacity: 0.7
                            },
                            name: 'Simulations',
                            hovertemplate: 'Density: %{x:.2g}x<br>Watts/TPP: %{y:.2g}x<extra></extra>'
                        }
                    ], {
                        xaxis: {
                            title: 'Transistor Density (relative to H100)',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            type: 'log',
                            range: [Math.log10(0.001), Math.log10(100)],
                            automargin: true
                        },
                        yaxis: {
                            title: 'Watts per TPP (relative to H100)',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            type: 'log',
                            tickmode: 'array',
                            tickvals: [0.01, 0.1, 1, 10, 100, 1000],
                            automargin: true
                        },
                        shapes: [{
                            type: 'line',
                            x0: dennardPaperX,
                            x1: dennardPaperX,
                            y0: 0,
                            y1: 1,
                            xref: 'paper',
                            yref: 'paper',
                            line: {
                                color: '#999',
                                width: 1,
                                dash: 'dot'
                            }
                        }],
                        annotations: [{
                            x: dennardPaperX + 0.02,
                            y: 0.85,
                            yref: 'paper',
                            xref: 'paper',
                            xanchor: 'left',
                            yanchor: 'bottom',
                            text: 'End of Dennard<br>Scaling',
                            showarrow: false,
                            align: "left",
                            font: {
                                size: 9,
                                color: '#666',
                            }
                        }],
                        margin: { l: 60, r: 10, t: 10, b: 65, pad: 10 },
                        showlegend: false,
                        hovermode: 'closest'
                    }, {displayModeBar: false, responsive: true});
                    setTimeout(() => Plotly.Plots.resize('densityVsEfficiencyPlot'), 50);

                    // 4. Display H100 energy requirements (from user input)
                    const h100PowerWatts = parseFloat(document.getElementById('h100_power_watts').value);
                    const h100EnergyWatts = h100PowerWatts; // Store in watts for calculations below
                    const h100EnergyKW = h100PowerWatts / 1000;
                    document.getElementById('h100EnergyDisplay').innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <div class="breakdown-box-inner">${h100EnergyKW.toFixed(2)} kW</div>
                            <div class="breakdown-label">Energy requirements of H100</div>
                        </div>`;

                    // 5. Calculate and plot energy requirements per month (GW/month)
                    // Energy = H100e_per_month × watts_per_TPP_relative × H100_energy
                    // Note: transistor_density is already factored into H100e calculation, don't multiply again!
                    const wattsPerTppBySimAndTime = data.covert_fab.watts_per_tpp.individual;

                    const energyPerMonthArray = totalComputeArray.map((simArray, simIdx) => {
                        return simArray.map((h100ePerMonth, timeIdx) => {
                            // h100ePerMonth is actual H100e count (not in thousands)
                            const wattsPerTppRelative = wattsPerTppBySimAndTime[simIdx][timeIdx];

                            // Energy (W) = H100e × watts_per_TPP_rel × H100_energy_watts
                            const totalWatts = h100ePerMonth * wattsPerTppRelative * h100EnergyWatts;
                            const energyGW = totalWatts / 1e9;
                            return energyGW;
                        });
                    });

                    const energyPerMonthMedian = years.map((_, i) => {
                        const values = energyPerMonthArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.5)];
                    });
                    const energyPerMonthP25 = years.map((_, i) => {
                        const values = energyPerMonthArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const energyPerMonthP75 = years.map((_, i) => {
                        const values = energyPerMonthArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });

                    const maxEnergyP75 = Math.max(...energyPerMonthP75);
                    const yMaxEnergy = maxEnergyP75 * 1.2;

                    plotMedianWithPercentiles('energyPerMonthPlot', {
                        median: energyPerMonthMedian,
                        p25: energyPerMonthP25,
                        p75: energyPerMonthP75,
                        individual: energyPerMonthArray
                    }, years, '#5AA89B', 'GW/Month', [0, yMaxEnergy], false, true);
                }

                // Check if project is running
                const runCovertProject = document.getElementById('run_covert_project').checked;
                const buildCovertFab = document.getElementById('build_covert_fab').checked;
                const projectNotRunDiv = document.getElementById('projectNotRun');
                const plotsContentDiv = document.getElementById('plotsContent');

                if (runCovertProject && buildCovertFab) {
                    // Show normal plots
                    projectNotRunDiv.style.display = 'none';
                    plotsContentDiv.style.display = 'block';
                } else {
                    // Show "project not run" message
                    projectNotRunDiv.style.display = 'block';
                    plotsContentDiv.style.display = 'none';
                }

                plotsDiv.style.display = 'block';
                loadingDiv.classList.remove('active');
                setStatus(`Simulation complete! Ran ${data.num_simulations} simulations`, 'success');
            } catch (error) {
                loadingDiv.classList.remove('active');
                setStatus('Error: ' + error.message, 'error');
            } finally {
                runButton.disabled = false;
            }
        }

        runButton.addEventListener('click', runSimulation);

        // Run simulation automatically on page load
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(runSimulation, 500); // Small delay to ensure page is fully loaded
        });

        // Add Enter key listener to all input fields and select elements in sidebar
        const sidebarInputs = document.querySelectorAll('.sidebar input, .sidebar select');
        sidebarInputs.forEach(input => {
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    runSimulation();
                }
            });
        });

        // Add click handler to breakdown box to focus corresponding input field
        const diversionProportionDisplay = document.getElementById('diversionProportionDisplay');
        if (diversionProportionDisplay) {
            diversionProportionDisplay.addEventListener('click', () => {
                const inputField = document.getElementById('proportion_of_initial_chip_stock_to_divert');
                if (inputField) {
                    inputField.focus();
                    inputField.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
            // Add cursor pointer style to indicate it's clickable
            diversionProportionDisplay.style.cursor = 'pointer';
        }

        // Setup tooltip handlers
        const globalTooltip = document.getElementById('globalTooltip');
        const tooltipElements = document.querySelectorAll('.has-tooltip');

        let hideTooltipTimeout;
        let currentTooltipElement = null;

        function hideTooltip() {
            globalTooltip.classList.remove('visible');
            globalTooltip.style.opacity = '0';
            currentTooltipElement = null;
        }

        function isMouseOverElementOrTooltip(mouseEvent) {
            // Check if mouse is over the current tooltip element
            if (currentTooltipElement && currentTooltipElement.matches(':hover')) {
                return true;
            }
            // Check if mouse is over the tooltip itself
            if (globalTooltip.matches(':hover')) {
                return true;
            }
            return false;
        }

        tooltipElements.forEach(element => {
            element.addEventListener('mouseenter', (e) => {
                clearTimeout(hideTooltipTimeout);
                currentTooltipElement = element;
                const tooltipText = element.getAttribute('data-tooltip');
                const downloadUrl = element.getAttribute('data-download');
                const imageUrl = element.getAttribute('data-image');
                const imageBeforeText = element.getAttribute('data-image-before-text');
                const imageAfterText = element.getAttribute('data-image-after-text');

                if (tooltipText) {
                    // Add the tooltip text
                    let content = tooltipText;

                    // Add image if data-image attribute exists
                    if (imageUrl) {
                        if (imageBeforeText) {
                            // Insert image before the specified text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageBeforeText}`;
                        } else if (imageAfterText) {
                            // Insert image after the tooltip text, then add the after text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageAfterText}`;
                        } else {
                            // Default: add image after tooltip text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px;" alt="Capabilities table">`;
                        }
                    }

                    // Add download button only if data-download attribute exists
                    if (downloadUrl) {
                        const fileName = downloadUrl.split('/').pop() + '.csv';
                        content += `<br><br><button onclick='window.location.href="${downloadUrl}"' style='margin-top: 8px; padding: 6px 12px; background-color: #555; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; pointer-events: auto;'>Download ${fileName}</button>`;
                    }

                    globalTooltip.innerHTML = content;

                    // Get the position of the element
                    const rect = element.getBoundingClientRect();

                    // Position tooltip to the right of the element
                    globalTooltip.style.left = (rect.right + 10) + 'px';

                    // Calculate vertical position to keep tooltip within viewport
                    let topPosition = rect.top;

                    // Show tooltip temporarily to measure its height
                    globalTooltip.style.visibility = 'hidden';
                    globalTooltip.style.opacity = '1';
                    globalTooltip.classList.add('visible');

                    const tooltipHeight = globalTooltip.offsetHeight;
                    const viewportHeight = window.innerHeight;

                    // If tooltip would go off bottom of screen, adjust position
                    if (topPosition + tooltipHeight > viewportHeight) {
                        topPosition = Math.max(10, viewportHeight - tooltipHeight - 10);
                    }

                    // If tooltip would go off top of screen, adjust position
                    if (topPosition < 10) {
                        topPosition = 10;
                    }

                    globalTooltip.style.top = topPosition + 'px';

                    // Now show tooltip properly
                    globalTooltip.style.visibility = 'visible';
                }
            });

            element.addEventListener('mouseleave', (e) => {
                // Give a short delay to allow mouse to move to tooltip
                hideTooltipTimeout = setTimeout(() => {
                    // Only hide if mouse is not over the element or tooltip
                    if (!isMouseOverElementOrTooltip(e)) {
                        hideTooltip();
                    }
                }, 100);
            });
        });

        // Keep tooltip visible when hovering over it
        globalTooltip.addEventListener('mouseenter', () => {
            clearTimeout(hideTooltipTimeout);
        });

        globalTooltip.addEventListener('mouseleave', () => {
            // Check if we're moving back to the original element
            hideTooltipTimeout = setTimeout(() => {
                if (!isMouseOverElementOrTooltip(event)) {
                    hideTooltip();
                }
            }, 100);
        });

        // Make breakdown plots clickable and link to sidebar inputs
        const plotToInputMapping = {
            // Section 2: US Bayesian Inference plots
            'lrInventoryPlot': 'proportion_diverted_sme', // Median absolute relative error of US intelligence estimate of PRC SME stock
            'lrProcurementPlot': 'localization_130nm_2025', // Probability PRC achieves >90% indigenization
            'lrOtherPlot': 'mean_detection_time_100', // Detection time
            'posteriorProbPlot': null, // Output, not an input

            // Section 3: Compute Production Rate plots
            'isOperationalPlot': 'construction_time_5k', // First construction time param
            'waferStartsPlot': 'wafers_per_month_per_worker', // Operating labor productivity
            'chipsPerWaferPlot': 'chips_per_wafer',
            'computePerChipPlot': 'transistor_density_exponent',
            'architectureEfficiencyDisplay': 'architecture_efficiency',
            'totalComputePlot': null, // Output, not an input

            // Section 4: Energy Requirements plots
            'energyTransistorDensityPlot': 'transistor_density_exponent',
            'densityVsEfficiencyPlot': 'watts_per_tpp_exponent_before_dennard',
            'h100EnergyDisplay': 'h100_power_watts',
            'energyComputePerMonthPlot': null, // This shows compute per month, not an input
            'energyPerMonthPlot': null // Output, not an input
        };

        // Add clickable class and click handlers to plots with associated inputs
        Object.entries(plotToInputMapping).forEach(([plotId, inputId]) => {
            const plotElement = document.getElementById(plotId);
            if (plotElement && inputId) {
                plotElement.classList.add('clickable');
                plotElement.addEventListener('click', () => {
                    const inputElement = document.getElementById(inputId);
                    if (inputElement) {
                        // Scroll input into view
                        inputElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Focus and select the input
                        setTimeout(() => {
                            inputElement.focus();
                            inputElement.select();
                        }, 300);
                    }
                });
            }
        });
        }  // End of initializeApp function

        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>
