<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Covert Compute Production Model</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background-color: #f5f5f5;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #ddd;
        }

        .sidebar h1 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #333;
        }

        .sidebar h2 {
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #555;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }

        .param-group {
            margin-bottom: 15px;
        }

        .param-group label {
            display: block;
            font-size: 13px;
            margin-bottom: 5px;
            color: #666;
        }

        .param-group input,
        .param-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .param-group input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }

        .localization-row {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .localization-row .param-group {
            flex: 1;
            margin-bottom: 0;
        }

        .localization-row label {
            font-size: 11px;
        }

        .localization-row input {
            padding: 6px;
        }

        .param-group.has-tooltip {
            position: relative;
        }

        #globalTooltip {
            position: fixed;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            background-color: #333;
            color: #fff;
            text-align: left;
            padding: 15px;
            border-radius: 6px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            pointer-events: none;
            visibility: hidden;
        }

        #globalTooltip.visible {
            pointer-events: auto;
        }

        #globalTooltip * {
            color: #fff !important;
        }

        /* Force Plotly hover labels to use white text */
        .hoverlayer .hovertext path {
            fill: #333 !important;
        }

        .hoverlayer .hovertext text {
            fill: #fff !important;
        }

        g.hovertext path {
            fill: #333 !important;
        }

        g.hovertext text {
            fill: #fff !important;
        }

        #globalTooltip::before {
            content: "";
            position: absolute;
            top: 20px;
            left: -8px;
            border-width: 8px;
            border-style: solid;
            border-color: transparent #333 transparent transparent;
        }

        #globalTooltip.visible {
            visibility: visible;
            opacity: 1;
        }

        button {
            width: 100%;
            padding: 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            margin-top: 20px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 20px 20px 20px;
            overflow-y: auto;
        }

        .top-plots {
            display: grid;
            grid-template-columns: 250px 1fr 1fr;
            gap: 20px;
            margin-bottom: 10px;
            width: 100%;
        }

        .dashboard {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .dashboard-item {
            text-align: center;
        }

        .dashboard-value {
            font-size: 32px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .dashboard-label {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 3px;
            line-height: 1.3;
        }

        .dashboard-sublabel {
            font-size: 10px;
            color: #777;
            line-height: 1.3;
        }

        .plot-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            min-width: 0; /* Allows grid items to shrink below content size */
            overflow: hidden;
        }

        .plot-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .plot {
            width: 100% !important;
            max-width: 100% !important;
            height: 364px;
        }

        .plot > div {
            width: 100% !important;
            max-width: 100% !important;
        }

        #computeCcdfPlot, #timeSeriesPlot {
            border: none !important;
        }

        #computeCcdfPlot > div, #timeSeriesPlot > div {
            border: none !important;
        }

        .breakdown-plot > div {
            border: none !important;
        }

        .breakdown-section {
            margin-top: 30px;
            padding: 15px 10px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .breakdown-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }

        .breakdown-plots-row {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
            max-width: 100%;
            width: 100%;
        }

        .breakdown-labels-row {
            display: flex;
            gap: 5px;
            max-width: 100%;
            width: 100%;
        }

        .breakdown-item {
            text-align: center;
            min-width: 0;
            flex: 1;
        }

        .breakdown-plot {
            height: 240px;
            width: 100%;
            max-width: 100%;
            flex: 1;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            transition: all 0.2s ease;
        }

        .breakdown-plot.clickable {
            cursor: pointer;
        }

        .breakdown-plot.clickable:hover {
            border-color: #007bff;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.3);
            transform: scale(1.02);
        }

        .breakdown-plot > div {
            width: 100% !important;
            max-width: 100% !important;
        }

        .breakdown-label {
            font-size: 11px;
            font-weight: bold;
            margin-top: 5px;
            color: #555;
            line-height: 1.2;
        }

        .breakdown-description {
            font-size: 9px;
            color: #777;
            margin-top: 5px;
            line-height: 1.3;
            font-style: italic;
        }

        .operator {
            font-size: 24px;
            font-weight: bold;
            color: #666;
            padding: 0 3px;
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .operator.arrow-operator {
            padding-top: 28px;
            padding-bottom: 0;
            padding-left: 20px;
            padding-right: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .status {
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-size: 13px;
        }

        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .status.success {
            background-color: #d4edda;
            color: #155724;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .section-description {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- Global tooltip (outside sidebar to avoid clipping) -->
    <div id="globalTooltip"></div>

    <div class="sidebar">
        <h1>Model Parameters</h1>

        <button id="runSimulation">Run Simulation</button>

        <div id="status"></div>

        <h2>Simulation Settings</h2>
        <div class="param-group">
            <label for="agreement_year">Agreement start year</label>
            <input type="number" id="agreement_year" value="2030" step="0.1">
        </div>
        <div class="param-group">
            <label for="end_year">End year</label>
            <input type="number" id="end_year" value="2037" step="0.1">
        </div>
        <div class="param-group">
            <label for="increment">Time increment (years)</label>
            <input type="number" id="increment" value="0.1" step="0.01">
        </div>
        <div class="param-group">
            <label for="num_simulations">Number of simulations</label>
            <input type="number" id="num_simulations" value="300" min="1" max="10000">
        </div>

        <h2>PRC Strategy</h2>
        <div class="param-group">
            <label>
                <input type="checkbox" id="run_covert_project" checked>
                Run covert project
            </label>
        </div>
        <div class="param-group">
            <label for="proportion_of_initial_chip_stock_to_divert">Proportion of initial chip stock to divert</label>
            <input type="number" id="proportion_of_initial_chip_stock_to_divert" value="{{ defaults.proportion_of_initial_chip_stock_to_divert }}" step="0.01" min="0" max="1">
        </div>

        <h3 style="font-size: 14px; margin-top: 15px; color: #777;">Covert datacenters</h3>
        <div class="param-group">
            <label for="GW_per_initial_datacenter">GW per initial datacenter</label>
            <input type="number" id="GW_per_initial_datacenter" value="{{ defaults.GW_per_initial_datacenter }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="number_of_initial_datacenters">Number of initial datacenters</label>
            <input type="number" id="number_of_initial_datacenters" value="{{ defaults.number_of_initial_datacenters }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="GW_per_year_of_concealed_datacenters">GW per year of concealed datacenters</label>
            <input type="number" id="GW_per_year_of_concealed_datacenters" value="{{ defaults.GW_per_year_of_concealed_datacenters }}" step="0.1">
        </div>

        <h3 style="font-size: 14px; margin-top: 15px; color: #777;">Covert fab</h3>
        <div class="param-group">
            <label>
                <input type="checkbox" id="build_covert_fab" checked>
                Build covert fab
            </label>
        </div>
        <div class="param-group">
            <label for="operating_labor">Number of workers to operate fab</label>
            <input type="number" id="operating_labor" value="{{ defaults.operating_labor }}">
        </div>
        <div class="param-group">
            <label for="construction_labor">Number of workers to construct fab</label>
            <input type="number" id="construction_labor" value="{{ defaults.construction_labor }}">
        </div>
        <div class="param-group">
            <label for="process_node">Process node</label>
            <select id="process_node">
                <option value="best_available_indigenously">Best Available Indigenously</option>
                <option value="nm130">130nm</option>
                <option value="nm28">28nm</option>
                <option value="nm14">14nm</option>
                <option value="nm7">7nm</option>
            </select>
        </div>
        <div class="param-group">
            <label for="scanner_proportion">Proportion of prc sme diverted to covert fab at start of the agreement</label>
            <input type="number" id="scanner_proportion" value="{{ defaults.scanner_proportion }}" step="0.001">
        </div>

        <h2>Initial PRC Dark Compute Parameters</h2>
        <div class="param-group">
            <label for="total_prc_compute_stock_in_2025">Total PRC compute stock in 2025 (millions of H100e)</label>
            <input type="number" id="total_prc_compute_stock_in_2025" value="{{ defaults.total_prc_compute_stock_in_2025 / 1e6 }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="annual_growth_rate_of_prc_compute_stock">Annual growth rate of PRC compute stock (multiplicative)</label>
            <input type="number" id="annual_growth_rate_of_prc_compute_stock" value="{{ defaults.annual_growth_rate_of_prc_compute_stock }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="relative_sigma_of_prc_compute_stock">Relative sigma of PRC compute stock (log scale)</label>
            <input type="number" id="relative_sigma_of_prc_compute_stock" value="{{ defaults.relative_sigma_of_prc_compute_stock }}" step="0.01">
        </div>
        <div class="param-group">
            <label for="us_intelligence_median_error_in_estimate_of_prc_compute_stock">US intelligence median error in estimate of PRC compute stock</label>
            <input type="number" id="us_intelligence_median_error_in_estimate_of_prc_compute_stock" value="{{ defaults.us_intelligence_median_error_in_estimate_of_prc_compute_stock }}" step="0.01">
        </div>
        <div class="param-group">
            <label for="total_global_compute_in_2025">Total global compute in 2025 (millions of H100e)</label>
            <input type="number" id="total_global_compute_in_2025" value="{{ defaults.total_global_compute_in_2025 / 1e6 }}" step="1">
        </div>
        <div class="param-group">
            <label for="annual_growth_rate_of_global_compute">Annual growth rate of global compute (multiplicative)</label>
            <input type="number" id="annual_growth_rate_of_global_compute" value="{{ defaults.annual_growth_rate_of_global_compute }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="relative_sigma_of_global_compute">Relative sigma of global compute (log scale)</label>
            <input type="number" id="relative_sigma_of_global_compute" value="{{ defaults.relative_sigma_of_global_compute }}" step="0.01">
        </div>
        <div class="param-group">
            <label for="median_unreported_compute_owned_by_non_prc_actors">Median unreported compute owned by non-PRC actors (millions of H100e)</label>
            <input type="number" id="median_unreported_compute_owned_by_non_prc_actors" value="{{ defaults.median_unreported_compute_owned_by_non_prc_actors / 1e6 }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="relative_sigma_unreported_compute_owned_by_non_prc_actors">Relative sigma of unreported compute owned by non-PRC actors (log scale)</label>
            <input type="number" id="relative_sigma_unreported_compute_owned_by_non_prc_actors" value="{{ defaults.relative_sigma_unreported_compute_owned_by_non_prc_actors }}" step="0.1">
        </div>

        <h2>Survival Rate Parameters</h2>
        <div class="param-group">
            <label for="initial_hazard_rate_p50">Initial hazard rate (median)</label>
            <input type="number" id="initial_hazard_rate_p50" value="{{ defaults.initial_hazard_rate_p50 }}" step="0.001">
        </div>
        <div class="param-group">
            <label for="increase_of_hazard_rate_per_year_p50">Increase of hazard rate per year (median)</label>
            <input type="number" id="increase_of_hazard_rate_per_year_p50" value="{{ defaults.increase_of_hazard_rate_per_year_p50 }}" step="0.001">
        </div>
        <div class="param-group">
            <label for="hazard_rate_p25_relative_to_p50">Hazard rate 25th percentile (relative to median)</label>
            <input type="number" id="hazard_rate_p25_relative_to_p50" value="{{ defaults.hazard_rate_p25_relative_to_p50 }}" step="0.01">
        </div>
        <div class="param-group">
            <label for="hazard_rate_p75_relative_to_p50">Hazard rate 75th percentile (relative to median)</label>
            <input type="number" id="hazard_rate_p75_relative_to_p50" value="{{ defaults.hazard_rate_p75_relative_to_p50 }}" step="0.1">
        </div>

        <h2>Covert Datacenter Parameters</h2>
        <div class="param-group">
            <label for="max_proportion_of_PRC_energy_consumption">Max proportion of PRC energy consumption</label>
            <input type="number" id="max_proportion_of_PRC_energy_consumption" value="{{ defaults.max_proportion_of_PRC_energy_consumption }}" step="0.01">
        </div>
        <div class="param-group">
            <label for="total_GW_of_PRC_energy_consumption">Total GW of PRC energy consumption</label>
            <input type="number" id="total_GW_of_PRC_energy_consumption" value="{{ defaults.total_GW_of_PRC_energy_consumption }}" step="10">
        </div>
        <div class="param-group">
            <label for="construction_labor_per_MW_per_year">Construction labor per MW per year</label>
            <input type="number" id="construction_labor_per_MW_per_year" value="{{ defaults.construction_labor_per_MW_per_year }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="relative_sigma_construction_labor_per_MW_per_year">Relative sigma construction labor per MW per year</label>
            <input type="number" id="relative_sigma_construction_labor_per_MW_per_year" value="{{ defaults.relative_sigma_construction_labor_per_MW_per_year }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="operating_labor_per_MW">Operating labor per MW</label>
            <input type="number" id="operating_labor_per_MW" value="{{ defaults.operating_labor_per_MW }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="relative_sigma_operating_labor_per_MW">Relative sigma operating labor per MW</label>
            <input type="number" id="relative_sigma_operating_labor_per_MW" value="{{ defaults.relative_sigma_operating_labor_per_MW }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="mean_detection_time_of_covert_site_for_100_workers">Mean detection time for 100 workers (years)</label>
            <input type="number" id="mean_detection_time_of_covert_site_for_100_workers" value="{{ defaults.mean_detection_time_of_covert_site_for_100_workers }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="mean_detection_time_of_covert_site_for_1000_workers">Mean detection time for 1000 workers (years)</label>
            <input type="number" id="mean_detection_time_of_covert_site_for_1000_workers" value="{{ defaults.mean_detection_time_of_covert_site_for_1000_workers }}" step="0.1">
        </div>
        <div class="param-group">
            <label for="variance_of_detection_time_given_num_workers">Variance of detection time given num workers</label>
            <input type="number" id="variance_of_detection_time_given_num_workers" value="{{ defaults.variance_of_detection_time_given_num_workers }}" step="0.1">
        </div>

        <h2>Covert fab parameters</h2>

        <h3 style="font-size: 14px; margin-top: 15px; color: #777;">Odds of Covert Project</h3>
        <div class="param-group">
            <label for="p_fab_exists">US prior probability that covert fab exists</label>
            <input type="number" id="p_fab_exists" value="0.1" step="0.01" min="0" max="1">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>SME Inventory Accounting Detection</strong><br><br><strong>Detection Method:</strong><br>US intelligence could detect a covert fab by noticing that equipment is missing from China's domestic semiconductor industry.<br><br><strong>Two Key Factors:</strong><br>1. Amount diverted: Diverting 80 of 100 stockpiled DUV scanners would be obvious; diverting a handful would not.<br>2. Width of USG's error bars: If USG estimates Chinese companies built 50-150 DUV scanners, a dozen missing wouldn't raise suspicion. If USG knows the exact count, it would notice.<br><br><strong>Historical Calibration:</strong><br>Historical intelligence estimates of weapon counts (tanks, nuclear warheads, etc.) from declassified documents (1960-2025) show median errors of ~15%." data-download="/download/us_intelligence_estimates" data-image="/static/error_bars_plot.png" data-image-after-text="<strong>Adjustment for SME Context:</strong><br>15% would be reasonable if the PRC treats SME with nuclear-weapons-level secrecy. However, it's plausible that China's semiconductor industry remains quasi-private with details shared among investors, or that the expansive SME industry is difficult to lock down. Therefore, I estimate that the US intelligence error margin will be ~7% (2x smaller than weapons programs).">
            <label for="proportion_diverted_sme">Median absolute relative error of US intelligence estimate of PRC SME stock</label>
            <input type="number" id="proportion_diverted_sme" value="0.07" step="0.01">
        </div>
        <div class="has-tooltip" style="margin-top: 15px; margin-bottom: 5px; font-size: 13px; color: #666; cursor: help;" data-tooltip="<strong>PRC Semiconductor Manufacturing Equipment (SME) Indigenization</strong><br><br><strong>Why Indigenization Matters for Covert Fabs:</strong><br>The SME market involves very few buyers and sellers globally. If equipment goes missing or can't be accounted for in international supply chains, there are only a handful of actors that could be hiding it—and the PRC would be a highly salient suspect. Therefore, a covert PRC fab would likely need to rely primarily on domestically-produced equipment to avoid detection through procurement accounting.<br><br>These parameters represent the probability that the PRC achieves >90% domestic sourcing of SME at each process node by the specified year. See the attached data file for detailed capabilities by equipment category and process node." data-image-after-text="<strong>Current Status (2025):</strong><br>The PRC can manufacture 130nm chips with mostly domestic tools (~80% localized). More advanced nodes require imported equipment, particularly photolithography scanners.<br><br><strong>Near-Term Progress (by 2031):</strong><br>• <strong>28nm:</strong> SMEE and Huawei-linked Yuliangsheng are developing DUV immersion scanners for 28nm. SMIC plans production integration by 2027. Given typical delays between prototype and production-ready equipment, there's ~25% chance of >90% localization by 2031.<br>• <strong>14nm & 7nm:</strong> Multi-patterning techniques could enable 28nm scanners to reach these nodes, but this requires years of additional development. Lower probability of high localization by 2031 (10% for 14nm, 6% for 7nm).<br><br><strong>Key Accelerants:</strong><br>• U.S. export controls driving indigenization urgency<br>• $47.5B Chinese government SME fund<br>• Aggressive talent recruitment (Huawei recruiting from ASML at 3x salary)<br>• Huawei's ¥12B R&D park with 35,000+ employees<br><br>The main bottleneck is talent (experienced engineers), not funding. Recent investments may start paying off by 2031, but the probability decreases significantly for more advanced nodes." data-image="/static/china_capabilities_table.png" data-download="/download/prc_indigenous_sme_capabilities">
            Probability PRC achieves >90% indiginization at node
        </div>
        <div class="localization-row">
            <div class="param-group">
                <label for="localization_130nm_2025">130nm 2025</label>
                <input type="number" id="localization_130nm_2025" value="0.80" step="0.01" min="0" max="1">
            </div>
            <div class="param-group">
                <label for="localization_130nm_2031">130nm 2031</label>
                <input type="number" id="localization_130nm_2031" value="0.80" step="0.01" min="0" max="1">
            </div>
        </div>
        <div class="localization-row">
            <div class="param-group">
                <label for="localization_28nm_2025">28nm 2025</label>
                <input type="number" id="localization_28nm_2025" value="0.0" step="0.01" min="0" max="1">
            </div>
            <div class="param-group">
                <label for="localization_28nm_2031">28nm 2031</label>
                <input type="number" id="localization_28nm_2031" value="0.25" step="0.01" min="0" max="1">
            </div>
        </div>
        <div class="localization-row">
            <div class="param-group">
                <label for="localization_14nm_2025">14nm 2025</label>
                <input type="number" id="localization_14nm_2025" value="0.0" step="0.01" min="0" max="1">
            </div>
            <div class="param-group">
                <label for="localization_14nm_2031">14nm 2031</label>
                <input type="number" id="localization_14nm_2031" value="0.10" step="0.01" min="0" max="1">
            </div>
        </div>
        <div class="localization-row">
            <div class="param-group">
                <label for="localization_7nm_2025">7nm 2025</label>
                <input type="number" id="localization_7nm_2025" value="0.0" step="0.01" min="0" max="1">
            </div>
            <div class="param-group">
                <label for="localization_7nm_2031">7nm 2031</label>
                <input type="number" id="localization_7nm_2031" value="0.06" step="0.01" min="0" max="1">
            </div>
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Detection Time</strong><br><br>These parameters determine the relationship between workforce size and the probability a covert project is detected over time. We estimated these parameters using online information about historical nuclear programs. Over the past 50 years, about a dozen states attempted to covertly develop nuclear weapons. For each case, we estimated the number of high-context workers involved and the time until detection (see attached data file).<br><br><strong>Functional Form:</strong><br>Detection time is modeled as a log-normal distribution:<br>• Mean detection time: μ(N) = μ₁₀₀ + (μ₁₀₀₀ - μ₁₀₀) × log₁₀(N/100) / log₁₀(10)<br>• Where N is the number of workers<br>• The mean scales logarithmically with workforce size<br>• Standard deviation σ is constant across workforce sizes<br><br>This parameter (μ₁₀₀) represents the expected detection time for a covert project with 100 high-context workers." data-download="/download/nuclear_case_studies">
            <label for="mean_detection_time_100">Expected time to detect covert project involving 100 people (years)</label>
            <input type="number" id="mean_detection_time_100" value="6.95" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Detection Time</strong><br><br>These parameters determine the relationship between workforce size and the probability a covert project is detected over time. We estimated these parameters using online information about historical nuclear programs. Over the past 50 years, about a dozen states attempted to covertly develop nuclear weapons. For each case, we estimated the number of high-context workers involved and the time until detection (see attached data file).<br><br><strong>Functional Form:</strong><br>Detection time is modeled as a log-normal distribution:<br>• Mean detection time: μ(N) = μ₁₀₀ + (μ₁₀₀₀ - μ₁₀₀) × log₁₀(N/100) / log₁₀(10)<br>• Where N is the number of workers<br>• The mean scales logarithmically with workforce size<br>• Standard deviation σ is constant across workforce sizes<br><br>This parameter (μ₁₀₀₀) represents the expected detection time for a covert project with 1000 high-context workers." data-download="/download/nuclear_case_studies">
            <label for="mean_detection_time_1000">Expected time to detect covert project involving 1000 people (years)</label>
            <input type="number" id="mean_detection_time_1000" value="3.42" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Detection Time</strong><br><br>These parameters determine the relationship between workforce size and the probability a covert project is detected over time. We estimated these parameters using online information about historical nuclear programs. Over the past 50 years, about a dozen states attempted to covertly develop nuclear weapons. For each case, we estimated the number of high-context workers involved and the time until detection (see attached data file).<br><br><strong>Functional Form:</strong><br>Detection time is modeled as a log-normal distribution:<br>• Mean detection time: μ(N) = μ₁₀₀ + (μ₁₀₀₀ - μ₁₀₀) × log₁₀(N/100) / log₁₀(10)<br>• Where N is the number of workers<br>• The mean scales logarithmically with workforce size<br>• Standard deviation σ is constant across workforce sizes<br><br>This parameter (σ) represents the standard deviation of the log-normal distribution." data-download="/download/nuclear_case_studies">
            <label for="variance_detection_time">Detection time sigma (years)</label>
            <input type="number" id="variance_detection_time" value="3.88" step="0.01">
        </div>

        <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">

        <h3 style="font-size: 14px; margin-top: 15px; color: #777;">Compute Production Rate</h3>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>Fab Construction Time</strong><br><br>Fab construction time depends on production capacity and construction labor. Time from 'breaking ground' to production ranges from 1-3 years for declared fabs.<br><br><img src='/static/construction_time_plot.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Construction time vs capacity'><br><br><strong>The Secrecy Tax:</strong><br>Covert fabs may take longer due to secrecy requirements. Comparing declared vs undeclared nuclear enrichment facilities: declared took 3.7 years on average, undeclared took 5.5 years - a 1.5x 'secrecy tax'.<br><br>So realistic timeframes for covert fabs: 1.5-4.5 years.<br><br><img src='/static/construction_time_plot_adjusted.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Adjusted construction time'><br><br><strong>Construction Labor:</strong><br>How does fab construction time depend on construction labor? McKinsey claims that 'about 100 workers are dedicated to the construction phase' for approximately every $1 billion spent on fab construction. Looking at a couple of examples, this claim appears to be roughly accurate.<br><br>Now, here's the cost of constructing a fab given its production capacity:<br><br><img src='/static/cost_of_fab_plot.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Production capacity vs cost'><br><br>Our model predicts the production capacity based on operating labor and SME inputs. So we can predict the construction labor that would typically be required by first estimating the cost of the project, and then using the heuristic that 100 concurrent workers are needed for every $1 billion USD.<br><br>But what if the provided construction labor falls short of this standard requirement? Then, we assume that if X times less construction labor is provided, construction will move X times slower. Conversely, if construction labor is oversupplied, then we assume that there's no speedup (which corresponds to the simple 'fixed-ratios' production function).<br><br><img src='/static/construction_time_vs_labor.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Construction time vs labor'>"
             data-download="/download/construction_time_vs_fab_capacity">
            <label for="construction_time_5k">Construction time of 5k wafers/month fab (years)</label>
            <input type="number" id="construction_time_5k" value="1.40" step="0.01">
        </div>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>Fab Construction Time</strong><br><br>Fab construction time depends on production capacity and construction labor. Time from 'breaking ground' to production ranges from 1-3 years for declared fabs.<br><br><img src='/static/construction_time_plot.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Construction time vs capacity'><br><br><strong>The Secrecy Tax:</strong><br>Covert fabs may take longer due to secrecy requirements. Comparing declared vs undeclared nuclear enrichment facilities: declared took 3.7 years on average, undeclared took 5.5 years - a 1.5x 'secrecy tax'.<br><br>So realistic timeframes for covert fabs: 1.5-4.5 years.<br><br><img src='/static/construction_time_plot_adjusted.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Adjusted construction time'><br><br><strong>Construction Labor:</strong><br>How does fab construction time depend on construction labor? McKinsey claims that 'about 100 workers are dedicated to the construction phase' for approximately every $1 billion spent on fab construction. Looking at a couple of examples, this claim appears to be roughly accurate.<br><br>Now, here's the cost of constructing a fab given its production capacity:<br><br><img src='/static/cost_of_fab_plot.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Production capacity vs cost'><br><br>Our model predicts the production capacity based on operating labor and SME inputs. So we can predict the construction labor that would typically be required by first estimating the cost of the project, and then using the heuristic that 100 concurrent workers are needed for every $1 billion USD.<br><br>But what if the provided construction labor falls short of this standard requirement? Then, we assume that if X times less construction labor is provided, construction will move X times slower. Conversely, if construction labor is oversupplied, then we assume that there's no speedup (which corresponds to the simple 'fixed-ratios' production function).<br><br><img src='/static/construction_time_vs_labor.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Construction time vs labor'>"
             data-download="/download/construction_time_vs_fab_capacity">
            <label for="construction_time_100k">Construction time of 100k wafers/month fab (years)</label>
            <input type="number" id="construction_time_100k" value="2.41" step="0.01">
        </div>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>Fab Construction Time</strong><br><br>Fab construction time depends on production capacity and construction labor. Time from 'breaking ground' to production ranges from 1-3 years for declared fabs.<br><br><img src='/static/construction_time_plot.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Construction time vs capacity'><br><br><strong>The Secrecy Tax:</strong><br>Covert fabs may take longer due to secrecy requirements. Comparing declared vs undeclared nuclear enrichment facilities: declared took 3.7 years on average, undeclared took 5.5 years - a 1.5x 'secrecy tax'.<br><br>So realistic timeframes for covert fabs: 1.5-4.5 years.<br><br><img src='/static/construction_time_plot_adjusted.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Adjusted construction time'><br><br><strong>Construction Labor:</strong><br>How does fab construction time depend on construction labor? McKinsey claims that 'about 100 workers are dedicated to the construction phase' for approximately every $1 billion spent on fab construction. Looking at a couple of examples, this claim appears to be roughly accurate.<br><br>Now, here's the cost of constructing a fab given its production capacity:<br><br><img src='/static/cost_of_fab_plot.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Production capacity vs cost'><br><br>Our model predicts the production capacity based on operating labor and SME inputs. So we can predict the construction labor that would typically be required by first estimating the cost of the project, and then using the heuristic that 100 concurrent workers are needed for every $1 billion USD.<br><br>But what if the provided construction labor falls short of this standard requirement? Then, we assume that if X times less construction labor is provided, construction will move X times slower. Conversely, if construction labor is oversupplied, then we assume that there's no speedup (which corresponds to the simple 'fixed-ratios' production function).<br><br><img src='/static/construction_time_vs_labor.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Construction time vs labor'>"
             data-download="/download/construction_time_vs_fab_capacity">
            <label for="construction_time_sigma">Construction time vs wafers per month sigma (relative, log scale)</label>
            <input type="number" id="construction_time_sigma" value="0.35" step="0.01">
        </div>
        <div class="param-group">
            <label for="construction_workers_per_1000">Construction workers per 1000 wafers/month</label>
            <input type="number" id="construction_workers_per_1000" value="14.1" step="0.1">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Operating Labor and Fab Production Capacity</strong><br><br>Fab production capacity depends on two main factors:<br>• Operating labor<br>• Quantity of SME<br><br>The relationship between the number of workers involved in operating a fab and its production capacity is shown in the attached plot, which displays wafers per month vs operating labor.<br><br>This regression trend is used in the model to estimate production capacity based on the allocated operating workforce.<br><br><strong>Production Function:</strong><br>The model uses a fixed-proportions production function where fab output is the minimum of labor and scanner constraints:<br><br>Production = min(24.6 × operating labor, 1000 × num scanners)" data-image="/static/labor_vs_production.png" data-download="/download/compute_production_vs_operating_labor">
            <label for="wafers_per_month_per_worker">Wafers/month per operating worker</label>
            <input type="number" id="wafers_per_month_per_worker" value="24.64" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Operating Labor and Fab Production Capacity</strong><br><br>Fab production capacity depends on two main factors:<br>• Operating labor<br>• Quantity of SME<br><br>The relationship between the number of workers involved in operating a fab and its production capacity is shown in the attached plot, which displays wafers per month vs operating labor.<br><br>This regression trend is used in the model to estimate production capacity based on the allocated operating workforce.<br><br><strong>Production Function:</strong><br>The model uses a fixed-proportions production function where fab output is the minimum of labor and scanner constraints:<br><br>Production = min(24.6 × operating labor, 1000 × num scanners)" data-image="/static/labor_vs_production.png" data-download="/download/compute_production_vs_operating_labor">
            <label for="labor_productivity_sigma">Wafers per month per operating worker sigma (log scale, wafers/month)</label>
            <input type="number" id="labor_productivity_sigma" value="0.62" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Photolithography Scanner Production Capacity</strong><br><br>Advanced photolithography scanners are often the main bottleneck to chip production. ASML claims that its DUV lithography machines can pattern around 250 wafers per hour, or 180,000 wafers per month.<br><br>However, each chip typically requires around 80 patterning steps and scanners operate at roughly 50% utilization. Therefore, each machine processes approximately:<br><br>0.5 × 180,000 / 80 = 1,000 completed wafers per month<br><br><strong>Production Function:</strong><br>The model uses a fixed-proportions production function where fab output is the minimum of labor and scanner constraints:<br><br>Production = min(24.6 × operating labor, 1000 × num scanners)">
            <label for="wafers_per_month_per_scanner">Wafers/month per photolithography scanner</label>
            <input type="number" id="wafers_per_month_per_scanner" value="1000" step="1">
        </div>
        <div class="param-group">
            <label for="scanner_productivity_sigma">Wafers per month per photolithography scanner sigma (log scale, wafers/month)</label>
            <input type="number" id="scanner_productivity_sigma" value="0.20" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>PRC Lithography Scanner Production Ramp-Up</strong><br><br>To estimate the total number of indigenous lithography scanners the PRC has at a given time, we model their production ramp-up based on historical ASML scaling patterns.<br><br>The attached plot shows how quickly ASML scaled production of a given lithography machine after it was first used in high volume production. The model assumes that PRC photolithography scanner production follows a similar trend (shown as the orange trendline) starting from the date when the PRC achieves high volume production at a given node.<br><br>This parameter represents the number of scanners produced in the first year after achieving high volume production capability." data-image="/static/lithography_sales_plot.png" data-download="/download/asml_sales_history">
            <label for="prc_scanners_first_year">Prc scanners produced in first year after high volume production is achieved</label>
            <input type="number" id="prc_scanners_first_year" value="20.0" step="1">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>PRC Lithography Scanner Production Ramp-Up</strong><br><br>To estimate the total number of indigenous lithography scanners the PRC has at a given time, we model their production ramp-up based on historical ASML scaling patterns.<br><br>The attached plot shows how quickly ASML scaled production of a given lithography machine after it was first used in high volume production. The model assumes that PRC photolithography scanner production follows a similar trend (shown as the orange trendline) starting from the date when the PRC achieves high volume production at a given node.<br><br>This parameter represents the annual increase in scanner production after the first year." data-image="/static/lithography_sales_plot.png" data-download="/download/asml_sales_history">
            <label for="prc_scanners_per_year">Annual increase of scanner production</label>
            <input type="number" id="prc_scanners_per_year" value="16.0" step="1">
        </div>
        <div class="param-group">
            <label for="prc_scanner_production_sigma">Prc scanner production sigma (log scale, scanners/year)</label>
            <input type="number" id="prc_scanner_production_sigma" value="0.30" step="0.01">
        </div>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>H100-sized Chips per Wafer (Yield)</strong><br><br>The value of 28 H100-sized chips per wafer represents the yield that TSMC achieved when manufacturing H100s for NVIDIA.<br><br>Source: <a href='https://www.trendforce.com/news/2024/03/18/news-tsmc-boosts-investment-in-advanced-packaging-with-ntd-500-billion-plan-to-build-six-plants-in-chiayi-science-park/' style='color: #6db4ff;' target='_blank'>TrendForce (March 2024)</a>">
            <label for="chips_per_wafer">H100-sized chips per wafer (yield)</label>
            <input type="number" id="chips_per_wafer" value="28" step="1">
        </div>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>Transistor Density</strong><br><br>Transistor density depends on the process node - the resolution at which circuits can be patterned onto the wafer. Historical data shows how transistor density (in millions of transistors per mm²) varies across different process nodes.<br><br>The figure below shows the relationship between process node (bottom axis) and H100 equivalents per wafer with 2022 architectures (left axis). This assumes a yield of 28 H100-sized chips per wafer."
             data-image="/static/h100_equiv_per_year_vs_process_node.png"
             data-download="/download/transistor_density_vs_node">
            <label for="transistor_density_exponent">Transistor density increase for every halving of process node</label>
            <input type="number" id="transistor_density_exponent" value="1.49" step="0.01">
        </div>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>Architecture Efficiency</strong><br><br>Over time, chip architectures improve and chips deliver more performance. To predict these improvements, we infer architecture efficiency by comparing how total chip performance has improved versus transistor density improvements.<br><br>According to <a href='https://epoch.ai/blog/trends-in-machine-learning-hardware' style='color: #6db4ff;'>Epoch's data</a>, total performance (TPP/Die Area) has improved at roughly 1.55x per year:<br><br><img src='/static/tpp_per_die_area.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='TPP per die area over time'><br><br>However, transistor density has only increased at 1.26x per year:<br><br><img src='/static/transistor_density_over_time.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Transistor density over time'><br><br>Therefore, architecture improvements have increased TPP/Die Area by around 1.55 / 1.26 = <strong>1.23x per year</strong>.">
            <label for="architecture_efficiency">Rate of architecture efficiency improvement per year</label>
            <input type="number" id="architecture_efficiency" value="1.23" step="0.01">
        </div>
    </div>

    <div class="main-content">
        <div class="loading active" id="loading">
            <h2>Running Simulation...</h2>
            <p>This may take a few moments.</p>
        </div>

        <div id="plots" style="display: none;">
            <!-- Dark Compute Equation Section -->
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 30px;">
                <div style="font-size: 120px; font-weight: 300; color: #666; flex: 0 0 30px; text-align: center; line-height: 250px;">(</div>
                <div style="flex: 1; min-width: 200px;">
                    <div id="initialDarkComputePlot" style="width: 100%; height: 250px;"></div>
                    <div style="text-align: center; margin-top: 5px; font-weight: bold; color: #333; font-size: 14px;">Initial Dark Compute</div>
                </div>
                <div style="font-size: 24px; font-weight: bold; color: #666; flex: 0 0 30px; text-align: center;">+</div>
                <div style="flex: 1; min-width: 200px;">
                    <div id="covertFabFlowPlot" style="width: 100%; height: 250px;"></div>
                    <div style="text-align: center; margin-top: 5px; font-weight: bold; color: #333; font-size: 14px;">Compute Flow</div>
                </div>
                <div style="font-size: 120px; font-weight: 300; color: #666; flex: 0 0 30px; text-align: center; line-height: 250px;">)</div>
                <div style="font-size: 24px; font-weight: bold; color: #666; flex: 0 0 30px; text-align: center;">×</div>
                <div style="flex: 1; min-width: 200px;">
                    <div id="chipSurvivalPlot" style="width: 100%; height: 250px;"></div>
                    <div style="text-align: center; margin-top: 5px; font-weight: bold; color: #333; font-size: 14px;">Average Survival Rate</div>
                </div>
                <div style="font-size: 24px; font-weight: bold; color: #666; flex: 0 0 30px; text-align: center;">=</div>
                <div style="flex: 1; min-width: 200px;">
                    <div id="totalDarkComputePlot" style="width: 100%; height: 250px;"></div>
                    <div style="text-align: center; margin-top: 5px; font-weight: bold; color: #333; font-size: 14px;">Dark Compute</div>
                </div>
            </div>

            <h1 style="font-size: 32px; font-weight: bold; margin-bottom: 20px; margin-top: 0; color: #333;">Initial stock</h1>

            <!-- Dashboard and Detection Probability -->
            <div style="display: flex; gap: 20px; margin-bottom: 30px; align-items: stretch;">
                <div style="flex: 0 0 250px; min-width: 250px;">
                    <div class="dashboard" style="height: 300px;">
                        <div class="dashboard-item">
                            <div class="dashboard-value" id="dashboardMedianDarkCompute">--</div>
                            <div class="dashboard-label">Median Initial PRC Dark Compute Stock</div>
                        </div>
                        <div class="dashboard-item">
                            <div class="dashboard-value" id="dashboardMedianLR">--</div>
                            <div class="dashboard-label">Probability of detection</div>
                            <div class="dashboard-sublabel">Detection means a ≥5x likelihood ratio</div>
                        </div>
                    </div>
                </div>
                <div style="flex: 0 0 25%; min-width: 200px;">
                    <div id="initialDarkComputeDetectionPlot" style="width: 100%; height: 300px;"></div>
                </div>
                <div style="flex: 1; min-width: 400px;">
                    <div id="initialComputeStockPlot" style="width: 100%; height: 300px;"></div>
                </div>
            </div>

            <div class="breakdown-section">
                <div class="breakdown-title">Evidence Breakdown</div>
                <div class="section-description">
                    Combined LR = LR<sub>PRC accounting</sub> × LR<sub>global accounting</sub><br>
                    Multiply likelihood ratios from PRC compute stock reporting and global compute production accounting to assess detection risk from initial stock discrepancies.
                </div>
                <div class="breakdown-plots-row">
                    <div class="breakdown-item">
                        <div id="lrPrcAccountingPlot" class="breakdown-plot"></div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="lrGlobalAccountingPlot" class="breakdown-plot"></div>
                    </div>
                    <div class="operator" style="font-size: 20px;">=</div>
                    <div class="breakdown-item">
                        <div id="lrCombinedPlot" class="breakdown-plot"></div>
                    </div>
                </div>
                <div class="breakdown-labels-row">
                    <div class="breakdown-item">
                        <div class="breakdown-label">Evidence from PRC compute stock accounting</div>
                        <div class="breakdown-description">If the PRC reports less compute stock than U.S. intelligence estimates they possess, this is evidence for a covert project. Conversely, if the PRC reports the same or more compute than the U.S. estimates, this is evidence against a covert project.</div>
                    </div>
                    <div class="operator" style="visibility: hidden;">×</div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Evidence from global compute production accounting</div>
                        <div class="breakdown-description">If the total amount of reported global compute is lower than U.S. intelligence estimates of total compute produced to date, this suggests unreported compute exists. Given that the PRC is the most likely actor to hold large quantities of unreported compute, a substantial discrepancy between reported and estimated production provides evidence of a PRC covert project.</div>
                    </div>
                    <div class="operator" style="visibility: hidden;">=</div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Combined likelihood ratio</div>
                        <div class="breakdown-description">The product of the two independent evidence sources gives the overall likelihood ratio update from initial compute reporting. Higher values indicate stronger evidence for a covert project.</div>
                    </div>
                </div>
            </div>

            <div class="breakdown-section">
                <div class="breakdown-title">Compute Breakdown</div>
                <div class="section-description">
                    Dark Compute Stock = Initial PRC Compute Stock × Proportion Diverted<br>
                    The dark compute stock is determined by the total PRC compute stock at time of agreement and the proportion diverted to the covert project.
                </div>
                <div class="breakdown-plots-row">
                    <div class="breakdown-item">
                        <div id="initialPrcStockPlot" class="breakdown-plot"></div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                        <div class="breakdown-label" style="visibility: hidden; margin-bottom: 5px;">Proportion<br>Diverted</div>
                        <div id="diversionProportionDisplay" class="breakdown-plot" style="display: flex; align-items: center; justify-content: center; font-size: 32px; font-weight: bold; color: #555; padding: 0; height: 70px;">
                            --
                        </div>
                        <div class="breakdown-label" style="margin-top: 5px;">Proportion diverted<br>to covert project</div>
                    </div>
                    <div class="operator" style="font-size: 20px;">=</div>
                    <div class="breakdown-item">
                        <div id="darkComputeResultPlot" class="breakdown-plot"></div>
                    </div>
                </div>
                <div class="breakdown-labels-row">
                    <div class="breakdown-item">
                        <div class="breakdown-label">Initial PRC compute stock</div>
                        <div class="breakdown-description">The total compute stock owned by the PRC at the time the agreement goes into force, before any diversion to a covert project.</div>
                    </div>
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                    </div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Initial PRC dark compute</div>
                        <div class="breakdown-description">The resulting compute stock diverted to the covert project, which is hidden from international monitoring and accounting systems.</div>
                    </div>
                </div>
            </div>

            <h1 style="font-size: 32px; font-weight: bold; margin-bottom: 20px; margin-top: 40px; color: #333;">Covert fab</h1>

            <div id="projectNotRun" style="display: none; padding: 40px; text-align: center;">
                <p style="font-size: 18px; color: #666;">Project not run</p>
            </div>

            <div id="plotsContent">
            <div class="top-plots">
                <div class="dashboard">
                    <div class="dashboard-item">
                        <div class="dashboard-value" id="dashboard80thH100e">--</div>
                        <div class="dashboard-label">Covert Compute Production Before Detection (80th %ile Outcome)</div>
                        <div class="dashboard-sublabel" id="dashboardDetectionLabel">Detection = US estimates covert fab has ≥5x higher odds than previously thought</div>
                    </div>
                    <div class="dashboard-item">
                        <div class="dashboard-value" id="dashboard80thTime">--</div>
                        <div class="dashboard-label">Years Operational Before Detection (80th %ile Outcome)</div>
                    </div>
                    <div class="dashboard-item">
                        <div class="dashboard-value" id="dashboard80thNode">--</div>
                        <div class="dashboard-label">Process Node (80th %ile Outcome)</div>
                    </div>
                </div>

                <div class="plot-container">
                    <div class="plot-title">Covert Compute Produced Before Detection</div>
                    <div id="computeCcdfPlot" class="plot"></div>
                </div>

                <div class="plot-container">
                    <div class="plot-title">Simulation Runs</div>
                    <div id="timeSeriesPlot" class="plot"></div>
                </div>

                <div class="plot-container">
                    <div class="plot-title">Covert Datacenters</div>
                    <div id="datacenterCapacityPlot" class="plot"></div>
                </div>
            </div>

            <div class="breakdown-section">
                <div class="breakdown-title">Evidence Breakdown</div>
                <div class="section-description">
                    Posterior Odds = Prior Odds × LR<sub>inventory</sub> × LR<sub>procurement</sub> × LR<sub>other</sub><br>
                    Combine prior belief with evidence from three independent intelligence sources to estimate detection likelihood.
                </div>
                <div class="breakdown-plots-row">
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                        <div class="breakdown-label" style="visibility: hidden; margin-bottom: 5px;">Prior Odds of<br>Covert Fab</div>
                        <div id="priorOddsDisplay" class="breakdown-plot" style="display: flex; align-items: center; justify-content: center; font-size: 32px; font-weight: bold; color: #555; padding: 0; height: 70px;">
                            --
                        </div>
                        <div class="breakdown-label" style="margin-top: 5px;">Prior Odds of<br>Covert Fab</div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="lrInventoryPlot" class="breakdown-plot"></div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="lrProcurementPlot" class="breakdown-plot"></div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="lrOtherPlot" class="breakdown-plot"></div>
                    </div>
                    <div class="operator arrow-operator" style="position: relative;">
                        <div style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); font-size: 9px; text-align: center; color: #888; line-height: 1.3; width: 70px;">Convert to<br>probability</div>
                        <div style="font-size: 20px;">→</div>
                    </div>
                    <div class="breakdown-item">
                        <div id="posteriorProbPlot" class="breakdown-plot"></div>
                    </div>
                </div>
                <div class="breakdown-labels-row">
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                    </div>
                    <div class="operator" style="visibility: hidden;">×</div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Evidence from accounting for prior PRC SME stock</div>
                        <div class="breakdown-description">If the PRC reports less SME than U.S. intelligence believes that it possesses, then this is evidence for a covert fab. Conversely, if the PRC reports the same or more equipment than the U.S. thinks it possesses, this is evidence against a covert fab.</div>
                    </div>
                    <div class="operator" style="visibility: hidden;">×</div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Evidence from tracing SME procurements</div>
                        <div class="breakdown-description">We assume that if most of the SME used to build a covert fab is from Chinese sources (aka localization is > 90%), then U.S. intelligence doesn't obtain any evidence from procurement intelligence that the covert fab exists. Otherwise, U.S. intelligence obtains strong evidence that the fab exists (a 10x update).</div>
                    </div>
                    <div class="operator" style="visibility: hidden;">×</div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Evidence from other intelligence sources</div>
                        <div class="breakdown-description">Over time, U.S. intelligence is increasingly likely to identify information through human intelligence, signal intelligence, etc. that provides strong evidence of a covert fab. For every year they don't observe this information, the likelihood of a covert fab decreases.</div>
                    </div>
                    <div class="operator arrow-operator" style="visibility: hidden;">→</div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Posterior Probability of<br>Covert Fab</div>
                    </div>
                </div>
            </div>

            <div class="breakdown-section">
                <div class="breakdown-title">Compute Production Breakdown</div>
                <div class="section-description">
                    H100e per month = Construction has finished? × Wafers processed per Month × Working H100-sized chips per wafer × Transistor density relative to an H100 × Architecture efficiency<br>
                    Architecture efficiency improves until the agreement year, then remains constant.
                </div>
                <div class="breakdown-plots-row">
                    <div class="breakdown-item">
                        <div id="isOperationalPlot" class="breakdown-plot"></div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="waferStartsPlot" class="breakdown-plot"></div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                        <div class="breakdown-label" style="visibility: hidden; margin-bottom: 5px;">Working H100-sized chips per wafer</div>
                        <div id="chipsPerWaferPlot" class="breakdown-plot" style="padding: 0; height: 70px;"></div>
                        <div class="breakdown-label" style="margin-top: 5px;">Working H100-sized chips per wafer</div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="computePerChipPlot" class="breakdown-plot"></div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                        <div class="breakdown-label" style="visibility: hidden; margin-bottom: 5px;">Architecture Efficiency (relative to H100)</div>
                        <div id="architectureEfficiencyDisplay" class="breakdown-plot" style="display: flex; align-items: center; justify-content: center; font-size: 32px; font-weight: bold; color: #555; padding: 0; height: 70px;">
                            --
                        </div>
                        <div class="breakdown-label" style="margin-top: 5px;">Architecture Efficiency (relative to H100)</div>
                    </div>
                    <div class="operator">=</div>
                    <div class="breakdown-item">
                        <div id="totalComputePlot" class="breakdown-plot"></div>
                    </div>
                </div>
                <div class="breakdown-labels-row">
                    <div class="breakdown-item">
                        <div class="breakdown-label">Probability construction has finished</div>
                    </div>
                    <div class="operator" style="visibility: hidden;">×</div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Production capacity (wafer starts per month)</div>
                    </div>
                    <div class="operator" style="visibility: hidden;">×</div>
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                    </div>
                    <div class="operator" style="visibility: hidden;">×</div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Transistor density relative to H100</div>
                    </div>
                    <div class="operator" style="visibility: hidden;">×</div>
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                    </div>
                    <div class="operator" style="visibility: hidden;">=</div>
                    <div class="breakdown-item">
                        <div class="breakdown-label">Compute produced per month (H100e / month)</div>
                    </div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <script>
        const runButton = document.getElementById('runSimulation');
        const statusDiv = document.getElementById('status');
        const loadingDiv = document.getElementById('loading');
        const plotsDiv = document.getElementById('plots');

        function setStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
        }

        function getParameters() {
            return {
                agreement_year: parseFloat(document.getElementById('agreement_year').value),
                end_year: parseFloat(document.getElementById('end_year').value),
                increment: parseFloat(document.getElementById('increment').value),
                num_simulations: parseInt(document.getElementById('num_simulations').value),
                // Initial PRC compute stock parameters
                total_prc_compute_stock_in_2025: parseFloat(document.getElementById('total_prc_compute_stock_in_2025').value) * 1e6,
                annual_growth_rate_of_prc_compute_stock: parseFloat(document.getElementById('annual_growth_rate_of_prc_compute_stock').value),
                relative_sigma_of_prc_compute_stock: parseFloat(document.getElementById('relative_sigma_of_prc_compute_stock').value),
                us_intelligence_median_error_in_estimate_of_prc_compute_stock: parseFloat(document.getElementById('us_intelligence_median_error_in_estimate_of_prc_compute_stock').value),
                run_covert_project: document.getElementById('run_covert_project').checked,
                proportion_of_initial_chip_stock_to_divert: parseFloat(document.getElementById('proportion_of_initial_chip_stock_to_divert').value),
                GW_per_initial_datacenter: parseFloat(document.getElementById('GW_per_initial_datacenter').value),
                number_of_initial_datacenters: parseFloat(document.getElementById('number_of_initial_datacenters').value),
                GW_per_year_of_concealed_datacenters: parseFloat(document.getElementById('GW_per_year_of_concealed_datacenters').value),
                build_covert_fab: document.getElementById('build_covert_fab').checked,
                operating_labor: parseInt(document.getElementById('operating_labor').value),
                construction_labor: parseInt(document.getElementById('construction_labor').value),
                process_node: document.getElementById('process_node').value,
                scanner_proportion: parseFloat(document.getElementById('scanner_proportion').value),
                p_fab_exists: parseFloat(document.getElementById('p_fab_exists').value),
                // Detection parameters
                median_absolute_relative_error_of_us_intelligence_estimate_of_prc_sme_stock: parseFloat(document.getElementById('proportion_diverted_sme').value),
                mean_detection_time_for_100_workers: parseFloat(document.getElementById('mean_detection_time_100').value),
                mean_detection_time_for_1000_workers: parseFloat(document.getElementById('mean_detection_time_1000').value),
                variance_of_detection_time_given_num_workers: parseFloat(document.getElementById('variance_detection_time').value),
                // Production capacity
                wafers_per_month_per_worker: parseFloat(document.getElementById('wafers_per_month_per_worker').value),
                labor_productivity_relative_sigma: parseFloat(document.getElementById('labor_productivity_sigma').value),
                wafers_per_month_per_lithography_scanner: parseFloat(document.getElementById('wafers_per_month_per_scanner').value),
                scanner_productivity_relative_sigma: parseFloat(document.getElementById('scanner_productivity_sigma').value),
                // Construction time
                construction_time_for_5k_wafers_per_month: parseFloat(document.getElementById('construction_time_5k').value),
                construction_time_for_100k_wafers_per_month: parseFloat(document.getElementById('construction_time_100k').value),
                construction_time_relative_sigma: parseFloat(document.getElementById('construction_time_sigma').value),
                construction_workers_per_1000_wafers_per_month: parseFloat(document.getElementById('construction_workers_per_1000').value),
                // Chip production
                h100_sized_chips_per_wafer: parseFloat(document.getElementById('chips_per_wafer').value),
                transistor_density_scaling_exponent: parseFloat(document.getElementById('transistor_density_exponent').value),
                architecture_efficiency_improvement_per_year: parseFloat(document.getElementById('architecture_efficiency').value),
                // PRC scanner production
                prc_lithography_scanners_produced_in_first_year: parseFloat(document.getElementById('prc_scanners_first_year').value),
                prc_additional_lithography_scanners_produced_per_year: parseFloat(document.getElementById('prc_scanners_per_year').value),
                prc_scanner_production_relative_sigma: parseFloat(document.getElementById('prc_scanner_production_sigma').value),
                // Localization probabilities
                localization_130nm_2025: parseFloat(document.getElementById('localization_130nm_2025').value),
                localization_130nm_2031: parseFloat(document.getElementById('localization_130nm_2031').value),
                localization_28nm_2025: parseFloat(document.getElementById('localization_28nm_2025').value),
                localization_28nm_2031: parseFloat(document.getElementById('localization_28nm_2031').value),
                localization_14nm_2025: parseFloat(document.getElementById('localization_14nm_2025').value),
                localization_14nm_2031: parseFloat(document.getElementById('localization_14nm_2031').value),
                localization_7nm_2025: parseFloat(document.getElementById('localization_7nm_2025').value),
                localization_7nm_2031: parseFloat(document.getElementById('localization_7nm_2031').value),
                // Survival rate parameters
                initial_hazard_rate_p50: parseFloat(document.getElementById('initial_hazard_rate_p50').value),
                increase_of_hazard_rate_per_year_p50: parseFloat(document.getElementById('increase_of_hazard_rate_per_year_p50').value),
                hazard_rate_p25_relative_to_p50: parseFloat(document.getElementById('hazard_rate_p25_relative_to_p50').value),
                hazard_rate_p75_relative_to_p50: parseFloat(document.getElementById('hazard_rate_p75_relative_to_p50').value),
                // Covert datacenter parameters
                max_proportion_of_PRC_energy_consumption: parseFloat(document.getElementById('max_proportion_of_PRC_energy_consumption').value),
                total_GW_of_PRC_energy_consumption: parseFloat(document.getElementById('total_GW_of_PRC_energy_consumption').value),
                construction_labor_per_MW_per_year: parseFloat(document.getElementById('construction_labor_per_MW_per_year').value),
                relative_sigma_construction_labor_per_MW_per_year: parseFloat(document.getElementById('relative_sigma_construction_labor_per_MW_per_year').value),
                operating_labor_per_MW: parseFloat(document.getElementById('operating_labor_per_MW').value),
                relative_sigma_operating_labor_per_MW: parseFloat(document.getElementById('relative_sigma_operating_labor_per_MW').value),
                mean_detection_time_of_covert_site_for_100_workers: parseFloat(document.getElementById('mean_detection_time_of_covert_site_for_100_workers').value),
                mean_detection_time_of_covert_site_for_1000_workers: parseFloat(document.getElementById('mean_detection_time_of_covert_site_for_1000_workers').value),
                variance_of_detection_time_given_num_workers: parseFloat(document.getElementById('variance_of_detection_time_given_num_workers').value)
            };
        }

        function plotTimeSeries(data) {
            const ts = data.time_series;

            // Better color scheme
            const probColor = '#5B8DBE'; // Muted blue
            const computeColor = '#9B7BB3'; // Purple

            // Create traces for individual simulations (show first 100 for performance)
            const individualsToShow = Math.min(100, ts.individual_us_probs.length);
            const individualUsProbs = ts.individual_us_probs.slice(0, individualsToShow).map((probs, idx) => ({
                x: ts.years,
                y: probs,
                type: 'scatter',
                mode: 'lines',
                line: { color: probColor, width: 0.8 },
                opacity: 0.08,
                showlegend: false,
                hoverinfo: 'skip'
            }));

            const individualH100e = ts.individual_h100e.slice(0, individualsToShow).map((h100e, idx) => ({
                x: ts.years,
                y: h100e,
                type: 'scatter',
                mode: 'lines',
                line: { color: computeColor, width: 0.8 },
                opacity: 0.08,
                showlegend: false,
                hoverinfo: 'skip',
                yaxis: 'y2'
            }));

            // Median and percentile traces
            const traces = [
                ...individualUsProbs,
                {
                    x: ts.years,
                    y: ts.us_prob_p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip'
                },
                {
                    x: ts.years,
                    y: ts.us_prob_p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: probColor + '30',
                    line: { color: 'transparent' },
                    name: '25th-75th %ile (Prob)',
                    hovertemplate: 'Prob: %{y:.3f}<extra></extra>'
                },
                {
                    x: ts.years,
                    y: ts.us_prob_median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: probColor, width: 3 },
                    name: 'Median US Prob',
                    hovertemplate: 'Prob: %{y:.3f}<extra></extra>'
                },
                ...individualH100e,
                {
                    x: ts.years,
                    y: ts.h100e_p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip',
                    yaxis: 'y2'
                },
                {
                    x: ts.years,
                    y: ts.h100e_p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: computeColor + '30',
                    line: { color: 'transparent' },
                    name: '25th-75th %ile (H100e)',
                    yaxis: 'y2',
                    hovertemplate: 'H100e: %{y:.1f}K<extra></extra>'
                },
                {
                    x: ts.years,
                    y: ts.h100e_median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: computeColor, width: 3 },
                    name: 'Median H100e',
                    yaxis: 'y2',
                    hovertemplate: 'H100e: %{y:.1f}K<extra></extra>'
                }
            ];

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 13 },
                    automargin: true
                },
                yaxis: {
                    title: 'US Probability of Covert Fab',
                    titlefont: { size: 13, color: '#000' },
                    tickfont: { size: 10, color: probColor },
                    range: [0, 1],
                    side: 'left',
                    automargin: true
                },
                yaxis2: {
                    title: 'H100e Produced by Fab (thousands)',
                    titlefont: { size: 13, color: '#000' },
                    tickfont: { size: 10, color: computeColor },
                    overlaying: 'y',
                    side: 'right',
                    range: [0, 5000],
                    automargin: true
                },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: -0.25,
                    xanchor: 'left',
                    yanchor: 'top',
                    orientation: 'h',
                    font: { size: 10 }
                },
                hovermode: 'x unified',
                margin: { l: 50, r: 50, t: 10, b: 85, pad: 10 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('timeSeriesPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('timeSeriesPlot'), 50);
        }

        function plotDatacenterCapacity(data) {
            const ts = data.time_series;

            // Color for datacenter capacity
            const datacenterColor = '#4CAF50'; // Green

            // Create traces for datacenter capacity with percentiles
            const traces = [
                {
                    x: ts.years,
                    y: ts.datacenter_capacity_p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip'
                },
                {
                    x: ts.years,
                    y: ts.datacenter_capacity_p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: datacenterColor + '30',
                    line: { color: 'transparent' },
                    name: '25th-75th %ile',
                    hovertemplate: 'Capacity: %{y:.1f} GW<extra></extra>'
                },
                {
                    x: ts.years,
                    y: ts.datacenter_capacity_median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: datacenterColor, width: 3 },
                    name: 'Median Capacity',
                    hovertemplate: 'Capacity: %{y:.1f} GW<extra></extra>'
                }
            ];

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 13 },
                    automargin: true
                },
                yaxis: {
                    title: 'Datacenter Capacity (GW)',
                    titlefont: { size: 13 },
                    tickfont: { size: 10 },
                    automargin: true
                },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: -0.25,
                    xanchor: 'left',
                    yanchor: 'top',
                    orientation: 'h',
                    font: { size: 10 }
                },
                hovermode: 'x unified',
                margin: { l: 50, r: 50, t: 10, b: 85, pad: 10 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('datacenterCapacityPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('datacenterCapacityPlot'), 50);
        }

        function plotComputeCcdf(data) {
            if (!data.compute_ccdfs) {
                document.getElementById('computeCcdfPlot').innerHTML = '<p>No detection data available</p>';
                return;
            }

            // Get prior probability from the input
            const priorProb = parseFloat(document.getElementById('p_fab_exists').value) || 0.1;
            const priorOdds = priorProb / (1 - priorProb);

            // Use likelihood ratios from backend
            const likelihoodRatios = data.likelihood_ratios || [1, 2, 5];
            const colors = ['#9B7BB3', '#5B8DBE', '#5AA89B'];  // Purple, Blue, Blue-green

            const traces = [];
            const thresholds = likelihoodRatios.map((lr, index) => {
                const posteriorOdds = priorOdds * lr;
                const posteriorProb = posteriorOdds / (1 + posteriorOdds);
                return {
                    value: posteriorProb,
                    label: `>${lr}x update`,
                    color: colors[index % colors.length]
                };
            });

            // Reverse thresholds for legend order (highest to lowest)
            const thresholdsReversed = [...thresholds].reverse();

            for (const threshold of thresholdsReversed) {
                const ccdf = data.compute_ccdfs[threshold.value];
                if (ccdf && ccdf.length > 0) {
                    traces.push({
                        x: ccdf.map(d => d.x),
                        y: ccdf.map(d => d.y),
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: threshold.color, width: 2 },
                        name: `"Detection" = ${threshold.label}`,
                        hovertemplate: 'H100e: %{x:.0f}<br>P(≥x): %{y:.3f}<extra></extra>'
                    });
                }
            }

            const layout = {
                xaxis: {
                    title: "H100e Produced by Covert Fab Before 'Detection'",
                    titlefont: { size: 13 },
                    tickfont: { size: 10 },
                    type: 'log',
                    automargin: true
                },
                yaxis: {
                    title: 'P(covert compute > x)',
                    titlefont: { size: 13 },
                    tickfont: { size: 10 },
                    range: [0, 1],
                    automargin: true
                },
                showlegend: true,
                legend: {
                    x: 0.98,
                    y: 0.98,
                    xanchor: 'right',
                    yanchor: 'top',
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ccc',
                    borderwidth: 1
                },
                hovermode: 'closest',
                margin: { l: 50, r: 50, t: 10, b: 65, pad: 10 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('computeCcdfPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('computeCcdfPlot'), 50);
        }

        function plotPDF(divId, values, color, xAxisLabel, nbins = 30, logScale = false, logMin = null, logMax = null, title = null) {
            // Create histogram/PDF from values
            console.log(`plotPDF called for ${divId}:`, values);
            console.log(`plotPDF ${divId} - min: ${Math.min(...values)}, max: ${Math.max(...values)}, count: ${values.length}`);

            const trace = {
                x: values,
                type: 'histogram',
                histnorm: 'probability density',
                marker: { color: color, line: { width: 0.5, color: 'white' } },
                hovertemplate: '%{x:.2f}<br>Density: %{y:.3f}<extra></extra>'
            };

            // For log scale, manually specify bin edges
            if (logScale) {
                // Use custom range if provided, otherwise default to 0.1 to 10
                const minVal = logMin !== null ? logMin : 0.1;
                const maxVal = logMax !== null ? logMax : 10;
                const numBins = 12;
                const logMinVal = Math.log10(minVal);
                const logMaxVal = Math.log10(maxVal);
                const binEdges = [];
                for (let i = 0; i <= numBins; i++) {
                    binEdges.push(Math.pow(10, logMinVal + i * (logMaxVal - logMinVal) / numBins));
                }

                // Manually bin the data
                const binCounts = new Array(binEdges.length - 1).fill(0);
                values.forEach(v => {
                    // Find which bin this value belongs to
                    let binned = false;
                    for (let i = 0; i < binEdges.length - 2; i++) {
                        if (v >= binEdges[i] && v < binEdges[i + 1]) {
                            binCounts[i]++;
                            binned = true;
                            break;
                        }
                    }
                    // Last bin captures all values >= second-to-last edge (making it a "+" bin)
                    if (!binned) {
                        binCounts[binCounts.length - 1]++;
                    }
                });

                // Calculate bin centers for plotting
                const binCenters = [];
                for (let i = 0; i < binEdges.length - 1; i++) {
                    binCenters.push((binEdges[i] + binEdges[i + 1]) / 2);
                }

                // Calculate probability mass (count / total) for better visualization with open-ended bins
                // Using probability instead of density makes the bar height proportional to the actual probability mass
                const probabilities = binCounts.map(count => count / values.length);

                console.log(`Bin edges: ${binEdges}`);
                console.log(`Bin counts: ${binCounts}`);
                console.log(`Probabilities: ${probabilities}`);

                // Create bar trace instead of histogram
                trace.type = 'bar';
                trace.x = binCenters;
                trace.y = probabilities;
                delete trace.histnorm;
                trace.width = binEdges.map((edge, i) => i < binEdges.length - 1 ? binEdges[i + 1] - binEdges[i] : 0).slice(0, -1);
                trace.hovertemplate = 'LR: %{x:.2f}<br>Probability: %{y:.3f}<extra></extra>';
            } else {
                trace.nbinsx = nbins;
            }

            const xaxisConfig = {
                title: xAxisLabel,
                titlefont: { size: 10 },
                automargin: true,
                tickfont: { size: 9 }
            };

            const yaxisConfig = {
                title: logScale ? 'Probability' : 'Density',
                titlefont: { size: 10 },
                tickfont: { size: 9 }
            };

            if (logScale) {
                xaxisConfig.type = 'log';
                // Manually specify tick values for better visibility
                // Use the actual max value from logMax parameter
                const maxTickVal = logMax !== null ? logMax : 10;
                const maxTickText = maxTickVal.toString() + '+';
                xaxisConfig.tickvals = [0.1, 0.2, 0.5, 1, 2, maxTickVal];
                xaxisConfig.ticktext = ['0.1', '0.2', '0.5', '1', '2', maxTickText];
                // Don't force range - let it adjust based on data
                xaxisConfig.autorange = true;
            }

            const layout = {
                xaxis: xaxisConfig,
                yaxis: {
                    ...yaxisConfig,
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 50, t: title ? 30 : 10, b: 55, pad: 10 },
                hovermode: 'closest'
            };

            if (title) {
                layout.title = {
                    text: `<b>${title}</b>`,
                    font: { size: 12 },
                    x: 0.5,
                    xanchor: 'center'
                };
            }

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotMedianWithPercentiles(divId, data, years, color, yAxisLabel = '', yAxisRange = null, logScale = false, showLegend = false) {
            // Plot median with 25th-75th percentile bands
            const traces = [];

            // Add individual simulation lines if provided
            if (data.individual) {
                const individualsToPlot = data.individual.slice(0, 100);
                for (let i = 0; i < individualsToPlot.length; i++) {
                    traces.push({
                        x: years,
                        y: individualsToPlot[i],
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: color, width: 0.5 },
                        opacity: 0.15,
                        showlegend: false,
                        hoverinfo: 'skip'
                    });
                }
            }

            // Add percentile bands
            traces.push(
                {
                    x: years,
                    y: data.p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: color, width: 1.5, dash: 'dot' },
                    opacity: 0.6,
                    showlegend: false,
                    hoverinfo: 'skip',
                    name: '25th percentile'
                },
                {
                    x: years,
                    y: data.p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: color + '60',
                    line: { color: color, width: 1.5, dash: 'dot' },
                    opacity: 0.7,
                    showlegend: showLegend,
                    hoverinfo: 'skip',
                    name: '25th-75th %ile'
                },
                {
                    x: years,
                    y: data.median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: color, width: 3 },
                    showlegend: showLegend,
                    hovertemplate: 'Year: %{x:.1f}<br>Value: %{y:.2f}<extra></extra>',
                    name: 'Median'
                }
            );

            const yaxisConfig = {
                title: yAxisLabel,
                titlefont: { size: 10 },
                tickfont: { size: 9 },
                automargin: true
            };

            // Add log scale if specified
            if (logScale) {
                yaxisConfig.type = 'log';
            }

            // Add range if specified
            if (yAxisRange !== null) {
                yaxisConfig.range = yAxisRange;
            }

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    range: [years[0] - 0.1, years[years.length - 1] + 0.1],
                    autorange: false,
                    fixedrange: true
                },
                yaxis: yaxisConfig,
                showlegend: showLegend,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    xanchor: 'left',
                    yanchor: 'top',
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ccc',
                    borderwidth: 1,
                    font: { size: 10 }
                },
                margin: { l: 50, r: 50, t: 10, b: 55, pad: 10 },
                hovermode: 'x'
            };

            Plotly.newPlot(divId, traces, layout, {displayModeBar: false, responsive: true});
            // Force resize after a small delay
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotBarByProcessNode(divId, values, processNodes, color) {
            // Group by process node and compute per wafer value
            const nodeValueCounts = {};
            values.forEach((v, idx) => {
                const rounded = Math.round(v * 1000) / 1000; // Round to 3 decimal places
                const node = processNodes[idx];
                const key = `${rounded}|${node}`;
                nodeValueCounts[key] = (nodeValueCounts[key] || 0) + 1;
            });

            // Parse and sort by value
            const entries = Object.entries(nodeValueCounts).map(([key, count]) => {
                const [value, node] = key.split('|');
                return { value: parseFloat(value), node, count };
            });
            entries.sort((a, b) => a.value - b.value);

            // Convert counts to proportions
            const totalCount = values.length;
            const labels = entries.map(e => `${e.value.toFixed(2)}x (${e.node})`);
            const proportions = entries.map(e => e.count / totalCount);

            const trace = {
                x: labels,
                y: proportions,
                type: 'bar',
                marker: {
                    color: color,
                    line: { width: 1, color: 'white' }
                },
                textposition: 'auto',
                hovertemplate: '%{x}<br>Probability: %{y:.3f}<extra></extra>'
            };

            const layout = {
                xaxis: {
                    title: '',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    type: 'category'
                },
                yaxis: {
                    title: 'Probability',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 50, t: 10, b: 65, pad: 10 },
                hovermode: 'closest',
                bargap: 0.2
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotProportionOperational(divId, data, years, color, yAxisLabel = '') {
            // Calculate proportion operational at each timestep
            const proportions = data.median; // This is already the proportion since we're averaging 0s and 1s

            const trace = {
                x: years,
                y: proportions,
                type: 'scatter',
                mode: 'lines',
                line: { color: color, width: 2 },
                fill: 'tozeroy',
                fillcolor: color + '20',
                hovertemplate: 'Year: %{x:.1f}<br>Proportion: %{y:.2f}<extra></extra>'
            };

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    range: [years[0] - 0.1, years[years.length - 1] + 0.1],
                    autorange: false,
                    fixedrange: true
                },
                yaxis: {
                    title: yAxisLabel,
                    range: [0, 1],
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 50, t: 10, b: 55, pad: 10 },
                hovermode: 'x'
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            // Force resize after a small delay
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotCategoricalFrequency(divId, values, categories, color) {
            // Count frequencies for each category
            const frequencies = categories.map(cat =>
                values.filter(v => v === cat.value).length
            );

            // Convert to proportions
            const total = values.length;
            const proportions = frequencies.map(f => f / total);

            const trace = {
                x: categories.map(cat => cat.label),
                y: proportions,
                type: 'bar',
                marker: {
                    color: color,
                    line: { width: 1, color: 'white' }
                },
                textposition: 'auto',
                hovertemplate: '%{x}<br>Probability: %{y:.3f}<extra></extra>'
            };

            const layout = {
                xaxis: {
                    title: '',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    type: 'category'
                },
                yaxis: {
                    title: 'Probability',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 50, t: 10, b: 65, pad: 10 },
                hovermode: 'closest',
                bargap: 0.2
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function updateDashboard(data) {
            // Find the 80th percentile simulation by H100e production
            const h100eValues = data.individual_h100e_before_detection || [];
            const timeValues = data.individual_time_before_detection || [];
            const nodeValues = data.individual_process_node || [];

            if (h100eValues.length > 0) {
                // Sort by H100e and find 80th percentile simulation
                const indexed = h100eValues.map((h100e, idx) => ({ h100e, idx }));
                indexed.sort((a, b) => a.h100e - b.h100e);
                const idx80 = Math.floor(indexed.length * 0.8);
                const sim80th = indexed[idx80];

                // Get all values from this same simulation
                const h100e80th = sim80th.h100e;
                const time80th = timeValues[sim80th.idx];
                const node80th = nodeValues[sim80th.idx];

                // Display H100e
                const rounded = Math.round(h100e80th / 100000) * 100000;
                if (rounded >= 1000000) {
                    document.getElementById('dashboard80thH100e').textContent =
                        `~${(rounded / 1000000).toFixed(1)}M H100e`;
                } else if (rounded >= 1000) {
                    document.getElementById('dashboard80thH100e').textContent =
                        `~${(rounded / 1000).toFixed(0)}K H100e`;
                } else {
                    document.getElementById('dashboard80thH100e').textContent =
                        `~${rounded.toFixed(0)} H100e`;
                }

                // Display time
                document.getElementById('dashboard80thTime').textContent = time80th.toFixed(1);

                // Display process node
                document.getElementById('dashboard80thNode').textContent = node80th;

                // Update detection label with highest LR value
                const likelihoodRatios = data.likelihood_ratios || [1, 3, 5];
                const highestLR = likelihoodRatios[likelihoodRatios.length - 1];
                document.getElementById('dashboardDetectionLabel').textContent =
                    `Detection = US estimates covert fab has ≥${highestLR}x higher odds than previously thought`;
            }
        }

        async function runSimulation() {
            runButton.disabled = true;
            loadingDiv.classList.add('active');
            plotsDiv.style.display = 'none';
            setStatus('Running simulation...', 'info');

            try {
                const params = getParameters();
                const response = await fetch('/run_simulation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    throw new Error('Simulation failed');
                }

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                // Update dashboard
                updateDashboard(data);

                // Plot dark compute equation section
                console.log('Plotting dark compute equation section...');

                // Plot 1: Initial dark compute (histogram)
                if (data.initial_compute_stock_samples) {
                    // Convert to thousands
                    const samplesInThousands = data.initial_compute_stock_samples.map(v => v / 1000);
                    plotPDF('initialDarkComputePlot', samplesInThousands, '#9B72B0', 'Thousands of H100 Equivalents', 30, false, null, null);
                }

                // Plot 2: Flow from covert fab (line plot - cumulative production over time)
                if (data.time_series) {
                    const years = data.time_series.years;
                    const h100e_median = data.time_series.h100e_median;
                    const h100e_p25 = data.time_series.h100e_p25;
                    const h100e_p75 = data.time_series.h100e_p75;

                    // Create traces for the shaded region and median line
                    const traces = [
                        // Upper bound of shaded region (invisible line)
                        {
                            x: years,
                            y: h100e_p75,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Lower bound with fill to previous trace
                        {
                            x: years,
                            y: h100e_p25,
                            type: 'scatter',
                            mode: 'lines',
                            fill: 'tonexty',
                            fillcolor: 'rgba(155, 114, 176, 0.2)',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Median line
                        {
                            x: years,
                            y: h100e_median,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: '#9B72B0', width: 2 },
                            name: 'covert fab production',
                            showlegend: true
                        }
                    ];

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 }
                        },
                        yaxis: {
                            title: 'H100e (thousands)',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 }
                        },
                        margin: { l: 50, r: 20, t: 35, b: 40 },
                        height: 250,
                        hovermode: 'x unified',
                        legend: {
                            x: 0.5,
                            y: 1.0,
                            xanchor: 'center',
                            yanchor: 'bottom',
                            orientation: 'h',
                            font: { size: 10 }
                        },
                        showlegend: true
                    };

                    Plotly.newPlot('covertFabFlowPlot', traces, layout, {responsive: true});
                }

                // Plot 3: Average compute survival rate
                if (data.time_series) {
                    const years = data.time_series.years;
                    const survival_rate_median = data.time_series.survival_rate_median;
                    const survival_rate_p25 = data.time_series.survival_rate_p25;
                    const survival_rate_p75 = data.time_series.survival_rate_p75;

                    const traces = [
                        // Upper bound of shaded region (invisible line)
                        {
                            x: years,
                            y: survival_rate_p75,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Lower bound with fill to previous trace
                        {
                            x: years,
                            y: survival_rate_p25,
                            type: 'scatter',
                            mode: 'lines',
                            fill: 'tonexty',
                            fillcolor: 'rgba(76, 175, 80, 0.2)',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Median line
                        {
                            x: years,
                            y: survival_rate_median,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: '#4CAF50', width: 2 },
                            name: 'Median',
                            showlegend: false
                        }
                    ];

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 }
                        },
                        yaxis: {
                            title: 'Survival Rate',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 },
                            range: [0, 1]
                        },
                        margin: { l: 50, r: 20, t: 10, b: 40 },
                        height: 250,
                        hovermode: 'x unified'
                    };

                    Plotly.newPlot('chipSurvivalPlot', traces, layout, {responsive: true});
                }

                // Plot 4: Total dark compute (operational)
                if (data.time_series) {
                    const years = data.time_series.years;
                    const operational_median = data.time_series.operational_dark_compute_median;
                    const operational_p25 = data.time_series.operational_dark_compute_p25;
                    const operational_p75 = data.time_series.operational_dark_compute_p75;

                    const traces = [
                        // Upper bound of shaded region (invisible line)
                        {
                            x: years,
                            y: operational_p75,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Lower bound with fill to previous trace
                        {
                            x: years,
                            y: operational_p25,
                            type: 'scatter',
                            mode: 'lines',
                            fill: 'tonexty',
                            fillcolor: 'rgba(33, 150, 243, 0.2)',
                            line: { color: 'transparent' },
                            showlegend: false,
                            hoverinfo: 'skip'
                        },
                        // Median line
                        {
                            x: years,
                            y: operational_median,
                            type: 'scatter',
                            mode: 'lines',
                            line: { color: '#2196F3', width: 2 },
                            name: 'Median',
                            showlegend: false
                        }
                    ];

                    const layout = {
                        xaxis: {
                            title: 'Year',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 }
                        },
                        yaxis: {
                            title: 'H100e (thousands)',
                            titlefont: { size: 10 },
                            tickfont: { size: 9 }
                        },
                        margin: { l: 50, r: 20, t: 10, b: 40 },
                        height: 250,
                        hovermode: 'x unified'
                    };

                    Plotly.newPlot('totalDarkComputePlot', traces, layout, {responsive: true});
                }

                // Plot detection probability bar chart and initial compute stock histogram
                if (data.initial_dark_compute_detection_probs && data.initial_compute_stock_samples) {
                    console.log('Plotting detection probability bar chart and initial compute stock...');

                    // Update dashboard with median values
                    const sortedDarkCompute = [...data.initial_compute_stock_samples].sort((a, b) => a - b);
                    const medianDarkCompute = sortedDarkCompute[Math.floor(sortedDarkCompute.length / 2)];
                    const medianInMillions = (medianDarkCompute / 1e6).toFixed(2);
                    document.getElementById('dashboardMedianDarkCompute').textContent = medianInMillions + ' M H100e';

                    // Display probability of detection (P(LR ≥ 5x))
                    if (data.initial_dark_compute_detection_probs && data.initial_dark_compute_detection_probs['5x'] !== undefined) {
                        const probDetection = data.initial_dark_compute_detection_probs['5x'];
                        document.getElementById('dashboardMedianLR').textContent = (probDetection * 100).toFixed(1) + '%';
                    }

                    // Bar chart for detection probabilities
                    const likelihoodRatios = data.likelihood_ratios || [1, 3, 5];
                    const colors = ['#9B7BB3', '#5B8DBE', '#5AA89B'];  // Purple, Blue, Blue-green
                    const detectionProbs = likelihoodRatios.map((lr, idx) => ({
                        lr: lr,
                        prob: data.initial_dark_compute_detection_probs[`${lr}x`] || 0,
                        color: colors[idx]
                    }));

                    const barTrace = {
                        x: detectionProbs.map(d => `Detection means<br>≥${d.lr}x LR`),
                        y: detectionProbs.map(d => d.prob),
                        type: 'bar',
                        marker: {
                            color: detectionProbs.map(d => d.color)
                        },
                        hovertemplate: 'P(LR ≥ %{x}): %{y:.2%}<extra></extra>'
                    };

                    const barLayout = {
                        xaxis: {
                            title: 'Probability of detection',
                            titlefont: { size: 11 },
                            tickfont: { size: 9 }
                        },
                        yaxis: {
                            title: 'P(Detection)',
                            titlefont: { size: 11 },
                            tickfont: { size: 10 },
                            range: [0, 1],
                            tickformat: '.0%'
                        },
                        showlegend: false,
                        margin: { l: 55, r: 10, t: 10, b: 45 },
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        plot_bgcolor: 'rgba(0,0,0,0)'
                    };

                    Plotly.newPlot('initialDarkComputeDetectionPlot', [barTrace], barLayout, {displayModeBar: false, responsive: true});

                    // Histogram for initial compute stock
                    plotPDF('initialComputeStockPlot', data.initial_compute_stock_samples, '#9B72B0', 'PRC Dark Compute Stock (H100e)', 30, false);
                } else {
                    console.log('No detection probability or compute stock data available');
                }

                // Plot LR breakdown histograms for initial compute reporting
                if (data.lr_prc_accounting_samples && data.lr_global_accounting_samples && data.lr_combined_samples) {
                    console.log('Plotting LR breakdown histograms...');
                    // Use log scale with range 1/3 to 5, and blue color #5B8DBE
                    plotPDF('lrPrcAccountingPlot', data.lr_prc_accounting_samples, '#5B8DBE', 'Likelihood Ratio from PRC Accounting', 12, true, 1/3, 5);
                    plotPDF('lrGlobalAccountingPlot', data.lr_global_accounting_samples, '#5B8DBE', 'Likelihood Ratio from Global Production Accounting', 12, true, 1/3, 5);
                    plotPDF('lrCombinedPlot', data.lr_combined_samples, '#5B8DBE', 'Combined LR', 12, true, 1/3, 5);
                } else {
                    console.log('No LR samples in data');
                }

                // Plot initial dark compute stock breakdown
                if (data.initial_prc_stock_samples && data.diversion_proportion && data.initial_compute_stock_samples) {
                    console.log('Plotting initial dark compute stock breakdown...');

                    // Plot initial PRC stock distribution - purple color #9B72B0
                    plotPDF('initialPrcStockPlot', data.initial_prc_stock_samples, '#9B72B0', 'Initial PRC Compute Stock (H100e)', 30, false);

                    // Display the diversion proportion
                    const diversionPercent = (data.diversion_proportion * 100).toFixed(0);
                    document.getElementById('diversionProportionDisplay').textContent = diversionPercent + '%';

                    // Plot the resulting dark compute stock - purple color #9B72B0
                    plotPDF('darkComputeResultPlot', data.initial_compute_stock_samples, '#9B72B0', 'Dark Compute Stock (H100e)', 30, false);
                } else {
                    console.log('No initial dark compute stock breakdown data available');
                }

                // Plot main charts
                plotTimeSeries(data);
                plotComputeCcdf(data);
                plotDatacenterCapacity(data);

                // Force resize after a brief delay to ensure plots fill containers
                setTimeout(() => {
                    Plotly.Plots.resize('initialDarkComputePlot');
                    Plotly.Plots.resize('covertFabFlowPlot');
                    Plotly.Plots.resize('chipSurvivalPlot');
                    Plotly.Plots.resize('totalDarkComputePlot');
                    Plotly.Plots.resize('initialDarkComputeDetectionPlot');
                    Plotly.Plots.resize('initialComputeStockPlot');
                    Plotly.Plots.resize('lrPrcAccountingPlot');
                    Plotly.Plots.resize('lrGlobalAccountingPlot');
                    Plotly.Plots.resize('lrCombinedPlot');
                    Plotly.Plots.resize('initialPrcStockPlot');
                    Plotly.Plots.resize('darkComputeResultPlot');
                    Plotly.Plots.resize('timeSeriesPlot');
                    Plotly.Plots.resize('computeCcdfPlot');
                }, 100);

                // Plot LR breakdown
                if (data.lr_components && data.lr_components.inventory_median) {
                    const years = data.time_series.years;

                    // Get prior probability from parameters and calculate prior odds
                    const priorProb = getParameters().p_fab_exists;
                    const priorOdds = priorProb / (1 - priorProb);

                    // Display prior odds
                    document.getElementById('priorOddsDisplay').innerHTML =
                        `<div style="font-size: 28px; font-weight: bold; color: #555;">${priorOdds.toFixed(3)}</div>`;

                    // LR Inventory - PDF of values across simulations at final timestep
                    const lrInventoryFinal = data.lr_components.inventory_individual.map(sim => sim[sim.length - 1]);
                    console.log('LR Inventory values:', lrInventoryFinal);
                    console.log('LR Inventory length:', lrInventoryFinal.length);
                    console.log('LR Inventory min:', Math.min(...lrInventoryFinal), 'max:', Math.max(...lrInventoryFinal));
                    console.log('Values below 1:', lrInventoryFinal.filter(v => v < 1));
                    console.log('Values at or above 1:', lrInventoryFinal.filter(v => v >= 1));
                    // Use log scale x-axis but show actual LR values (not log values)
                    plotPDF('lrInventoryPlot', lrInventoryFinal, '#D97676', 'Likelihood Ratio', 10, true);

                    // LR Procurement - Categorical bar plot (1 or 10)
                    const lrProcurementFinal = data.lr_components.procurement_individual.map(sim => sim[sim.length - 1]);
                    plotCategoricalFrequency('lrProcurementPlot', lrProcurementFinal, [
                        { value: 1, label: 'Likelihood Ratio = 1<br>(>90% localization)' },
                        { value: 10, label: 'Likelihood Ratio = 10<br>(≤90% localization)' }
                    ], '#6B9BD1');

                    // LR Other - Median over time with percentiles
                    const lrOtherArray = data.lr_components.other_individual.map(sim => sim.map(v => v));
                    const lrOtherP25 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const lrOtherP75 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });
                    plotMedianWithPercentiles('lrOtherPlot', {
                        median: data.lr_components.other_median,
                        p25: lrOtherP25,
                        p75: lrOtherP75,
                        individual: data.lr_components.other_individual
                    }, years, '#7CAE7A', 'Likelihood Ratio', null, true);

                    // Use the same US probability data as Simulation Runs plot
                    // This includes ALL simulations (with and without fabs)
                    plotMedianWithPercentiles('posteriorProbPlot', {
                        median: data.time_series.us_prob_median,
                        p25: data.time_series.us_prob_p25,
                        p75: data.time_series.us_prob_p75,
                        individual: data.time_series.individual_us_probs
                    }, data.time_series.years, '#5B8DBE', 'Posterior Probability');
                }

                // Plot compute breakdown
                if (data.compute_factors && data.compute_factors.is_operational_median) {
                    const years = data.time_series.years;

                    // Proportion Operational - time series showing proportion
                    plotProportionOperational('isOperationalPlot', {
                        median: data.compute_factors.is_operational_median
                    }, years, '#D4A574', 'Probability');

                    // Wafer Starts per Month - PDF
                    const waferStartsFinal = data.compute_factors.wafer_starts_individual.map(sim => sim[sim.length - 1]);
                    plotPDF('waferStartsPlot', waferStartsFinal, '#74B3A8', 'Wafers/Month');

                    // H100-sized Chips per Wafer - Display as a box (constant value)
                    const chipsPerWaferValue = data.compute_factors.chips_per_wafer_individual[0][0]; // Same for all sims
                    document.getElementById('chipsPerWaferPlot').innerHTML = `<div style="display: flex; align-items: center; justify-content: center; font-size: 32px; font-weight: bold; color: #555; height: 100%; width: 100%;">${chipsPerWaferValue.toFixed(0)}</div>`;

                    // Transistor density relative to H100 - Bar plot at final timestep
                    const transistorDensityFinal = data.compute_factors.transistor_density_individual.map(sim => sim[sim.length - 1]);
                    const processNodes = data.compute_factors.process_node_by_sim;
                    plotBarByProcessNode('computePerChipPlot', transistorDensityFinal, processNodes, '#E8A863');

                    // Architecture Efficiency - Display as a box (constant value at agreement year)
                    const archEffValue = data.architecture_efficiency_at_agreement;
                    document.getElementById('architectureEfficiencyDisplay').innerHTML = `<div style="font-size: 28px; font-weight: bold; color: #555;">${archEffValue.toFixed(2)}</div>`;

                    // Total compute - time series over all timesteps
                    const totalComputeArray = data.compute_factors.is_operational_individual.map((opSim, simIdx) => {
                        return opSim.map((isOp, timeIdx) => {
                            return (isOp * data.compute_factors.wafer_starts_individual[simIdx][timeIdx] *
                                    data.compute_factors.architecture_efficiency_individual[simIdx][timeIdx] *
                                    data.compute_factors.compute_per_wafer_2022_arch_individual[simIdx][timeIdx]);
                        });
                    });

                    // Calculate median and percentiles for total compute
                    const totalComputeMedian = years.map((_, i) => {
                        const values = totalComputeArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.5)];
                    });
                    const totalComputeP25 = years.map((_, i) => {
                        const values = totalComputeArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const totalComputeP75 = years.map((_, i) => {
                        const values = totalComputeArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });

                    // Calculate y-axis maximum as 1.2 times the maximum 75th percentile value
                    const maxP75 = Math.max(...totalComputeP75);
                    const yMax = maxP75 * 1.2;

                    plotMedianWithPercentiles('totalComputePlot', {
                        median: totalComputeMedian,
                        p25: totalComputeP25,
                        p75: totalComputeP75,
                        individual: totalComputeArray
                    }, years, '#9B7BB3', 'H100e/Month', [0, yMax], false, true);
                }

                // Check if project is running
                const runCovertProject = document.getElementById('run_covert_project').checked;
                const buildCovertFab = document.getElementById('build_covert_fab').checked;
                const projectNotRunDiv = document.getElementById('projectNotRun');
                const plotsContentDiv = document.getElementById('plotsContent');

                if (runCovertProject && buildCovertFab) {
                    // Show normal plots
                    projectNotRunDiv.style.display = 'none';
                    plotsContentDiv.style.display = 'block';
                } else {
                    // Show "project not run" message
                    projectNotRunDiv.style.display = 'block';
                    plotsContentDiv.style.display = 'none';
                }

                plotsDiv.style.display = 'block';
                loadingDiv.classList.remove('active');
                setStatus(`Simulation complete! Ran ${data.num_simulations} simulations`, 'success');
            } catch (error) {
                loadingDiv.classList.remove('active');
                setStatus('Error: ' + error.message, 'error');
            } finally {
                runButton.disabled = false;
            }
        }

        runButton.addEventListener('click', runSimulation);

        // Run simulation automatically on page load
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(runSimulation, 500); // Small delay to ensure page is fully loaded
        });

        // Add Enter key listener to all input fields and select elements in sidebar
        const sidebarInputs = document.querySelectorAll('.sidebar input, .sidebar select');
        sidebarInputs.forEach(input => {
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    runSimulation();
                }
            });
        });

        // Setup tooltip handlers
        const globalTooltip = document.getElementById('globalTooltip');
        const tooltipElements = document.querySelectorAll('.has-tooltip');

        let hideTooltipTimeout;
        let currentTooltipElement = null;

        function hideTooltip() {
            globalTooltip.classList.remove('visible');
            globalTooltip.style.opacity = '0';
            currentTooltipElement = null;
        }

        function isMouseOverElementOrTooltip(mouseEvent) {
            // Check if mouse is over the current tooltip element
            if (currentTooltipElement && currentTooltipElement.matches(':hover')) {
                return true;
            }
            // Check if mouse is over the tooltip itself
            if (globalTooltip.matches(':hover')) {
                return true;
            }
            return false;
        }

        tooltipElements.forEach(element => {
            element.addEventListener('mouseenter', (e) => {
                clearTimeout(hideTooltipTimeout);
                currentTooltipElement = element;
                const tooltipText = element.getAttribute('data-tooltip');
                const downloadUrl = element.getAttribute('data-download');
                const imageUrl = element.getAttribute('data-image');
                const imageBeforeText = element.getAttribute('data-image-before-text');
                const imageAfterText = element.getAttribute('data-image-after-text');

                if (tooltipText) {
                    // Add the tooltip text
                    let content = tooltipText;

                    // Add image if data-image attribute exists
                    if (imageUrl) {
                        if (imageBeforeText) {
                            // Insert image before the specified text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageBeforeText}`;
                        } else if (imageAfterText) {
                            // Insert image after the tooltip text, then add the after text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageAfterText}`;
                        } else {
                            // Default: add image after tooltip text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px;" alt="Capabilities table">`;
                        }
                    }

                    // Add download button only if data-download attribute exists
                    if (downloadUrl) {
                        const fileName = downloadUrl.split('/').pop() + '.csv';
                        content += `<br><br><button onclick='window.location.href="${downloadUrl}"' style='margin-top: 8px; padding: 6px 12px; background-color: #555; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; pointer-events: auto;'>Download ${fileName}</button>`;
                    }

                    globalTooltip.innerHTML = content;

                    // Get the position of the element
                    const rect = element.getBoundingClientRect();

                    // Position tooltip to the right of the element
                    globalTooltip.style.left = (rect.right + 10) + 'px';

                    // Calculate vertical position to keep tooltip within viewport
                    let topPosition = rect.top;

                    // Show tooltip temporarily to measure its height
                    globalTooltip.style.visibility = 'hidden';
                    globalTooltip.style.opacity = '1';
                    globalTooltip.classList.add('visible');

                    const tooltipHeight = globalTooltip.offsetHeight;
                    const viewportHeight = window.innerHeight;

                    // If tooltip would go off bottom of screen, adjust position
                    if (topPosition + tooltipHeight > viewportHeight) {
                        topPosition = Math.max(10, viewportHeight - tooltipHeight - 10);
                    }

                    // If tooltip would go off top of screen, adjust position
                    if (topPosition < 10) {
                        topPosition = 10;
                    }

                    globalTooltip.style.top = topPosition + 'px';

                    // Now show tooltip properly
                    globalTooltip.style.visibility = 'visible';
                }
            });

            element.addEventListener('mouseleave', (e) => {
                // Give a short delay to allow mouse to move to tooltip
                hideTooltipTimeout = setTimeout(() => {
                    // Only hide if mouse is not over the element or tooltip
                    if (!isMouseOverElementOrTooltip(e)) {
                        hideTooltip();
                    }
                }, 100);
            });
        });

        // Keep tooltip visible when hovering over it
        globalTooltip.addEventListener('mouseenter', () => {
            clearTimeout(hideTooltipTimeout);
        });

        globalTooltip.addEventListener('mouseleave', () => {
            // Check if we're moving back to the original element
            hideTooltipTimeout = setTimeout(() => {
                if (!isMouseOverElementOrTooltip(event)) {
                    hideTooltip();
                }
            }, 100);
        });

        // Make breakdown plots clickable and link to sidebar inputs
        const plotToInputMapping = {
            // Section 2: US Bayesian Inference plots
            'priorOddsDisplay': 'p_fab_exists',
            'lrInventoryPlot': 'proportion_diverted_sme', // Median absolute relative error of US intelligence estimate of PRC SME stock
            'lrProcurementPlot': 'localization_130nm_2025', // Probability PRC achieves >90% indigenization
            'lrOtherPlot': 'mean_detection_time_100', // Detection time
            'posteriorProbPlot': null, // Output, not an input

            // Section 3: Compute Production Rate plots
            'isOperationalPlot': 'construction_time_5k', // First construction time param
            'waferStartsPlot': 'wafers_per_month_per_worker', // Operating labor productivity
            'chipsPerWaferPlot': 'chips_per_wafer',
            'computePerChipPlot': 'transistor_density_exponent',
            'architectureEfficiencyDisplay': 'architecture_efficiency',
            'totalComputePlot': null // Output, not an input
        };

        // Add clickable class and click handlers to plots with associated inputs
        Object.entries(plotToInputMapping).forEach(([plotId, inputId]) => {
            const plotElement = document.getElementById(plotId);
            if (plotElement && inputId) {
                plotElement.classList.add('clickable');
                plotElement.addEventListener('click', () => {
                    const inputElement = document.getElementById(inputId);
                    if (inputElement) {
                        // Scroll input into view
                        inputElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Focus and select the input
                        setTimeout(() => {
                            inputElement.focus();
                            inputElement.select();
                        }, 300);
                    }
                });
            }
        });
    </script>
</body>
</html>
