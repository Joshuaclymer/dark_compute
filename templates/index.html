<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Covert Compute Production Model</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 350px;
            background-color: #f5f5f5;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #ddd;
        }

        .sidebar h1 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #333;
        }

        .sidebar h2 {
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #555;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }

        .param-group {
            margin-bottom: 15px;
        }

        .param-group label {
            display: block;
            font-size: 13px;
            margin-bottom: 5px;
            color: #666;
        }

        .param-group input,
        .param-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .param-group input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }

        .localization-row {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .localization-row .param-group {
            flex: 1;
            margin-bottom: 0;
        }

        .localization-row label {
            font-size: 11px;
        }

        .localization-row input {
            padding: 6px;
        }

        .param-group.has-tooltip {
            position: relative;
        }

        #globalTooltip {
            position: fixed;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            background-color: #333;
            color: #fff;
            text-align: left;
            padding: 15px;
            border-radius: 6px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            pointer-events: none;
            visibility: hidden;
        }

        #globalTooltip.visible {
            pointer-events: auto;
        }

        #globalTooltip * {
            color: #fff !important;
        }

        /* Force Plotly hover labels to use white text */
        .hoverlayer .hovertext path {
            fill: #333 !important;
        }

        .hoverlayer .hovertext text {
            fill: #fff !important;
        }

        g.hovertext path {
            fill: #333 !important;
        }

        g.hovertext text {
            fill: #fff !important;
        }

        #globalTooltip::before {
            content: "";
            position: absolute;
            top: 20px;
            left: -8px;
            border-width: 8px;
            border-style: solid;
            border-color: transparent #333 transparent transparent;
        }

        #globalTooltip.visible {
            visibility: visible;
            opacity: 1;
        }

        button {
            width: 100%;
            padding: 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            margin-top: 20px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px 20px 20px 20px;
            overflow-y: auto;
        }

        .top-plots {
            display: grid;
            grid-template-columns: 250px 1fr 1fr;
            gap: 20px;
            margin-bottom: 10px;
            width: 100%;
        }

        .dashboard {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .dashboard-item {
            text-align: center;
        }

        .dashboard-value {
            font-size: 32px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .dashboard-label {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 3px;
            line-height: 1.3;
        }

        .dashboard-sublabel {
            font-size: 10px;
            color: #777;
            line-height: 1.3;
        }

        .plot-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            min-width: 0; /* Allows grid items to shrink below content size */
            overflow: hidden;
        }

        .plot-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .plot {
            width: 100% !important;
            max-width: 100% !important;
            height: 364px;
        }

        .plot > div {
            width: 100% !important;
            max-width: 100% !important;
        }

        .breakdown-section {
            margin-top: 30px;
            padding: 15px 10px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .breakdown-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }

        .breakdown-grid {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 20px;
            max-width: 100%;
            width: 100%;
        }

        .breakdown-item {
            text-align: center;
            min-width: 0;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .breakdown-plot {
            height: 240px;
            width: 100%;
            max-width: 100%;
            flex: 1;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            transition: all 0.2s ease;
        }

        .breakdown-plot.clickable {
            cursor: pointer;
        }

        .breakdown-plot.clickable:hover {
            border-color: #007bff;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.3);
            transform: scale(1.02);
        }

        .breakdown-plot > div {
            width: 100% !important;
            max-width: 100% !important;
        }

        .breakdown-label {
            font-size: 11px;
            font-weight: bold;
            margin-top: 5px;
            color: #555;
            line-height: 1.2;
        }

        .operator {
            font-size: 24px;
            font-weight: bold;
            color: #666;
            padding: 0 3px;
            flex: 0 0 auto;
        }

        .status {
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-size: 13px;
        }

        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .status.success {
            background-color: #d4edda;
            color: #155724;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .section-description {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- Global tooltip (outside sidebar to avoid clipping) -->
    <div id="globalTooltip"></div>

    <div class="sidebar">
        <h1>Model Parameters</h1>

        <button id="runSimulation">Run Simulation</button>

        <div id="status"></div>

        <h2>Simulation Settings</h2>
        <div class="param-group">
            <label for="agreement_year">Agreement start year</label>
            <input type="number" id="agreement_year" value="2030" step="0.1">
        </div>
        <div class="param-group">
            <label for="end_year">End year</label>
            <input type="number" id="end_year" value="2037" step="0.1">
        </div>
        <div class="param-group">
            <label for="increment">Time increment (years)</label>
            <input type="number" id="increment" value="0.1" step="0.01">
        </div>
        <div class="param-group">
            <label for="num_simulations">Number of simulations</label>
            <input type="number" id="num_simulations" value="300" min="1" max="10000">
        </div>

        <h2>PRC Strategy</h2>
        <div class="param-group">
            <label>
                <input type="checkbox" id="run_covert_project" checked>
                Run covert project
            </label>
        </div>
        <div class="param-group">
            <label>
                <input type="checkbox" id="build_covert_fab" checked>
                Build covert fab
            </label>
        </div>
        <div class="param-group">
            <label for="operating_labor">Number of workers to operate fab</label>
            <input type="number" id="operating_labor" value="728">
        </div>
        <div class="param-group">
            <label for="construction_labor">Number of workers to construct fab</label>
            <input type="number" id="construction_labor" value="448">
        </div>
        <div class="param-group">
            <label for="process_node">Process node</label>
            <select id="process_node">
                <option value="best_available_indigenously">Best Available Indigenously</option>
                <option value="nm130">130nm</option>
                <option value="nm28">28nm</option>
                <option value="nm14">14nm</option>
                <option value="nm7">7nm</option>
            </select>
        </div>
        <div class="param-group">
            <label for="scanner_proportion">Proportion of prc sme diverted to covert fab at start of the agreement</label>
            <input type="number" id="scanner_proportion" value="0.1" step="0.001">
        </div>

        <h2>Fab Model Parameters</h2>

        <h3 style="font-size: 14px; margin-top: 15px; color: #777;">Odds of Covert Project</h3>
        <div class="param-group">
            <label for="p_fab_exists">US prior probability that covert fab exists</label>
            <input type="number" id="p_fab_exists" value="0.1" step="0.01" min="0" max="1">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>SME Inventory Accounting Detection</strong><br><br><strong>Detection Method:</strong><br>Even if the PRC manufactures SME domestically, US intelligence could detect a covert fab by noticing that equipment is missing from China's domestic semiconductor industry. The SME supply chain is complex (e.g., ASML has 5000+ suppliers), making it difficult to hide equipment diversions.<br><br><strong>Diversion Strategy:</strong><br>The PRC might divert SME in advance—during the 6-12 months when an agreement is being negotiated—before the domestic industry is closely monitored. They could move equipment to a secret location and cover up evidence it existed.<br><br><strong>Key Factors:</strong><br>• <strong>Amount diverted:</strong> Diverting 80% of scanners would be obvious; diverting a few might go unnoticed<br>• <strong>US intelligence uncertainty:</strong> How wide are US error bars on how much SME Chinese companies had before they could have diverted it to a covert fab?<br><br><strong>Historical Calibration:</strong><br>Historical intelligence estimates of weapon counts (tanks, nuclear warheads, etc.) provide an analogy for tracking SME. See attached data file and plot showing error bars from declassified intelligence documents (1960-2025)." data-download="/download/us_intelligence_estimates" data-image-before-text="Data suggests:<br>• Median error in weapon count estimates: ~15%<br>• At 14% diverted SME: 50% chance of detection via inventory accounting<br>• At higher diversion rates, detection becomes increasingly likely<br><br>This parameter represents the proportion of indigenous SME that must be diverted to trigger a 50% probability that US intelligence becomes suspicious due to inventory discrepancies." data-image="/static/intelligence_error_bars/error_bars_plot.png">
            <label for="proportion_diverted_sme">US intelligence estimates 50% chance of covert fab at what proportion of sme diverted</label>
            <input type="number" id="proportion_diverted_sme" value="0.14" step="0.01">
        </div>
        <div class="has-tooltip" style="margin-top: 15px; margin-bottom: 5px; font-size: 13px; color: #666; cursor: help;" data-tooltip="<strong>PRC Semiconductor Manufacturing Equipment (SME) Indigenization</strong><br><br><strong>Why Indigenization Matters for Covert Fabs:</strong><br>The SME market involves very few buyers and sellers globally. If equipment goes missing or can't be accounted for in international supply chains, there are only a handful of actors that could be hiding it—and the PRC would be a highly salient suspect. Therefore, a covert PRC fab would likely need to rely primarily on domestically-produced equipment to avoid detection through procurement accounting.<br><br>These parameters represent the probability that the PRC achieves >90% domestic sourcing of SME at each process node by the specified year. See the attached data file for detailed capabilities by equipment category and process node." data-image-after-text="<strong>Current Status (2025):</strong><br>The PRC can manufacture 130nm chips with mostly domestic tools (~80% localized). More advanced nodes require imported equipment, particularly photolithography scanners.<br><br><strong>Near-Term Progress (by 2031):</strong><br>• <strong>28nm:</strong> SMEE and Huawei-linked Yuliangsheng are developing DUV immersion scanners for 28nm. SMIC plans production integration by 2027. Given typical delays between prototype and production-ready equipment, there's ~25% chance of >90% localization by 2031.<br>• <strong>14nm & 7nm:</strong> Multi-patterning techniques could enable 28nm scanners to reach these nodes, but this requires years of additional development. Lower probability of high localization by 2031 (10% for 14nm, 6% for 7nm).<br><br><strong>Key Accelerants:</strong><br>• U.S. export controls driving indigenization urgency<br>• $47.5B Chinese government SME fund<br>• Aggressive talent recruitment (Huawei recruiting from ASML at 3x salary)<br>• Huawei's ¥12B R&D park with 35,000+ employees<br><br>The main bottleneck is talent (experienced engineers), not funding. Recent investments may start paying off by 2031, but the probability decreases significantly for more advanced nodes." data-image="/static/china_domestic_fab_capability/china_capabilities_table.png" data-download="/download/prc_indigenous_sme_capabilities">
            Probability PRC achieves >90% indiginization at node
        </div>
        <div class="localization-row">
            <div class="param-group">
                <label for="localization_130nm_2025">130nm 2025</label>
                <input type="number" id="localization_130nm_2025" value="0.80" step="0.01" min="0" max="1">
            </div>
            <div class="param-group">
                <label for="localization_130nm_2031">130nm 2031</label>
                <input type="number" id="localization_130nm_2031" value="0.80" step="0.01" min="0" max="1">
            </div>
        </div>
        <div class="localization-row">
            <div class="param-group">
                <label for="localization_28nm_2025">28nm 2025</label>
                <input type="number" id="localization_28nm_2025" value="0.0" step="0.01" min="0" max="1">
            </div>
            <div class="param-group">
                <label for="localization_28nm_2031">28nm 2031</label>
                <input type="number" id="localization_28nm_2031" value="0.25" step="0.01" min="0" max="1">
            </div>
        </div>
        <div class="localization-row">
            <div class="param-group">
                <label for="localization_14nm_2025">14nm 2025</label>
                <input type="number" id="localization_14nm_2025" value="0.0" step="0.01" min="0" max="1">
            </div>
            <div class="param-group">
                <label for="localization_14nm_2031">14nm 2031</label>
                <input type="number" id="localization_14nm_2031" value="0.10" step="0.01" min="0" max="1">
            </div>
        </div>
        <div class="localization-row">
            <div class="param-group">
                <label for="localization_7nm_2025">7nm 2025</label>
                <input type="number" id="localization_7nm_2025" value="0.0" step="0.01" min="0" max="1">
            </div>
            <div class="param-group">
                <label for="localization_7nm_2031">7nm 2031</label>
                <input type="number" id="localization_7nm_2031" value="0.06" step="0.01" min="0" max="1">
            </div>
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Detection Time</strong><br><br>These parameters calibrate the relationship between workforce size and detection time using historical covert nuclear programs. Over the past 50 years, about a dozen states attempted to covertly develop nuclear weapons. For each case, we estimated the number of high-context workers involved and the time until detection (see attached data file).<br><br><strong>Functional Form:</strong><br>Detection time is modeled as a log-normal distribution:<br>• Mean detection time: μ(N) = μ₁₀₀ + (μ₁₀₀₀ - μ₁₀₀) × log₁₀(N/100) / log₁₀(10)<br>• Where N is the number of workers<br>• The mean scales logarithmically with workforce size<br>• Standard deviation σ is constant across workforce sizes<br><br>This parameter (μ₁₀₀) represents the expected detection time for a covert project with 100 high-context workers." data-download="/download/nuclear_case_studies">
            <label for="mean_detection_time_100">Expected time to detect covert project involving 100 people (years)</label>
            <input type="number" id="mean_detection_time_100" value="6.95" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Detection Time</strong><br><br>These parameters calibrate the relationship between workforce size and detection time using historical covert nuclear programs. Over the past 50 years, about a dozen states attempted to covertly develop nuclear weapons. For each case, we estimated the number of high-context workers involved and the time until detection (see attached data file).<br><br><strong>Functional Form:</strong><br>Detection time is modeled as a log-normal distribution:<br>• Mean detection time: μ(N) = μ₁₀₀ + (μ₁₀₀₀ - μ₁₀₀) × log₁₀(N/100) / log₁₀(10)<br>• Where N is the number of workers<br>• The mean scales logarithmically with workforce size<br>• Standard deviation σ is constant across workforce sizes<br><br>This parameter (μ₁₀₀₀) represents the expected detection time for a covert project with 1000 high-context workers." data-download="/download/nuclear_case_studies">
            <label for="mean_detection_time_1000">Expected time to detect covert project involving 1000 people (years)</label>
            <input type="number" id="mean_detection_time_1000" value="3.42" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Detection Time</strong><br><br>These parameters calibrate the relationship between workforce size and detection time using historical covert nuclear programs. Over the past 50 years, about a dozen states attempted to covertly develop nuclear weapons. For each case, we estimated the number of high-context workers involved and the time until detection (see attached data file).<br><br><strong>Functional Form:</strong><br>Detection time is modeled as a log-normal distribution:<br>• Mean detection time: μ(N) = μ₁₀₀ + (μ₁₀₀₀ - μ₁₀₀) × log₁₀(N/100) / log₁₀(10)<br>• Where N is the number of workers<br>• The mean scales logarithmically with workforce size<br>• Standard deviation σ is constant across workforce sizes<br><br>This parameter (σ) represents the standard deviation of the log-normal distribution." data-download="/download/nuclear_case_studies">
            <label for="variance_detection_time">Detection time sigma (years)</label>
            <input type="number" id="variance_detection_time" value="3.88" step="0.01">
        </div>

        <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">

        <h3 style="font-size: 14px; margin-top: 15px; color: #777;">Compute Production Rate</h3>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>Fab Construction Time</strong><br><br>Fab construction time depends on production capacity and construction labor. Time from 'breaking ground' to production ranges from 1-3 years for declared fabs.<br><br><img src='/static/fab_construction_time/construction_time_plot.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Construction time vs capacity'><br><br><strong>The Secrecy Tax:</strong><br>Covert fabs may take longer due to secrecy requirements. Comparing declared vs undeclared nuclear enrichment facilities: declared took 3.7 years on average, undeclared took 5.5 years - a 1.5x 'secrecy tax'.<br><br><img src='/static/fab_construction_time/construction_time_cdf.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Nuclear facility construction comparison'><br><br>So realistic timeframes for covert fabs: 1.5-4.5 years.<br><br><img src='/static/fab_construction_time/construction_time_plot_adjusted.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Adjusted construction time'><br><br><strong>Construction Labor:</strong><br>McKinsey estimates ~100 workers per $1B construction cost. If labor is undersupplied by factor X, construction takes X times longer. If oversupplied, no speedup (fixed-ratios production function).<br><br><img src='/static/fab_construction_time/construction_time_vs_labor.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Construction time vs labor'><br><br><img src='/static/fab_construction_time/cost_of_fab_plot.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Production capacity vs cost'>"
             data-download="/download/construction_time_vs_fab_capacity">
            <label for="construction_time_5k">Construction time of 5k wafers/month fab (years)</label>
            <input type="number" id="construction_time_5k" value="1.40" step="0.01">
        </div>
        <div class="param-group">
            <label for="construction_time_100k">Construction time of 100k wafers/month fab (years)</label>
            <input type="number" id="construction_time_100k" value="2.41" step="0.01">
        </div>
        <div class="param-group">
            <label for="construction_time_sigma">Construction time sigma (log scale, years)</label>
            <input type="number" id="construction_time_sigma" value="0.35" step="0.01">
        </div>
        <div class="param-group">
            <label for="construction_workers_per_1000">Construction workers per 1000 wafers/month</label>
            <input type="number" id="construction_workers_per_1000" value="14.1" step="0.1">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Operating Labor and Fab Production Capacity</strong><br><br>Fab production capacity depends on two main factors:<br>• Operating labor<br>• Quantity of SME<br><br>The relationship between the number of workers involved in operating a fab and its production capacity is shown in the attached plot, which displays wafers per month vs operating labor.<br><br>This regression trend is used in the model to estimate production capacity based on the allocated operating workforce.<br><br><strong>Production Function:</strong><br>The model uses a fixed-proportions production function where fab output is the minimum of labor and scanner constraints:<br><br>Production = min(24.6 × operating labor, 1000 × num scanners)" data-image="/static/fab_production/labor_vs_production.png" data-download="/download/compute_production_vs_operating_labor">
            <label for="wafers_per_month_per_worker">Wafers/month per operating worker</label>
            <input type="number" id="wafers_per_month_per_worker" value="24.64" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Operating Labor and Fab Production Capacity</strong><br><br>Fab production capacity depends on two main factors:<br>• Operating labor<br>• Quantity of SME<br><br>The relationship between the number of workers involved in operating a fab and its production capacity is shown in the attached plot, which displays wafers per month vs operating labor.<br><br>This regression trend is used in the model to estimate production capacity based on the allocated operating workforce.<br><br><strong>Production Function:</strong><br>The model uses a fixed-proportions production function where fab output is the minimum of labor and scanner constraints:<br><br>Production = min(24.6 × operating labor, 1000 × num scanners)" data-image="/static/fab_production/labor_vs_production.png" data-download="/download/compute_production_vs_operating_labor">
            <label for="labor_productivity_sigma">Wafers per month per operating worker sigma (log scale, wafers/month)</label>
            <input type="number" id="labor_productivity_sigma" value="0.62" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>Photolithography Scanner Production Capacity</strong><br><br>Advanced photolithography scanners are often the main bottleneck to chip production. ASML claims that its DUV lithography machines can pattern around 250 wafers per hour, or 180,000 wafers per month.<br><br>However, each chip typically requires around 80 patterning steps and scanners operate at roughly 50% utilization. Therefore, each machine processes approximately:<br><br>0.5 × 180,000 / 80 = 1,000 completed wafers per month<br><br><strong>Production Function:</strong><br>The model uses a fixed-proportions production function where fab output is the minimum of labor and scanner constraints:<br><br>Production = min(24.6 × operating labor, 1000 × num scanners)">
            <label for="wafers_per_month_per_scanner">Wafers/month per photolithography scanner</label>
            <input type="number" id="wafers_per_month_per_scanner" value="1000" step="1">
        </div>
        <div class="param-group">
            <label for="scanner_productivity_sigma">Wafers per month per photolithography scanner sigma (log scale, wafers/month)</label>
            <input type="number" id="scanner_productivity_sigma" value="0.20" step="0.01">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>PRC Lithography Scanner Production Ramp-Up</strong><br><br>To estimate the total number of indigenous lithography scanners the PRC has at a given time, we model their production ramp-up based on historical ASML scaling patterns.<br><br>The attached plot shows how quickly ASML scaled production of a given lithography machine after it was first used in high volume production. The model assumes that PRC photolithography scanner production follows a similar trend (shown as the orange trendline) starting from the date when the PRC achieves high volume production at a given node.<br><br>This parameter represents the number of scanners produced in the first year after achieving high volume production capability." data-image="/static/fab_production/lithography_sales_plot.png" data-download="/download/asml_sales_history">
            <label for="prc_scanners_first_year">Prc scanners produced in first year after high volume production is achieved</label>
            <input type="number" id="prc_scanners_first_year" value="20.0" step="1">
        </div>
        <div class="param-group has-tooltip" data-tooltip="<strong>PRC Lithography Scanner Production Ramp-Up</strong><br><br>To estimate the total number of indigenous lithography scanners the PRC has at a given time, we model their production ramp-up based on historical ASML scaling patterns.<br><br>The attached plot shows how quickly ASML scaled production of a given lithography machine after it was first used in high volume production. The model assumes that PRC photolithography scanner production follows a similar trend (shown as the orange trendline) starting from the date when the PRC achieves high volume production at a given node.<br><br>This parameter represents the annual increase in scanner production after the first year." data-image="/static/fab_production/lithography_sales_plot.png" data-download="/download/asml_sales_history">
            <label for="prc_scanners_per_year">Annual increase of scanner production</label>
            <input type="number" id="prc_scanners_per_year" value="16.0" step="1">
        </div>
        <div class="param-group">
            <label for="prc_scanner_production_sigma">Prc scanner production sigma (log scale, scanners/year)</label>
            <input type="number" id="prc_scanner_production_sigma" value="0.30" step="0.01">
        </div>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>H100-sized Chips per Wafer (Yield)</strong><br><br>The value of 28 H100-sized chips per wafer represents the yield that TSMC achieved when manufacturing H100s for NVIDIA.<br><br>Source: <a href='https://www.trendforce.com/news/2024/03/18/news-tsmc-boosts-investment-in-advanced-packaging-with-ntd-500-billion-plan-to-build-six-plants-in-chiayi-science-park/' style='color: #6db4ff;' target='_blank'>TrendForce (March 2024)</a>">
            <label for="chips_per_wafer">H100-sized chips per wafer (yield)</label>
            <input type="number" id="chips_per_wafer" value="28" step="1">
        </div>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>Transistor Density</strong><br><br>Transistor density depends on the process node - the resolution at which circuits can be patterned onto the wafer. Historical data shows how transistor density (in millions of transistors per mm²) varies across different process nodes.<br><br>The figure below shows the relationship between process node (bottom axis) and H100 equivalents per wafer with 2022 architectures (left axis). This assumes a yield of 28 H100-sized chips per wafer."
             data-image="/static/compute_density/h100_equiv_per_year_vs_process_node.png"
             data-download="/download/transistor_density_vs_node">
            <label for="transistor_density_exponent">Transistor density increase for every halving of process node</label>
            <input type="number" id="transistor_density_exponent" value="1.49" step="0.01">
        </div>
        <div class="param-group has-tooltip"
             data-tooltip="<strong>Architecture Efficiency</strong><br><br>Over time, chip architectures improve and chips deliver more performance. To predict these improvements, we infer architecture efficiency by comparing how total chip performance has improved versus transistor density improvements.<br><br>According to <a href='https://epoch.ai/blog/trends-in-machine-learning-hardware' style='color: #6db4ff;'>Epoch's data</a>, total performance (TPP/Die Area) has improved at roughly 1.55x per year:<br><br><img src='/static/compute_density/tpp_per_die_area.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='TPP per die area over time'><br><br>However, transistor density has only increased at 1.26x per year:<br><br><img src='/static/compute_density/transistor_density_over_time.png' style='width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;' alt='Transistor density over time'><br><br>Therefore, architecture improvements have increased TPP/Die Area by around 1.55 / 1.26 = <strong>1.23x per year</strong>.">
            <label for="architecture_efficiency">Rate of architecture efficiency improvement per year</label>
            <input type="number" id="architecture_efficiency" value="1.23" step="0.01">
        </div>
    </div>

    <div class="main-content">
        <div class="loading active" id="loading">
            <h2>Running Simulation...</h2>
            <p>This may take a few moments.</p>
        </div>

        <div id="plots" style="display: none;">
            <h1 style="font-size: 32px; font-weight: bold; margin-bottom: 20px; margin-top: 0; color: #333;">Covert PRC Fab</h1>
            <div class="top-plots">
                <div class="dashboard">
                    <div class="dashboard-item">
                        <div class="dashboard-value" id="dashboard80thH100e">--</div>
                        <div class="dashboard-label">80th %ile H100e Before Detection</div>
                        <div class="dashboard-sublabel">Detection = US estimates 50% probability of covert fab</div>
                    </div>
                    <div class="dashboard-item">
                        <div class="dashboard-value" id="dashboard80thTime">--</div>
                        <div class="dashboard-label">80th %ile Years Operational Before Detection</div>
                    </div>
                    <div class="dashboard-item">
                        <div class="dashboard-value" id="dashboard80thNode">--</div>
                        <div class="dashboard-label">80th %ile Process Node</div>
                    </div>
                </div>

                <div class="plot-container">
                    <div class="plot-title">Covert Compute Produced Before Detection</div>
                    <div id="computeCcdfPlot" class="plot"></div>
                </div>

                <div class="plot-container">
                    <div class="plot-title">Simulation Runs</div>
                    <div id="timeSeriesPlot" class="plot"></div>
                </div>
            </div>

            <div class="breakdown-section">
                <div class="breakdown-title">Odds of Covert Project Breakdown</div>
                <div class="section-description">
                    Posterior Odds = Prior Odds × LR<sub>inventory</sub> × LR<sub>procurement</sub> × LR<sub>other</sub><br>
                    Combine prior belief with evidence from three independent intelligence sources to estimate detection likelihood.
                </div>
                <div class="breakdown-grid">
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                        <div id="priorOddsDisplay" class="breakdown-plot" style="display: flex; align-items: center; justify-content: center; font-size: 32px; font-weight: bold; color: #555; padding: 20px;">
                            --
                        </div>
                        <div class="breakdown-label">Prior Odds of<br>Covert Project</div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="lrInventoryPlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">Likelihood Ratio from<br>Inventory Accounting</div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="lrProcurementPlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">Likelihood Ratio from<br>Procurement Accounting</div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="lrOtherPlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">Likelihood Ratio from Other Intelligence Sources<br>(e.g. HUMINT, SIGINT, IMINT)</div>
                    </div>
                    <div class="operator">=</div>
                    <div class="breakdown-item">
                        <div id="posteriorOddsPlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">Posterior Odds of<br>Covert Project</div>
                    </div>
                </div>
            </div>

            <div class="breakdown-section">
                <div class="breakdown-title">Compute Production Rate Breakdown</div>
                <div class="section-description">
                    H100e per month = Probability Operational × Wafer Starts per Month × H100-sized Chips per Wafer × H100e per Chip × Architecture Efficiency
                </div>
                <div class="breakdown-grid">
                    <div class="breakdown-item">
                        <div id="isOperationalPlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">Probability Operational</div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="waferStartsPlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">Wafer Starts per Month</div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item" style="flex: 0 0 140px; min-width: 140px;">
                        <div id="chipsPerWaferPlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">H100-sized Chips per Wafer</div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="computePerChipPlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">H100e per Chip (H100 architecture)</div>
                    </div>
                    <div class="operator">×</div>
                    <div class="breakdown-item">
                        <div id="architectureEfficiencyPlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">Architecture Efficiency (relative to H100)</div>
                    </div>
                    <div class="operator">=</div>
                    <div class="breakdown-item">
                        <div id="totalComputePlot" class="breakdown-plot"></div>
                        <div class="breakdown-label">Total H100e per Month</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const runButton = document.getElementById('runSimulation');
        const statusDiv = document.getElementById('status');
        const loadingDiv = document.getElementById('loading');
        const plotsDiv = document.getElementById('plots');

        function setStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
        }

        function getParameters() {
            return {
                agreement_year: parseFloat(document.getElementById('agreement_year').value),
                end_year: parseFloat(document.getElementById('end_year').value),
                increment: parseFloat(document.getElementById('increment').value),
                num_simulations: parseInt(document.getElementById('num_simulations').value),
                run_covert_project: document.getElementById('run_covert_project').checked,
                build_covert_fab: document.getElementById('build_covert_fab').checked,
                operating_labor: parseInt(document.getElementById('operating_labor').value),
                construction_labor: parseInt(document.getElementById('construction_labor').value),
                process_node: document.getElementById('process_node').value,
                scanner_proportion: parseFloat(document.getElementById('scanner_proportion').value),
                p_fab_exists: parseFloat(document.getElementById('p_fab_exists').value),
                // Detection parameters
                proportion_of_diverted_sme_with_50p_chance_of_detection: parseFloat(document.getElementById('proportion_diverted_sme').value),
                mean_detection_time_for_100_workers: parseFloat(document.getElementById('mean_detection_time_100').value),
                mean_detection_time_for_1000_workers: parseFloat(document.getElementById('mean_detection_time_1000').value),
                variance_of_detection_time_given_num_workers: parseFloat(document.getElementById('variance_detection_time').value),
                // Production capacity
                wafers_per_month_per_worker: parseFloat(document.getElementById('wafers_per_month_per_worker').value),
                labor_productivity_relative_sigma: parseFloat(document.getElementById('labor_productivity_sigma').value),
                wafers_per_month_per_lithography_scanner: parseFloat(document.getElementById('wafers_per_month_per_scanner').value),
                scanner_productivity_relative_sigma: parseFloat(document.getElementById('scanner_productivity_sigma').value),
                // Construction time
                construction_time_for_5k_wafers_per_month: parseFloat(document.getElementById('construction_time_5k').value),
                construction_time_for_100k_wafers_per_month: parseFloat(document.getElementById('construction_time_100k').value),
                construction_time_relative_sigma: parseFloat(document.getElementById('construction_time_sigma').value),
                construction_workers_per_1000_wafers_per_month: parseFloat(document.getElementById('construction_workers_per_1000').value),
                // Chip production
                h100_sized_chips_per_wafer: parseFloat(document.getElementById('chips_per_wafer').value),
                transistor_density_scaling_exponent: parseFloat(document.getElementById('transistor_density_exponent').value),
                architecture_efficiency_improvement_per_year: parseFloat(document.getElementById('architecture_efficiency').value),
                // PRC scanner production
                prc_lithography_scanners_produced_in_first_year: parseFloat(document.getElementById('prc_scanners_first_year').value),
                prc_additional_lithography_scanners_produced_per_year: parseFloat(document.getElementById('prc_scanners_per_year').value),
                prc_scanner_production_relative_sigma: parseFloat(document.getElementById('prc_scanner_production_sigma').value),
                // Localization probabilities
                localization_130nm_2025: parseFloat(document.getElementById('localization_130nm_2025').value),
                localization_130nm_2031: parseFloat(document.getElementById('localization_130nm_2031').value),
                localization_28nm_2025: parseFloat(document.getElementById('localization_28nm_2025').value),
                localization_28nm_2031: parseFloat(document.getElementById('localization_28nm_2031').value),
                localization_14nm_2025: parseFloat(document.getElementById('localization_14nm_2025').value),
                localization_14nm_2031: parseFloat(document.getElementById('localization_14nm_2031').value),
                localization_7nm_2025: parseFloat(document.getElementById('localization_7nm_2025').value),
                localization_7nm_2031: parseFloat(document.getElementById('localization_7nm_2031').value)
            };
        }

        function plotTimeSeries(data) {
            const ts = data.time_series;

            // Better color scheme
            const probColor = '#5B8DBE'; // Muted blue
            const computeColor = '#9B7BB3'; // Purple

            // Create traces for individual simulations (show first 100 for performance)
            const individualsToShow = Math.min(100, ts.individual_us_probs.length);
            const individualUsProbs = ts.individual_us_probs.slice(0, individualsToShow).map((probs, idx) => ({
                x: ts.years,
                y: probs,
                type: 'scatter',
                mode: 'lines',
                line: { color: probColor, width: 0.8 },
                opacity: 0.08,
                showlegend: false,
                hoverinfo: 'skip'
            }));

            const individualH100e = ts.individual_h100e.slice(0, individualsToShow).map((h100e, idx) => ({
                x: ts.years,
                y: h100e,
                type: 'scatter',
                mode: 'lines',
                line: { color: computeColor, width: 0.8 },
                opacity: 0.08,
                showlegend: false,
                hoverinfo: 'skip',
                yaxis: 'y2'
            }));

            // Median and percentile traces
            const traces = [
                ...individualUsProbs,
                {
                    x: ts.years,
                    y: ts.us_prob_p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip'
                },
                {
                    x: ts.years,
                    y: ts.us_prob_p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: probColor + '30',
                    line: { color: 'transparent' },
                    name: '25th-75th %ile (Prob)',
                    hovertemplate: 'Prob: %{y:.3f}<extra></extra>'
                },
                {
                    x: ts.years,
                    y: ts.us_prob_median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: probColor, width: 3 },
                    name: 'Median US Prob',
                    hovertemplate: 'Prob: %{y:.3f}<extra></extra>'
                },
                ...individualH100e,
                {
                    x: ts.years,
                    y: ts.h100e_p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'transparent' },
                    showlegend: false,
                    hoverinfo: 'skip',
                    yaxis: 'y2'
                },
                {
                    x: ts.years,
                    y: ts.h100e_p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: computeColor + '30',
                    line: { color: 'transparent' },
                    name: '25th-75th %ile (H100e)',
                    yaxis: 'y2',
                    hovertemplate: 'H100e: %{y:.1f}K<extra></extra>'
                },
                {
                    x: ts.years,
                    y: ts.h100e_median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: computeColor, width: 3 },
                    name: 'Median H100e',
                    yaxis: 'y2',
                    hovertemplate: 'H100e: %{y:.1f}K<extra></extra>'
                }
            ];

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 11 },
                    automargin: true
                },
                yaxis: {
                    title: 'US Probability of Covert Fab',
                    titlefont: { size: 11, color: probColor },
                    tickfont: { size: 10, color: probColor },
                    range: [0, 1],
                    side: 'left',
                    automargin: true
                },
                yaxis2: {
                    title: 'H100e Produced by Fab (thousands)',
                    titlefont: { size: 11, color: computeColor },
                    tickfont: { size: 10, color: computeColor },
                    overlaying: 'y',
                    side: 'right',
                    range: [0, 1000],
                    automargin: true
                },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: -0.25,
                    xanchor: 'left',
                    yanchor: 'top',
                    orientation: 'h',
                    font: { size: 10 }
                },
                hovermode: 'x unified',
                margin: { l: 50, r: 50, t: 10, b: 70, pad: 10 }
            };

            Plotly.newPlot('timeSeriesPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('timeSeriesPlot'), 50);
        }

        function plotComputeCcdf(data) {
            if (!data.compute_ccdfs) {
                document.getElementById('computeCcdfPlot').innerHTML = '<p>No detection data available</p>';
                return;
            }

            const traces = [];
            const thresholds = [
                { value: 0.5, label: 'P(fab) ≥ 50%', color: '#9B7BB3' },  // Purple
                { value: 0.25, label: 'P(fab) ≥ 25%', color: '#5B8DBE' },  // Blue
                { value: 0.125, label: 'P(fab) ≥ 12.5%', color: '#5AA89B' }  // Blue-green
            ];

            for (const threshold of thresholds) {
                const ccdf = data.compute_ccdfs[threshold.value];
                if (ccdf && ccdf.length > 0) {
                    traces.push({
                        x: ccdf.map(d => d.x),
                        y: ccdf.map(d => d.y),
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: threshold.color, width: 2 },
                        name: `"Detection" means ${threshold.label}`,
                        hovertemplate: 'H100e: %{x:.0f}<br>P(≥x): %{y:.3f}<extra></extra>'
                    });
                }
            }

            const layout = {
                xaxis: {
                    title: "H100e Produced by Covert Fab Before 'Detection'",
                    titlefont: { size: 11 },
                    tickfont: { size: 10 },
                    type: 'log',
                    automargin: true
                },
                yaxis: {
                    title: 'P(Covert compute produced before detection > x)',
                    titlefont: { size: 11 },
                    tickfont: { size: 10 },
                    range: [0, 1],
                    automargin: true
                },
                showlegend: true,
                legend: {
                    x: 0.98,
                    y: 0.98,
                    xanchor: 'right',
                    yanchor: 'top',
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ccc',
                    borderwidth: 1
                },
                hovermode: 'closest',
                margin: { l: 50, r: 50, t: 10, b: 50, pad: 10 }
            };

            Plotly.newPlot('computeCcdfPlot', traces, layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize('computeCcdfPlot'), 50);
        }

        function plotPDF(divId, values, color, xAxisLabel, nbins = 30, logScale = false) {
            // Create histogram/PDF from values
            const trace = {
                x: values,
                type: 'histogram',
                histnorm: 'probability density',
                marker: { color: color, line: { width: 0.5, color: 'white' } },
                hovertemplate: '%{x:.2f}<br>Density: %{y:.3f}<extra></extra>',
                nbinsx: nbins
            };

            const layout = {
                xaxis: {
                    title: xAxisLabel,
                    titlefont: { size: 10 },
                    automargin: true,
                    tickfont: { size: 9 },
                    type: logScale ? 'log' : 'linear',
                    autorange: true
                },
                yaxis: {
                    title: 'Density',
                    titlefont: { size: 10 },
                    automargin: true,
                    tickfont: { size: 9 }
                },
                showlegend: false,
                margin: { l: 50, r: 50, t: 10, b: 40, pad: 10 },
                hovermode: 'closest'
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotMedianWithPercentiles(divId, data, years, color, yAxisLabel = '') {
            // Plot median with 25th-75th percentile bands
            const traces = [];

            // Add individual simulation lines if provided
            if (data.individual) {
                const individualsToPlot = data.individual.slice(0, 100);
                for (let i = 0; i < individualsToPlot.length; i++) {
                    traces.push({
                        x: years,
                        y: individualsToPlot[i],
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: color, width: 0.5 },
                        opacity: 0.08,
                        showlegend: false,
                        hoverinfo: 'skip'
                    });
                }
            }

            // Add percentile bands
            traces.push(
                {
                    x: years,
                    y: data.p25,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: color, width: 1, dash: 'dot' },
                    opacity: 0.4,
                    showlegend: false,
                    hoverinfo: 'skip',
                    name: '25th percentile'
                },
                {
                    x: years,
                    y: data.p75,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    fillcolor: color + '60',
                    line: { color: color, width: 1, dash: 'dot' },
                    opacity: 0.5,
                    showlegend: false,
                    hoverinfo: 'skip',
                    name: '75th percentile'
                },
                {
                    x: years,
                    y: data.median,
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: color, width: 2.5 },
                    showlegend: false,
                    hovertemplate: 'Year: %{x:.1f}<br>Value: %{y:.2f}<extra></extra>',
                    name: 'Median'
                }
            );

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    range: [years[0] - 0.1, years[years.length - 1] + 0.1],
                    autorange: false,
                    fixedrange: true
                },
                yaxis: {
                    title: yAxisLabel,
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 50, t: 10, b: 40, pad: 10 },
                hovermode: 'x'
            };

            Plotly.newPlot(divId, traces, layout, {displayModeBar: false, responsive: true});
            // Force resize after a small delay
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotBarByProcessNode(divId, values, processNodes, color) {
            // Group by process node and compute per wafer value
            const nodeValueCounts = {};
            values.forEach((v, idx) => {
                const rounded = Math.round(v * 1000) / 1000; // Round to 3 decimal places
                const node = processNodes[idx];
                const key = `${rounded}|${node}`;
                nodeValueCounts[key] = (nodeValueCounts[key] || 0) + 1;
            });

            // Parse and sort by value
            const entries = Object.entries(nodeValueCounts).map(([key, count]) => {
                const [value, node] = key.split('|');
                return { value: parseFloat(value), node, count };
            });
            entries.sort((a, b) => a.value - b.value);

            // Convert counts to proportions
            const totalCount = values.length;
            const labels = entries.map(e => `${e.value.toFixed(2)} H100e (${e.node})`);
            const proportions = entries.map(e => e.count / totalCount);

            const trace = {
                x: labels,
                y: proportions,
                type: 'bar',
                marker: {
                    color: color,
                    line: { width: 1, color: 'white' }
                },
                textposition: 'auto',
                hovertemplate: '%{x}<br>Probability: %{y:.3f}<extra></extra>'
            };

            const layout = {
                xaxis: {
                    title: '',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    type: 'category'
                },
                yaxis: {
                    title: 'Probability',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 50, t: 10, b: 50, pad: 10 },
                hovermode: 'closest',
                bargap: 0.2
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotProportionOperational(divId, data, years, color, yAxisLabel = '') {
            // Calculate proportion operational at each timestep
            const proportions = data.median; // This is already the proportion since we're averaging 0s and 1s

            const trace = {
                x: years,
                y: proportions,
                type: 'scatter',
                mode: 'lines',
                line: { color: color, width: 2 },
                fill: 'tozeroy',
                fillcolor: color + '20',
                hovertemplate: 'Year: %{x:.1f}<br>Proportion: %{y:.2f}<extra></extra>'
            };

            const layout = {
                xaxis: {
                    title: 'Year',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    range: [years[0] - 0.1, years[years.length - 1] + 0.1],
                    autorange: false,
                    fixedrange: true
                },
                yaxis: {
                    title: yAxisLabel,
                    range: [0, 1],
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 50, t: 10, b: 40, pad: 10 },
                hovermode: 'x'
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            // Force resize after a small delay
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function plotCategoricalFrequency(divId, values, categories, color) {
            // Count frequencies for each category
            const frequencies = categories.map(cat =>
                values.filter(v => v === cat.value).length
            );

            // Convert to proportions
            const total = values.length;
            const proportions = frequencies.map(f => f / total);

            const trace = {
                x: categories.map(cat => cat.label),
                y: proportions,
                type: 'bar',
                marker: {
                    color: color,
                    line: { width: 1, color: 'white' }
                },
                textposition: 'auto',
                hovertemplate: '%{x}<br>Probability: %{y:.3f}<extra></extra>'
            };

            const layout = {
                xaxis: {
                    title: '',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true,
                    type: 'category'
                },
                yaxis: {
                    title: 'Probability',
                    titlefont: { size: 10 },
                    tickfont: { size: 9 },
                    automargin: true
                },
                showlegend: false,
                margin: { l: 50, r: 50, t: 10, b: 50, pad: 10 },
                hovermode: 'closest',
                bargap: 0.2
            };

            Plotly.newPlot(divId, [trace], layout, {displayModeBar: false, responsive: true});
            setTimeout(() => Plotly.Plots.resize(divId), 50);
        }

        function updateDashboard(data) {
            // Calculate 80th percentile H100e before detection
            const h100eValues = data.individual_h100e_before_detection || [];
            if (h100eValues.length > 0) {
                const sorted = [...h100eValues].sort((a, b) => a - b);
                const idx80 = Math.floor(sorted.length * 0.8);
                const h100e80th = sorted[idx80];
                // Round to nearest 100,000
                const rounded = Math.round(h100e80th / 100000) * 100000;
                document.getElementById('dashboard80thH100e').textContent =
                    rounded >= 1000 ? `~${(rounded / 1000).toFixed(0)}K` : `~${rounded.toFixed(0)}`;
            }

            // Calculate 80th percentile time before detection
            const timeValues = data.individual_time_before_detection || [];
            if (timeValues.length > 0) {
                const sorted = [...timeValues].sort((a, b) => a - b);
                const idx80 = Math.floor(sorted.length * 0.8);
                const time80th = sorted[idx80];
                document.getElementById('dashboard80thTime').textContent = time80th.toFixed(1);
            }

            // Calculate 80th percentile process node (treating as ordinal: smaller nm = better)
            const nodeValues = data.individual_process_node || [];
            if (nodeValues.length > 0) {
                // Extract numeric values from nodes (e.g., "28nm" -> 28)
                const numericNodes = nodeValues.map(node => {
                    const match = node.toString().match(/(\d+)/);
                    return match ? parseInt(match[1]) : 0;
                });

                // Sort numerically (smaller is better/more advanced)
                const sorted = [...numericNodes].sort((a, b) => a - b);
                const idx80 = Math.floor(sorted.length * 0.8);
                const node80th = sorted[idx80];

                document.getElementById('dashboard80thNode').textContent = `${node80th}nm`;
            }
        }

        async function runSimulation() {
            runButton.disabled = true;
            loadingDiv.classList.add('active');
            plotsDiv.style.display = 'none';
            setStatus('Running simulation...', 'info');

            try {
                const params = getParameters();
                const response = await fetch('/run_simulation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    throw new Error('Simulation failed');
                }

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                // Update dashboard
                updateDashboard(data);

                // Plot main charts
                plotTimeSeries(data);
                plotComputeCcdf(data);

                // Force resize after a brief delay to ensure plots fill containers
                setTimeout(() => {
                    Plotly.Plots.resize('timeSeriesPlot');
                    Plotly.Plots.resize('computeCcdfPlot');
                }, 100);

                // Plot LR breakdown
                if (data.lr_components && data.lr_components.inventory_median) {
                    const years = data.time_series.years;

                    // Get prior probability from parameters and calculate prior odds
                    const priorProb = getParameters().p_fab_exists;
                    const priorOdds = priorProb / (1 - priorProb);

                    // Display prior odds
                    document.getElementById('priorOddsDisplay').innerHTML =
                        `<div style="font-size: 28px; font-weight: bold; color: #555;">${priorOdds.toFixed(3)}</div>`;

                    // LR Inventory - PDF of values across simulations at final timestep
                    const lrInventoryFinal = data.lr_components.inventory_individual.map(sim => sim[sim.length - 1]);
                    console.log('LR Inventory values:', lrInventoryFinal);
                    console.log('LR Inventory min:', Math.min(...lrInventoryFinal), 'max:', Math.max(...lrInventoryFinal));
                    // Convert to log10 scale to show values both above and below 1
                    const lrInventoryLog = lrInventoryFinal.map(lr => Math.log10(lr));
                    plotPDF('lrInventoryPlot', lrInventoryLog, '#D97676', 'log₁₀(LR)', 10, false);

                    // LR Procurement - Categorical bar plot (1 or 10)
                    const lrProcurementFinal = data.lr_components.procurement_individual.map(sim => sim[sim.length - 1]);
                    plotCategoricalFrequency('lrProcurementPlot', lrProcurementFinal, [
                        { value: 1, label: 'LR = 1 (>90% localization)' },
                        { value: 10, label: 'LR = 10 (≤90% localization)' }
                    ], '#6B9BD1');

                    // LR Other - Median over time with percentiles
                    const lrOtherArray = data.lr_components.other_individual.map(sim => sim.map(v => v));
                    const lrOtherP25 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.25)];
                    });
                    const lrOtherP75 = years.map((_, i) => {
                        const values = lrOtherArray.map(sim => sim[i]);
                        return values.sort((a, b) => a - b)[Math.floor(values.length * 0.75)];
                    });
                    plotMedianWithPercentiles('lrOtherPlot', {
                        median: data.lr_components.other_median,
                        p25: lrOtherP25,
                        p75: lrOtherP75,
                        individual: data.lr_components.other_individual
                    }, years, '#7CAE7A', 'Likelihood Ratio');

                    // Calculate posterior odds (prior odds * total LR) - PDF
                    const posteriorOddsFinal = data.lr_components.inventory_individual.map((invSim, simIdx) => {
                        const i = invSim.length - 1;
                        const totalLR = invSim[i] * data.lr_components.procurement_individual[simIdx][i] * data.lr_components.other_individual[simIdx][i];
                        return priorOdds * totalLR;
                    });
                    plotPDF('posteriorOddsPlot', posteriorOddsFinal, '#9B7BB3', 'Odds');
                }

                // Plot compute breakdown
                if (data.compute_factors && data.compute_factors.is_operational_median) {
                    const years = data.time_series.years;

                    // Proportion Operational - time series showing proportion
                    plotProportionOperational('isOperationalPlot', {
                        median: data.compute_factors.is_operational_median
                    }, years, '#D4A574', 'Probability');

                    // Wafer Starts per Month - PDF
                    const waferStartsFinal = data.compute_factors.wafer_starts_individual.map(sim => sim[sim.length - 1]);
                    plotPDF('waferStartsPlot', waferStartsFinal, '#74B3A8', 'Wafers/Month');

                    // H100-sized Chips per Wafer - Display as a box (constant value)
                    const chipsPerWaferValue = data.compute_factors.chips_per_wafer_individual[0][0]; // Same for all sims
                    document.getElementById('chipsPerWaferPlot').innerHTML = `<div style="display: flex; align-items: center; justify-content: center; font-size: 32px; font-weight: bold; color: #555; padding: 20px;">${chipsPerWaferValue.toFixed(0)}</div>`;

                    // H100e per Chip (H100 architecture) - Bar plot at final timestep
                    const computePerChip2022Final = data.compute_factors.compute_per_wafer_2022_arch_individual.map(sim => sim[sim.length - 1]);
                    const processNodes = data.compute_factors.process_node_by_sim;
                    plotBarByProcessNode('computePerChipPlot', computePerChip2022Final, processNodes, '#E8A863');

                    // Architecture Efficiency - median over time with percentiles (smooth curve)
                    if (data.compute_factors.architecture_efficiency_individual && data.compute_factors.architecture_efficiency_individual.length > 0) {
                        const archEffArray = data.compute_factors.architecture_efficiency_individual.map(sim => sim.map(v => v));
                        const archEffP25 = years.map((_, i) => {
                            const values = archEffArray.map(sim => sim[i]).filter(v => v !== undefined && v !== null);
                            if (values.length === 0) return 0;
                            const sorted = values.sort((a, b) => a - b);
                            return sorted[Math.floor(sorted.length * 0.25)];
                        });
                        const archEffP75 = years.map((_, i) => {
                            const values = archEffArray.map(sim => sim[i]).filter(v => v !== undefined && v !== null);
                            if (values.length === 0) return 0;
                            const sorted = values.sort((a, b) => a - b);
                            return sorted[Math.floor(sorted.length * 0.75)];
                        });
                        plotMedianWithPercentiles('architectureEfficiencyPlot', {
                            median: data.compute_factors.architecture_efficiency_median,
                            p25: archEffP25,
                            p75: archEffP75,
                            individual: data.compute_factors.architecture_efficiency_individual
                        }, years, '#A87DC4', 'Efficiency Multiplier');
                    }

                    // Total compute - PDF (at final timestep)
                    const totalComputeFinal = data.compute_factors.is_operational_individual.map((opSim, simIdx) => {
                        const i = opSim.length - 1;
                        return (opSim[i] * data.compute_factors.wafer_starts_individual[simIdx][i] *
                                data.compute_factors.chips_per_wafer_individual[simIdx][i] *
                                data.compute_factors.architecture_efficiency_individual[simIdx][i] *
                                data.compute_factors.compute_per_wafer_2022_arch_individual[simIdx][i]) / 1000;
                    });
                    plotPDF('totalComputePlot', totalComputeFinal, '#B56C6C', 'H100e/Month (K)');
                }

                plotsDiv.style.display = 'block';
                loadingDiv.classList.remove('active');
                setStatus(`Simulation complete! Ran ${data.num_simulations} simulations`, 'success');
            } catch (error) {
                loadingDiv.classList.remove('active');
                setStatus('Error: ' + error.message, 'error');
            } finally {
                runButton.disabled = false;
            }
        }

        runButton.addEventListener('click', runSimulation);

        // Run simulation automatically on page load
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(runSimulation, 500); // Small delay to ensure page is fully loaded
        });

        // Setup tooltip handlers
        const globalTooltip = document.getElementById('globalTooltip');
        const tooltipElements = document.querySelectorAll('.has-tooltip');

        let hideTooltipTimeout;
        let currentTooltipElement = null;

        function hideTooltip() {
            globalTooltip.classList.remove('visible');
            globalTooltip.style.opacity = '0';
            currentTooltipElement = null;
        }

        function isMouseOverElementOrTooltip(mouseEvent) {
            // Check if mouse is over the current tooltip element
            if (currentTooltipElement && currentTooltipElement.matches(':hover')) {
                return true;
            }
            // Check if mouse is over the tooltip itself
            if (globalTooltip.matches(':hover')) {
                return true;
            }
            return false;
        }

        tooltipElements.forEach(element => {
            element.addEventListener('mouseenter', (e) => {
                clearTimeout(hideTooltipTimeout);
                currentTooltipElement = element;
                const tooltipText = element.getAttribute('data-tooltip');
                const downloadUrl = element.getAttribute('data-download');
                const imageUrl = element.getAttribute('data-image');
                const imageBeforeText = element.getAttribute('data-image-before-text');
                const imageAfterText = element.getAttribute('data-image-after-text');

                if (tooltipText) {
                    // Add the tooltip text
                    let content = tooltipText;

                    // Add image if data-image attribute exists
                    if (imageUrl) {
                        if (imageBeforeText) {
                            // Insert image before the specified text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageBeforeText}`;
                        } else if (imageAfterText) {
                            // Insert image after the tooltip text, then add the after text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px; margin-bottom: 8px;" alt="Capabilities table"><br>${imageAfterText}`;
                        } else {
                            // Default: add image after tooltip text
                            content += `<br><br><img src="${imageUrl}" style="width: 100%; max-width: 470px; border-radius: 4px; margin-top: 8px;" alt="Capabilities table">`;
                        }
                    }

                    // Add download button only if data-download attribute exists
                    if (downloadUrl) {
                        const fileName = downloadUrl.split('/').pop() + '.csv';
                        content += `<br><br><button onclick='window.location.href="${downloadUrl}"' style='margin-top: 8px; padding: 6px 12px; background-color: #555; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; pointer-events: auto;'>Download ${fileName}</button>`;
                    }

                    globalTooltip.innerHTML = content;

                    // Get the position of the element
                    const rect = element.getBoundingClientRect();

                    // Position tooltip to the right of the element
                    globalTooltip.style.left = (rect.right + 10) + 'px';

                    // Calculate vertical position to keep tooltip within viewport
                    let topPosition = rect.top;

                    // Show tooltip temporarily to measure its height
                    globalTooltip.style.visibility = 'hidden';
                    globalTooltip.style.opacity = '1';
                    globalTooltip.classList.add('visible');

                    const tooltipHeight = globalTooltip.offsetHeight;
                    const viewportHeight = window.innerHeight;

                    // If tooltip would go off bottom of screen, adjust position
                    if (topPosition + tooltipHeight > viewportHeight) {
                        topPosition = Math.max(10, viewportHeight - tooltipHeight - 10);
                    }

                    // If tooltip would go off top of screen, adjust position
                    if (topPosition < 10) {
                        topPosition = 10;
                    }

                    globalTooltip.style.top = topPosition + 'px';

                    // Now show tooltip properly
                    globalTooltip.style.visibility = 'visible';
                }
            });

            element.addEventListener('mouseleave', (e) => {
                // Give a short delay to allow mouse to move to tooltip
                hideTooltipTimeout = setTimeout(() => {
                    // Only hide if mouse is not over the element or tooltip
                    if (!isMouseOverElementOrTooltip(e)) {
                        hideTooltip();
                    }
                }, 100);
            });
        });

        // Keep tooltip visible when hovering over it
        globalTooltip.addEventListener('mouseenter', () => {
            clearTimeout(hideTooltipTimeout);
        });

        globalTooltip.addEventListener('mouseleave', () => {
            // Check if we're moving back to the original element
            hideTooltipTimeout = setTimeout(() => {
                if (!isMouseOverElementOrTooltip(event)) {
                    hideTooltip();
                }
            }, 100);
        });

        // Make breakdown plots clickable and link to sidebar inputs
        const plotToInputMapping = {
            // Section 2: US Bayesian Inference plots
            'priorOddsDisplay': 'p_fab_exists',
            'lrInventoryPlot': 'proportion_diverted_sme', // US intelligence estimates
            'lrProcurementPlot': 'localization_130nm_2025', // Probability PRC achieves >90% indigenization
            'lrOtherPlot': 'mean_detection_time_100', // Detection time
            'posteriorOddsPlot': null, // Output, not an input

            // Section 3: Compute Production Rate plots
            'isOperationalPlot': 'construction_time_5k', // First construction time param
            'waferStartsPlot': 'wafers_per_month_per_worker', // Operating labor productivity
            'chipsPerWaferPlot': 'chips_per_wafer',
            'computePerChipPlot': 'transistor_density_exponent',
            'architectureEfficiencyPlot': 'architecture_efficiency',
            'totalComputePlot': null // Output, not an input
        };

        // Add clickable class and click handlers to plots with associated inputs
        Object.entries(plotToInputMapping).forEach(([plotId, inputId]) => {
            const plotElement = document.getElementById(plotId);
            if (plotElement && inputId) {
                plotElement.classList.add('clickable');
                plotElement.addEventListener('click', () => {
                    const inputElement = document.getElementById(inputId);
                    if (inputElement) {
                        // Scroll input into view
                        inputElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Focus and select the input
                        setTimeout(() => {
                            inputElement.focus();
                            inputElement.select();
                        }, 300);
                    }
                });
            }
        });
    </script>
</body>
</html>
